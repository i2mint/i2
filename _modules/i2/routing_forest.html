

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>i2.routing_forest &mdash; i2 0.1.48 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=b5e87a2a"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/toggleprompt.js?v=d7ede5d2"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            i2
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2.html">i2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/_deprecated.html">i2._deprecated</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/base.html">i2.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/castgraph.html">i2.castgraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/chain_map.html">i2.chain_map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/deco.html">i2.deco</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/doc_mint.html">i2.doc_mint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/errors.html">i2.errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/examples.html">i2.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/examples/castgraph_examples.html">i2.examples.castgraph_examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/examples/signature_calculus.html">i2.examples.signature_calculus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/footprints.html">i2.footprints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/io_trans.html">i2.io_trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/itypes.html">i2.itypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/key_path.html">i2.key_path</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/multi_object.html">i2.multi_object</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/routing_forest.html">i2.routing_forest</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/scrap.html">i2.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/scrap/scrap.html">i2.scrap.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/scrap/scrap_ch_variadics.html">i2.scrap.scrap_ch_variadics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/scrap/scrap_kwargs.html">i2.scrap.scrap_kwargs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/scrap/signature_bops.html">i2.scrap.signature_bops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/scrap/simple_pymint.html">i2.scrap.simple_pymint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/scrap/switch_case_tree.html">i2.scrap.switch_case_tree</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/signatures.html">i2.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests.html">i2.tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/footprints_test.html">i2.tests.footprints_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/objects_for_testing.html">i2.tests.objects_for_testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/signatures_test.html">i2.tests.signatures_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/test_castgraph.html">i2.tests.test_castgraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/test_util.html">i2.tests.test_util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/test_wrapper.html">i2.tests.test_wrapper</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/util.html">i2.tests.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/util.html">i2.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/wrapper.html">i2.wrapper</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">i2</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">i2.routing_forest</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for i2.routing_forest</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Tools to specify functions through trees and forests.</span>

<span class="sd">Whaaa?!?</span>

<span class="sd">Well, you see, often -- especially when writing transformers -- you have a series of</span>
<span class="sd">if/then conditions nested into eachother, in code, where it gets ugly and un-reusable.</span>

<span class="sd">This module explores ways to objectivy this: That is, to give us the means to create</span>
<span class="sd">such nested conditions in a way that we can define the parts as reusable operable</span>
<span class="sd">components.</span>

<span class="sd">Think of the relationship between the for loop (code) and the iterator (object), along</span>
<span class="sd">with iterator tools (itertools).</span>
<span class="sd">This is what we&#39;re trying to explore, but for if/then conditions.</span>

<span class="sd">I said explore. Some more work is needed here to make it robust and easily usable.</span>

<span class="sd">Let&#39;s look at an example involving the three main actors of our play.</span>
<span class="sd">Each of these are ``Iterable`` and ``Callable`` (``Generator`` to be precise).</span>

<span class="sd">- ``CondNode``: implements the if/then (no else) logic</span>
<span class="sd">- ``FinalNode``: Final -- yields (both with call and iter) it&#39;s single `.val` attribute.</span>
<span class="sd">- ``RoutingForest``: An Iterable of ``CondNode``</span>

<span class="sd">You&#39;ll note that instances of these classes are all both callables and iterables,</span>
<span class="sd">and that when called, they return iterables.</span>
<span class="sd">It&#39;s this aspect that makes us be able to nest conditions within conditions,</span>
<span class="sd">and further, control the flow of the iteration from outside.</span>
<span class="sd">A routing node (or forest) called on an object will yield all values that match the</span>
<span class="sd">conditions that were specified for it.</span>
<span class="sd">For example, if you need all matches, you can wrap it with ``list``, if you need the</span>
<span class="sd">first match only, you can wrap it with ``next``, if you have a default value,</span>
<span class="sd">you can wrap it in ``next`` with a default value.</span>

<span class="sd">&gt;&gt;&gt; import inspect</span>
<span class="sd">&gt;&gt;&gt;</span>
<span class="sd">&gt;&gt;&gt; def could_be_int(obj):</span>
<span class="sd">...     if isinstance(obj, int):</span>
<span class="sd">...         b = True</span>
<span class="sd">...     else:</span>
<span class="sd">...         try:</span>
<span class="sd">...             int(obj)</span>
<span class="sd">...             b = True</span>
<span class="sd">...         except ValueError:</span>
<span class="sd">...             b = False</span>
<span class="sd">...     if b:</span>
<span class="sd">...         print(f&#39;{inspect.currentframe().f_code.co_name}&#39;)</span>
<span class="sd">...     return b</span>
<span class="sd">...</span>
<span class="sd">&gt;&gt;&gt; def could_be_float(obj):</span>
<span class="sd">...     if isinstance(obj, float):</span>
<span class="sd">...         b = True</span>
<span class="sd">...     else:</span>
<span class="sd">...         try:</span>
<span class="sd">...             float(obj)</span>
<span class="sd">...             b = True</span>
<span class="sd">...         except ValueError:</span>
<span class="sd">...             b = False</span>
<span class="sd">...     if b:</span>
<span class="sd">...         print(f&#39;{inspect.currentframe().f_code.co_name}&#39;)</span>
<span class="sd">...     return b</span>
<span class="sd">...</span>
<span class="sd">&gt;&gt;&gt; print(</span>
<span class="sd">...     could_be_int(30),</span>
<span class="sd">...     could_be_int(30.3),</span>
<span class="sd">...     could_be_int(&#39;30.2&#39;),</span>
<span class="sd">...     could_be_int(&#39;nope&#39;),</span>
<span class="sd">... )</span>
<span class="sd">could_be_int</span>
<span class="sd">could_be_int</span>
<span class="sd">True True False False</span>
<span class="sd">&gt;&gt;&gt; print(</span>
<span class="sd">...     could_be_float(30),</span>
<span class="sd">...     could_be_float(30.3),</span>
<span class="sd">...     could_be_float(&#39;30.2&#39;),</span>
<span class="sd">...     could_be_float(&#39;nope&#39;),</span>
<span class="sd">... )</span>
<span class="sd">could_be_float</span>
<span class="sd">could_be_float</span>
<span class="sd">could_be_float</span>
<span class="sd">True True True False</span>
<span class="sd">&gt;&gt;&gt; assert could_be_int(&#39;30.2&#39;) is False</span>
<span class="sd">&gt;&gt;&gt; assert could_be_float(&#39;30.2&#39;) is True</span>
<span class="sd">could_be_float</span>
<span class="sd">&gt;&gt;&gt;</span>
<span class="sd">&gt;&gt;&gt; st = RoutingForest(</span>
<span class="sd">...     [</span>
<span class="sd">...         CondNode(</span>
<span class="sd">...             cond=could_be_int,</span>
<span class="sd">...             then=RoutingForest(</span>
<span class="sd">...                 [</span>
<span class="sd">...                     CondNode(</span>
<span class="sd">...                         cond=lambda x: int(x) &gt;= 10,</span>
<span class="sd">...                         then=FinalNode(&#39;More than a digit&#39;),</span>
<span class="sd">...                     ),</span>
<span class="sd">...                     CondNode(</span>
<span class="sd">...                         cond=lambda x: (int(x) % 2) == 1,</span>
<span class="sd">...                         then=FinalNode(&quot;That&#39;s odd!&quot;),</span>
<span class="sd">...                     ),</span>
<span class="sd">...                 ]</span>
<span class="sd">...             ),</span>
<span class="sd">...         ),</span>
<span class="sd">...         CondNode(cond=could_be_float, then=FinalNode(&#39;could be seen as a float&#39;)),</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt; assert list(st(&#39;nothing I can do with that&#39;)) == []</span>
<span class="sd">&gt;&gt;&gt; assert list(st(8)) == [&#39;could be seen as a float&#39;]</span>
<span class="sd">could_be_int</span>
<span class="sd">could_be_float</span>
<span class="sd">&gt;&gt;&gt; assert list(st(9)) == [&quot;That&#39;s odd!&quot;, &#39;could be seen as a float&#39;]</span>
<span class="sd">could_be_int</span>
<span class="sd">could_be_float</span>
<span class="sd">&gt;&gt;&gt; assert list(st(10)) == [&#39;More than a digit&#39;, &#39;could be seen as a float&#39;]</span>
<span class="sd">could_be_int</span>
<span class="sd">could_be_float</span>
<span class="sd">&gt;&gt;&gt; assert list(st(11)) == [</span>
<span class="sd">...     &#39;More than a digit&#39;,</span>
<span class="sd">...     &quot;That&#39;s odd!&quot;,</span>
<span class="sd">...     &#39;could be seen as a float&#39;,</span>
<span class="sd">... ]</span>
<span class="sd">could_be_int</span>
<span class="sd">could_be_float</span>
<span class="sd">&gt;&gt;&gt;</span>
<span class="sd">&gt;&gt;&gt; print(</span>
<span class="sd">...     &#39;### RoutingForest ########################################################################################&#39;</span>
<span class="sd">... )</span>
<span class="sd">### RoutingForest ########################################################################################</span>
<span class="sd">&gt;&gt;&gt; rf = RoutingForest(</span>
<span class="sd">...     [</span>
<span class="sd">...         SwitchCaseNode(</span>
<span class="sd">...             switch=lambda x: x % 5,</span>
<span class="sd">...             cases={0: FinalNode(&#39;zero_mod_5&#39;), 1: FinalNode(&#39;one_mod_5&#39;)},</span>
<span class="sd">...             default=FinalNode(&#39;default_mod_5&#39;),</span>
<span class="sd">...         ),</span>
<span class="sd">...         SwitchCaseNode(</span>
<span class="sd">...             switch=lambda x: x % 2,</span>
<span class="sd">...             cases={0: FinalNode(&#39;even&#39;), 1: FinalNode(&#39;odd&#39;)},</span>
<span class="sd">...             default=FinalNode(&#39;that is not an int&#39;),</span>
<span class="sd">...         ),</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt;</span>
<span class="sd">&gt;&gt;&gt; assert list(rf(5)) == [&#39;zero_mod_5&#39;, &#39;odd&#39;]</span>
<span class="sd">&gt;&gt;&gt; assert list(rf(6)) == [&#39;one_mod_5&#39;, &#39;even&#39;]</span>
<span class="sd">&gt;&gt;&gt; assert list(rf(7)) == [&#39;default_mod_5&#39;, &#39;odd&#39;]</span>
<span class="sd">&gt;&gt;&gt; assert list(rf(8)) == [&#39;default_mod_5&#39;, &#39;even&#39;]</span>
<span class="sd">&gt;&gt;&gt; assert list(rf(10)) == [&#39;zero_mod_5&#39;, &#39;even&#39;]</span>
<span class="sd">&gt;&gt;&gt;</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">chain</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">i2.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">LiteralVal</span><span class="p">,</span> <span class="n">mk_sentinel</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">MutableMapping</span><span class="p">,</span> <span class="n">Any</span>


<div class="viewcode-block" id="return_sentinel">
<a class="viewcode-back" href="../../module_docs/i2/routing_forest.html#i2.routing_forest.return_sentinel">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">return_sentinel</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">sentinel</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a constanc sentinel value when called. Use partial to set sentinel&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sentinel</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">identity</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">obj</span>


<div class="viewcode-block" id="DelegateToMappingAttrMixin">
<a class="viewcode-back" href="../../module_docs/i2/routing_forest.html#i2.routing_forest.DelegateToMappingAttrMixin">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DelegateToMappingAttrMixin</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A mixin to delegate ``Mapping`` methods to a mapping attribute called ``mapping``</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mapping</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span></div>



<span class="c1"># Note: KeyFuncMapping is very similar to the SwitchCaseMapping in i2.routing_forest,</span>
<span class="c1">#  but the latter builds on a more extensive framework for routing.</span>
<div class="viewcode-block" id="KeyFuncMapping">
<a class="viewcode-back" href="../../module_docs/i2/routing_forest.html#i2.routing_forest.KeyFuncMapping">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">KeyFuncMapping</span><span class="p">(</span><span class="n">DelegateToMappingAttrMixin</span><span class="p">,</span> <span class="n">MutableMapping</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Implements a switch-case-like mapping with a callable key function.</span>

<span class="sd">    The purpose of ``KeyFuncMapping`` is to  allow switch-case logic to be</span>
<span class="sd">    given as a plugin specification.</span>

<span class="sd">    &gt;&gt;&gt; from i2.routing_forest import KeyFuncMapping</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; get_extension = lambda x: x.split(&#39;.&#39;)[-1]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; data_type = KeyFuncMapping(</span>
<span class="sd">    ...     {&#39;csv&#39;: &#39;table&#39;, &#39;xls&#39;: &#39;table&#39;, &#39;wav&#39;: &#39;audio&#39;}, key=get_extension</span>
<span class="sd">    ... )</span>

<span class="sd">    Calling a ``KeyFuncMapping`` instance will call the ``key`` function on the input,</span>
<span class="sd">    then look up the result in the ``mapping``.</span>

<span class="sd">    &gt;&gt;&gt; data_type(&#39;my_file.csv&#39;)</span>
<span class="sd">    &#39;table&#39;</span>
<span class="sd">    &gt;&gt;&gt; data_type(&#39;another_file.xls&#39;)</span>
<span class="sd">    &#39;table&#39;</span>
<span class="sd">    &gt;&gt;&gt; data_type(&#39;sound.wav&#39;)</span>
<span class="sd">    &#39;audio&#39;</span>

<span class="sd">    If the key is not found in the mapping, the ``default_factory`` is **called**</span>
<span class="sd">    with the input and the result is returned. The default ``default_factory`` is</span>
<span class="sd">    ``return_sentinel``, which by default returns ``None``</span>

<span class="sd">    &gt;&gt;&gt; assert data_type(&#39;poem.txt&#39;) is None</span>

<span class="sd">    Note that instances of ``KeyFuncMapping`` are also ``Mapping``s, so all ``Mapping``</span>
<span class="sd">    methods can be used.</span>

<span class="sd">    &gt;&gt;&gt; list(data_type)</span>
<span class="sd">    [&#39;csv&#39;, &#39;xls&#39;, &#39;wav&#39;]</span>
<span class="sd">    &gt;&gt;&gt; dict(data_type)</span>
<span class="sd">    {&#39;csv&#39;: &#39;table&#39;, &#39;xls&#39;: &#39;table&#39;, &#39;wav&#39;: &#39;audio&#39;}</span>

<span class="sd">    Including ``update``, which constitutes a convenient way to extend the mapping.</span>

<span class="sd">    &gt;&gt;&gt; data_type.update(txt=&#39;text&#39;)</span>
<span class="sd">    &gt;&gt;&gt; data_type(&#39;poem.txt&#39;)</span>
<span class="sd">    &#39;text&#39;</span>

<span class="sd">    The ``default_factory`` can be set to any callable, including a</span>
<span class="sd">    ``KeyFuncMapping`` itself, which enables us to define an ``else`` for the</span>
<span class="sd">    switch-case logic that a ``KeyFuncMapping`` implements.</span>
<span class="sd">    Say, for example, if no handled extension is found, we want to check the protocol</span>
<span class="sd">    of the input string instead. This is not only a new mapping, but also a new key</span>
<span class="sd">    function. We can do it as such:</span>

<span class="sd">    &gt;&gt;&gt; get_protocol = lambda x: x.split(&#39;://&#39;)[0]</span>
<span class="sd">    &gt;&gt;&gt; protocol = KeyFuncMapping({&#39;https&#39;: &#39;url&#39;}, get_protocol)</span>
<span class="sd">    &gt;&gt;&gt; new_data_type = KeyFuncMapping(</span>
<span class="sd">    ...     data_type.mapping, data_type.key, default_factory=protocol</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; new_data_type(&#39;notes.txt&#39;)</span>
<span class="sd">    &#39;text&#39;</span>
<span class="sd">    &gt;&gt;&gt; new_data_type(&#39;https://www.python.org/&#39;)</span>
<span class="sd">    &#39;url&#39;</span>

<span class="sd">    Given how useful this pattern is, we made the ``+`` operator implement this.</span>
<span class="sd">    Note that here, ``+`` is not associative or commutative (as with numbers).</span>
<span class="sd">    It should be understood to function more like the ``+`` for iterables like ``list``</span>
<span class="sd">    and ``tuple``.</span>

<span class="sd">    &gt;&gt;&gt; nested = data_type + protocol</span>
<span class="sd">    &gt;&gt;&gt; nested(&#39;https://www.python.org/&#39;)</span>
<span class="sd">    &#39;url&#39;</span>
<span class="sd">    &gt;&gt;&gt; nested(&#39;jazz.wav&#39;)</span>
<span class="sd">    &#39;audio&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mapping</span><span class="p">:</span> <span class="n">MutableMapping</span>
    <span class="n">key</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">identity</span>  <span class="c1"># TODO: Design: should we default this at all?</span>
    <span class="n">default_factory</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">return_sentinel</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">default_factory</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">default_factory</span><span class="si">}</span><span class="s2"> is not callable&quot;</span>

    <span class="c1"># Note: An earlier version used __getitem__ itself instead of __call__ as the</span>
    <span class="c1">#  obj routing method, but the misalignment between the keys listed by __iter__ and</span>
    <span class="c1">#  the values that could be resolved by __getitem__ lead to unintuitive behaviors</span>
    <span class="c1">#  with other mapping methods.</span>
    <span class="c1"># Note: The default_factory is a Callable instead of a value because the former is</span>
    <span class="c1"># more general and enables recursivity: That is, one can define another</span>
    <span class="c1"># KeyFuncMapping to be specified as a default, thus specifying a tree</span>
    <span class="c1"># (or rather forest) of conditionals.</span>
    <span class="c1"># Note: Could use a mapping.get(..., sentinel) instead of the `obj_key in mapping`</span>
    <span class="c1"># check, which would be more efficient, but perhaps less readable/debuggable</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="n">obj_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">obj_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">:</span>  <span class="c1"># if the obj_key is in the mapping...</span>
            <span class="c1"># ... return the mapping&#39;s value for obj_key...</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">[</span><span class="n">obj_key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_factory</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>  <span class="c1"># ... else call the default function</span>

    <span class="c1"># TODO: Is this too hacky? Should we not use __add__ for this? Maybe use</span>
    <span class="c1">#  ``extend`` instead? Maybe another method? Maybe not add this convenience at all?</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Callable</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make a copy of the KeyFuncMapping instance with other as default_factory&quot;&quot;&quot;</span>
        <span class="n">self_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span>
            <span class="n">other</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Can only add a callable (usually a </span><span class="si">{</span><span class="n">self_type</span><span class="si">}</span><span class="s2"> itself) to a </span><span class="si">{</span><span class="n">self_type</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">self_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mapping</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">default_factory</span><span class="o">=</span><span class="n">other</span><span class="p">)</span></div>



<span class="c1"># --------------------------------------------------------------------------------------</span>
<span class="c1"># A proposal for a routing forest OO backend and convenience mini-language</span>
<span class="n">Obj</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;Obj&quot;</span><span class="p">)</span>
<span class="n">Output</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;Output&quot;</span><span class="p">)</span>
<span class="n">Cond</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Obj</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span>
<span class="n">Then</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Obj</span><span class="p">],</span> <span class="n">Output</span><span class="p">]</span>
<span class="n">Rule</span> <span class="o">=</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Cond</span><span class="p">,</span> <span class="n">Then</span><span class="p">]</span>
<span class="n">Rules</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Rule</span><span class="p">]</span>


<span class="c1"># TODO: Think a bit harder about this mini-language</span>
<span class="c1"># TODO: Right now use has to explicitly declare final nodes. Can do better.</span>
<span class="c1"># TODO: This mini language can itself be expressed as a routing forest. Do it!</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_default_mini_lang</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="c1"># TODO: One is really tempted to use CondNode here to define this, right?</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">CondNode</span><span class="p">,</span> <span class="n">RoutingForest</span><span class="p">,</span> <span class="n">SwitchCaseNode</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">LiteralVal</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">get_val</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">CondNode</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="n">_default_mini_lang</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SwitchCaseNode</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="n">_default_mini_lang</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;If a tuple, element must be a `(cond, then)` pair, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;or a (switch, case, default) triple, or a `Literal`. Was: </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">{</span><span class="s2">&quot;cond&quot;</span><span class="p">,</span> <span class="s2">&quot;then&quot;</span><span class="p">}</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">CondNode</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">_default_mini_lang</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
            <span class="k">elif</span> <span class="p">{</span><span class="s2">&quot;switch&quot;</span><span class="p">,</span> <span class="s2">&quot;case&quot;</span><span class="p">}</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="ow">and</span> <span class="n">keys</span> <span class="o">==</span> <span class="p">{</span>
                <span class="s2">&quot;switch&quot;</span><span class="p">,</span>
                <span class="s2">&quot;case&quot;</span><span class="p">,</span>
                <span class="s2">&quot;default&quot;</span><span class="p">,</span>
            <span class="p">}:</span>
                <span class="k">return</span> <span class="n">SwitchCaseNode</span><span class="p">(</span>
                    <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">_default_mini_lang</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;keys should be &#39;switch&#39;, &#39;case&#39; and optionally &#39;default&#39;. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Were: </span><span class="si">{</span><span class="n">keys</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;A non-Literal dict must have keys &#39;cond&#39; and &#39;then&#39; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;or &#39;switch&#39; and &#39;case&#39; (and optionally &#39;default&#39;). Was: </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">RoutingForest</span><span class="p">(</span><span class="n">cond_nodes</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_default_mini_lang</span><span class="p">,</span> <span class="n">x</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>


<div class="viewcode-block" id="RoutingNode">
<a class="viewcode-back" href="../../module_docs/i2/routing_forest.html#i2.routing_forest.RoutingNode">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">RoutingNode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A RoutingNode instance needs to be callable on a single object,</span>
<span class="sd">    yielding an iterable or a final value&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;You should implement this.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="RoutingNode.from_object">
<a class="viewcode-back" href="../../module_docs/i2/routing_forest.html#i2.routing_forest.RoutingNode.from_object">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_object</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mini_lang</span><span class="o">=</span><span class="n">_default_mini_lang</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts an object to a RoutingNode instance.</span>
<span class="sd">        Enables mini-languages to be developed for defining routing trees.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">mini_lang</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="FinalNode">
<a class="viewcode-back" href="../../module_docs/i2/routing_forest.html#i2.routing_forest.FinalNode">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FinalNode</span><span class="p">(</span><span class="n">RoutingNode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A RoutingNode that is final.</span>
<span class="sd">    It yields (both with call and iter) it&#39;s single `.val` attribute.&quot;&quot;&quot;</span>

    <span class="n">val</span><span class="p">:</span> <span class="n">Any</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">val</span></div>


    <span class="c1"># def __getstate__(self):</span>
    <span class="c1">#     return {&#39;val&#39;: self.val}</span>


<span class="c1"># TODO: Add tooling to merge validation into `then` functions/values</span>
<div class="viewcode-block" id="CondNode">
<a class="viewcode-back" href="../../module_docs/i2/routing_forest.html#i2.routing_forest.CondNode">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CondNode</span><span class="p">(</span><span class="n">RoutingNode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A RoutingNode that implements the if/then (no else) logic&quot;&quot;&quot;</span>

    <span class="n">cond</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span>
    <span class="n">then</span><span class="p">:</span> <span class="n">Any</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="c1"># The yield from is important here. It&#39;s what allows us to nest further</span>
            <span class="c1"># routing nodes.</span>
            <span class="c1"># as it allows the then node to</span>
            <span class="c1"># contain</span>
            <span class="c1"># an iterable (probably a RoutingForest) that is yielded as a single</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: Why `yield from` instead of just `yield`?</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">then</span></div>



<div class="viewcode-block" id="RoutingForest">
<a class="viewcode-back" href="../../module_docs/i2/routing_forest.html#i2.routing_forest.RoutingForest">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">RoutingForest</span><span class="p">(</span><span class="n">RoutingNode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &gt;&gt;&gt; rf = RoutingForest([</span>
<span class="sd">    ...     CondNode(cond=lambda x: isinstance(x, int),</span>
<span class="sd">    ...              then=RoutingForest([</span>
<span class="sd">    ...                  CondNode(cond=lambda x: int(x) &gt;= 10, then=FinalNode(&#39;More than a digit&#39;)),</span>
<span class="sd">    ...                  CondNode(cond=lambda x: (int(x) % 2) == 1, then=FinalNode(&quot;That&#39;s odd!&quot;))])</span>
<span class="sd">    ...             ),</span>
<span class="sd">    ...     CondNode(cond=lambda x: isinstance(x, (int, float)),</span>
<span class="sd">    ...              then=FinalNode(&#39;could be seen as a float&#39;)),</span>
<span class="sd">    ... ])</span>
<span class="sd">    &gt;&gt;&gt; assert list(rf(&#39;nothing I can do with that&#39;)) == []</span>
<span class="sd">    &gt;&gt;&gt; assert list(rf(8)) == [&#39;could be seen as a float&#39;]</span>
<span class="sd">    &gt;&gt;&gt; assert list(rf(9)) == [&quot;That&#39;s odd!&quot;, &#39;could be seen as a float&#39;]</span>
<span class="sd">    &gt;&gt;&gt; assert list(rf(10)) == [&#39;More than a digit&#39;, &#39;could be seen as a float&#39;]</span>
<span class="sd">    &gt;&gt;&gt; assert list(rf(11)) == [&#39;More than a digit&#39;, &quot;That&#39;s odd!&quot;, &#39;could be seen as a float&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cond_nodes</span><span class="p">:</span> <span class="n">Iterable</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cond_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">from_object</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cond_nodes</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">cond_node</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">for</span> <span class="n">cond_node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cond_nodes</span><span class="p">))</span>
        <span class="c1"># for cond_node in self.cond_nodes:</span>
        <span class="c1">#     yield from cond_node(obj)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: Why are we chaining cond_nodes?</span>

        <span class="k">yield from</span> <span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cond_nodes</span><span class="p">)</span></div>



<span class="n">Feature</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;Feature&quot;</span><span class="p">)</span>
<span class="n">Featurizer</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Obj</span><span class="p">],</span> <span class="n">Feature</span><span class="p">]</span>
<span class="n">FeatCondThenMap</span> <span class="o">=</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Feature</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>


<div class="viewcode-block" id="FeatCondNode">
<a class="viewcode-back" href="../../module_docs/i2/routing_forest.html#i2.routing_forest.FeatCondNode">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FeatCondNode</span><span class="p">(</span><span class="n">RoutingNode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A RoutingNode that yields multiple routes, one for each of several conditions</span>
<span class="sd">    met, where the condition is computed implements computes a feature of the obj and</span>
<span class="sd">    according to an iterable of conditions on the feature.</span>

<span class="sd">    &gt;&gt;&gt; fcn = FeatCondNode(</span>
<span class="sd">    ...     feat=lambda x: x % 5,</span>
<span class="sd">    ...     feat_cond_thens=[</span>
<span class="sd">    ...         (lambda x: x == 0, lambda x: &#39;zero_mod_5&#39;),</span>
<span class="sd">    ...         (lambda x: x == 1, lambda x: &#39;one_mod_5&#39;),</span>
<span class="sd">    ...         (lambda x: x == 2, lambda x: &#39;two_mod_5&#39;),</span>
<span class="sd">    ...         (lambda x: x == 3, lambda x: &#39;three_mod_5&#39;),</span>
<span class="sd">    ...         (lambda x: x == 4, lambda x: &#39;four_mod_5&#39;),</span>
<span class="sd">    ...     ]</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; assert list(fcn(0)) == [&#39;zero_mod_5&#39;]</span>
<span class="sd">    &gt;&gt;&gt; assert list(fcn(1)) == [&#39;one_mod_5&#39;]</span>
<span class="sd">    &gt;&gt;&gt; assert list(fcn(2)) == [&#39;two_mod_5&#39;]</span>
<span class="sd">    &gt;&gt;&gt; assert list(fcn(3)) == [&#39;three_mod_5&#39;]</span>
<span class="sd">    &gt;&gt;&gt; assert list(fcn(4)) == [&#39;four_mod_5&#39;]</span>
<span class="sd">    &gt;&gt;&gt; assert list(fcn(5)) == [&#39;zero_mod_5&#39;]</span>
<span class="sd">    &gt;&gt;&gt; assert list(fcn(6)) == [&#39;one_mod_5&#39;]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">feat</span><span class="p">:</span> <span class="n">Featurizer</span>
    <span class="n">feat_cond_thens</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Feature</span><span class="p">],</span> <span class="nb">bool</span><span class="p">],</span> <span class="n">Any</span><span class="p">]]</span>

<div class="viewcode-block" id="FeatCondNode.from_feature_val_map">
<a class="viewcode-back" href="../../module_docs/i2/routing_forest.html#i2.routing_forest.FeatCondNode.from_feature_val_map">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_feature_val_map</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">feat</span><span class="p">,</span> <span class="n">feat_cond_thens</span><span class="p">:</span> <span class="n">FeatCondThenMap</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A FeatCondNode where the conditions are equality checks on the feature value</span>

<span class="sd">        # &gt;&gt;&gt; fvn = FeatCondNode.from_feature_val_map(</span>
<span class="sd">        # ...     feat=lambda x: x % 3,</span>
<span class="sd">        # ...     feat_cond_thens={</span>
<span class="sd">        # ...         0: lambda x: &#39;zero_mod_3&#39;,</span>
<span class="sd">        # ...         1: lambda x: &#39;one_mod_3&#39;,</span>
<span class="sd">        # ...         2: lambda x: &#39;two_mod_3&#39;,</span>
<span class="sd">        # ...     }</span>
<span class="sd">        # ... )</span>
<span class="sd">        # &gt;&gt;&gt; list(fvn(0))</span>
<span class="sd">        #</span>
<span class="sd">        # &gt;&gt;&gt; assert list(fvn(0)) == [&#39;zero_mod_3&#39;]</span>
<span class="sd">        # &gt;&gt;&gt; assert list(fvn(1)) == [&#39;one_mod_3&#39;]</span>
<span class="sd">        # &gt;&gt;&gt; assert list(fvn(2)) == [&#39;two_mod_3&#39;]</span>
<span class="sd">        #</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">feat_cond_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">feat_cond_thens</span><span class="p">)</span>
        <span class="n">feat_cond_thens</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="n">feat_val</span><span class="p">,</span> <span class="n">then</span><span class="p">)</span> <span class="k">for</span> <span class="n">feat_val</span><span class="p">,</span> <span class="n">then</span> <span class="ow">in</span> <span class="n">feat_cond_map</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">feat</span><span class="p">,</span> <span class="n">feat_cond_thens</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feat_cond_map</span> <span class="o">=</span> <span class="n">feat_cond_map</span>
        <span class="k">return</span> <span class="bp">self</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="n">feature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feat</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cond</span><span class="p">,</span> <span class="n">then</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">feat_cond_thens</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cond</span><span class="p">(</span><span class="n">feature</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">then</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># yield from chain.from_iterable(self.feat_cond_map.values())</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">feat_cond_thens</span></div>


    <span class="c1"># def __call__(self, obj):</span>
    <span class="c1">#     feature = self.feat(obj)</span>
    <span class="c1">#     val = self.feat_cond_thens_map.get(feature, no_such_key)</span>
    <span class="c1">#     if val is not no_such_key:</span>
    <span class="c1">#         yield val</span>
    <span class="c1">#</span>


<span class="c1"># class FeatValNode(FeatCondNode):</span>
<span class="c1">#     &quot;&quot;&quot;A FeatCondNode where the conditions are equality checks on the feature value</span>
<span class="c1">#</span>
<span class="c1">#     &gt;&gt;&gt; fvn = FeatValNode(</span>
<span class="c1">#     ...     feat=lambda x: x % 3,</span>
<span class="c1">#     ...     feat_cond_thens={</span>
<span class="c1">#     ...         0: lambda x: &#39;zero_mod_3&#39;,</span>
<span class="c1">#     ...         1: lambda x: &#39;one_mod_3&#39;,</span>
<span class="c1">#     ...         2: lambda x: &#39;two_mod_3&#39;,</span>
<span class="c1">#     ...     }</span>
<span class="c1">#     ... )</span>
<span class="c1">#     &gt;&gt;&gt; list(fvn(0))</span>
<span class="c1">#     [&#39;zero_mod_3&#39;]</span>
<span class="c1">#     &gt;&gt;&gt; list(fvn(0))</span>
<span class="c1">#     [&#39;zero_mod_3&#39;]</span>
<span class="c1">#     #</span>
<span class="c1">#     # &gt;&gt;&gt; assert list(fvn(0)) == [&#39;zero_mod_3&#39;]</span>
<span class="c1">#     # &gt;&gt;&gt; assert list(fvn(1)) == [&#39;one_mod_3&#39;]</span>
<span class="c1">#     # &gt;&gt;&gt; assert list(fvn(2)) == [&#39;two_mod_3&#39;]</span>
<span class="c1">#     # &gt;&gt;&gt; assert list(fvn(3)) == [&#39;zero_mod_3&#39;]</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#     def __init__(self, feat, feat_cond_thens: FeatCondThensMap):</span>
<span class="c1">#         feat_cond_map = dict(feat_cond_thens)</span>
<span class="c1">#         feat_cond_thens = (</span>
<span class="c1">#             (lambda x: x == feat_val, then) for feat_val, then in feat_cond_map.items()</span>
<span class="c1">#         )</span>
<span class="c1">#         super().__init__(feat, feat_cond_thens)</span>
<span class="c1">#         self.feat_cond_map = feat_cond_map</span>


<span class="n">NoDefault</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s2">&quot;NoDefault&quot;</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span> <span class="p">{})</span>
<span class="n">NO_DFLT</span> <span class="o">=</span> <span class="n">NoDefault</span><span class="p">()</span>


<div class="viewcode-block" id="SwitchCaseNode">
<a class="viewcode-back" href="../../module_docs/i2/routing_forest.html#i2.routing_forest.SwitchCaseNode">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SwitchCaseNode</span><span class="p">(</span><span class="n">RoutingNode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A RoutingNode that implements the switch/case/else logic.</span>
<span class="sd">    It&#39;s just a specialization (enhanced with a &quot;default&quot; option) of the FeatCondNode</span>
<span class="sd">    class to a situation where the cond function of feat_cond_thens is equality,</span>
<span class="sd">    therefore the routing can be</span>
<span class="sd">    implemented with a {value_to_compare_to_feature: then_node} map.</span>

<span class="sd">    :param switch: A function returning the feature of an object we want to switch on</span>
<span class="sd">    :param cases: The mapping from feature to RoutingNode that should be yield for that</span>
<span class="sd">    feature. It is often a dict, but only requirement is that it implements the</span>
<span class="sd">    ``cases.get(val, default)`` method.</span>
<span class="sd">    :param default: Default RoutingNode to yield if no</span>

<span class="sd">    &gt;&gt;&gt; rf = RoutingForest([</span>
<span class="sd">    ...     SwitchCaseNode(switch=lambda x: x % 5,</span>
<span class="sd">    ...                    cases={0: FinalNode(&#39;zero_mod_5&#39;), 1: FinalNode(&#39;one_mod_5&#39;)},</span>
<span class="sd">    ...                    default=FinalNode(&#39;default_mod_5&#39;)),</span>
<span class="sd">    ...     SwitchCaseNode(switch=lambda x: x % 2,</span>
<span class="sd">    ...                    cases={0: FinalNode(&#39;even&#39;), 1: FinalNode(&#39;odd&#39;)},</span>
<span class="sd">    ...                    default=FinalNode(&#39;that is not an int&#39;)),</span>
<span class="sd">    ... ])</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; assert(list(rf(5)) == [&#39;zero_mod_5&#39;, &#39;odd&#39;])</span>
<span class="sd">    &gt;&gt;&gt; assert(list(rf(6)) == [&#39;one_mod_5&#39;, &#39;even&#39;])</span>
<span class="sd">    &gt;&gt;&gt; assert(list(rf(7)) == [&#39;default_mod_5&#39;, &#39;odd&#39;])</span>
<span class="sd">    &gt;&gt;&gt; assert(list(rf(8)) == [&#39;default_mod_5&#39;, &#39;even&#39;])</span>
<span class="sd">    &gt;&gt;&gt; assert(list(rf(10)) == [&#39;zero_mod_5&#39;, &#39;even&#39;])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">switch</span><span class="p">:</span> <span class="n">Callable</span>
    <span class="n">cases</span><span class="p">:</span> <span class="n">Mapping</span>
    <span class="n">default</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">NO_DFLT</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="n">feature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">switch</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">NO_DFLT</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">cases</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">feature</span><span class="p">)(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">cases</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">feature</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span><span class="p">)(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cases</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">wrap_leafs_with_final_node</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">RoutingNode</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">xx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">FinalNode</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">test_routing_forest</span><span class="p">():</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">could_be_int</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">b</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                <span class="n">b</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># if b:</span>
        <span class="c1">#     print(f&#39;{inspect.currentframe().f_code.co_name}&#39;)</span>
        <span class="k">return</span> <span class="n">b</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">could_be_float</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">b</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                <span class="n">b</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># if b:</span>
        <span class="c1">#     print(f&#39;{inspect.currentframe().f_code.co_name}&#39;)</span>
        <span class="k">return</span> <span class="n">b</span>

    <span class="k">assert</span> <span class="n">could_be_int</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">could_be_int</span><span class="p">(</span><span class="mf">30.3</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">could_be_int</span><span class="p">(</span><span class="s2">&quot;30.2&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">could_be_int</span><span class="p">(</span><span class="s2">&quot;nope&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">could_be_float</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">could_be_float</span><span class="p">(</span><span class="mf">30.3</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">could_be_float</span><span class="p">(</span><span class="s2">&quot;30.2&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">could_be_float</span><span class="p">(</span><span class="s2">&quot;nope&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">could_be_int</span><span class="p">(</span><span class="s2">&quot;30.2&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span>
    <span class="k">assert</span> <span class="n">could_be_float</span><span class="p">(</span><span class="s2">&quot;30.2&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span>

    <span class="n">st</span> <span class="o">=</span> <span class="n">RoutingForest</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">CondNode</span><span class="p">(</span>
                <span class="n">cond</span><span class="o">=</span><span class="n">could_be_int</span><span class="p">,</span>
                <span class="n">then</span><span class="o">=</span><span class="n">RoutingForest</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">CondNode</span><span class="p">(</span>
                            <span class="n">cond</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">,</span>
                            <span class="n">then</span><span class="o">=</span><span class="n">FinalNode</span><span class="p">(</span><span class="s2">&quot;More than a digit&quot;</span><span class="p">),</span>
                        <span class="p">),</span>
                        <span class="n">CondNode</span><span class="p">(</span>
                            <span class="n">cond</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="n">then</span><span class="o">=</span><span class="n">FinalNode</span><span class="p">(</span><span class="s2">&quot;That&#39;s odd!&quot;</span><span class="p">),</span>
                        <span class="p">),</span>
                    <span class="p">]</span>
                <span class="p">),</span>
            <span class="p">),</span>
            <span class="n">CondNode</span><span class="p">(</span><span class="n">cond</span><span class="o">=</span><span class="n">could_be_float</span><span class="p">,</span> <span class="n">then</span><span class="o">=</span><span class="n">FinalNode</span><span class="p">(</span><span class="s2">&quot;could be seen as a float&quot;</span><span class="p">)),</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">st</span><span class="p">(</span><span class="s2">&quot;nothing I can do with that&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="p">[]</span>
    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">st</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;could be seen as a float&quot;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">st</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;That&#39;s odd!&quot;</span><span class="p">,</span> <span class="s2">&quot;could be seen as a float&quot;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">st</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;More than a digit&quot;</span><span class="p">,</span> <span class="s2">&quot;could be seen as a float&quot;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">st</span><span class="p">(</span><span class="mi">11</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span>
        <span class="s2">&quot;More than a digit&quot;</span><span class="p">,</span>
        <span class="s2">&quot;That&#39;s odd!&quot;</span><span class="p">,</span>
        <span class="s2">&quot;could be seen as a float&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">rf</span> <span class="o">=</span> <span class="n">RoutingForest</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">SwitchCaseNode</span><span class="p">(</span>
                <span class="n">switch</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">5</span><span class="p">,</span>
                <span class="n">cases</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">FinalNode</span><span class="p">(</span><span class="s2">&quot;zero_mod_5&quot;</span><span class="p">),</span> <span class="mi">1</span><span class="p">:</span> <span class="n">FinalNode</span><span class="p">(</span><span class="s2">&quot;one_mod_5&quot;</span><span class="p">)},</span>
                <span class="n">default</span><span class="o">=</span><span class="n">FinalNode</span><span class="p">(</span><span class="s2">&quot;default_mod_5&quot;</span><span class="p">),</span>
            <span class="p">),</span>
            <span class="n">SwitchCaseNode</span><span class="p">(</span>
                <span class="n">switch</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span>
                <span class="n">cases</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">FinalNode</span><span class="p">(</span><span class="s2">&quot;even&quot;</span><span class="p">),</span> <span class="mi">1</span><span class="p">:</span> <span class="n">FinalNode</span><span class="p">(</span><span class="s2">&quot;odd&quot;</span><span class="p">)},</span>
                <span class="n">default</span><span class="o">=</span><span class="n">FinalNode</span><span class="p">(</span><span class="s2">&quot;that is not an int&quot;</span><span class="p">),</span>
            <span class="p">),</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">rf</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;zero_mod_5&quot;</span><span class="p">,</span> <span class="s2">&quot;odd&quot;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">rf</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;one_mod_5&quot;</span><span class="p">,</span> <span class="s2">&quot;even&quot;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">rf</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;default_mod_5&quot;</span><span class="p">,</span> <span class="s2">&quot;odd&quot;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">rf</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;default_mod_5&quot;</span><span class="p">,</span> <span class="s2">&quot;even&quot;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">rf</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;zero_mod_5&quot;</span><span class="p">,</span> <span class="s2">&quot;even&quot;</span><span class="p">]</span>

    <span class="c1"># testing default mini-language #####################################################</span>

    <span class="n">st2</span> <span class="o">=</span> <span class="n">RoutingNode</span><span class="o">.</span><span class="n">from_object</span><span class="p">(</span>
        <span class="p">[</span>  <span class="c1"># RoutingForest</span>
            <span class="p">(</span>  <span class="c1"># CondNode</span>
                <span class="n">could_be_int</span><span class="p">,</span>
                <span class="p">[</span>  <span class="c1"># RoutingForest</span>
                    <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">FinalNode</span><span class="p">(</span><span class="s2">&quot;More than a digit&quot;</span><span class="p">)),</span>
                    <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">FinalNode</span><span class="p">(</span><span class="s2">&quot;That&#39;s odd!&quot;</span><span class="p">)),</span>
                <span class="p">],</span>
            <span class="p">),</span>
            <span class="p">(</span><span class="n">could_be_float</span><span class="p">,</span> <span class="n">FinalNode</span><span class="p">(</span><span class="s2">&quot;could be seen as a float&quot;</span><span class="p">)),</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">st2</span><span class="p">(</span><span class="s2">&quot;nothing I can do with that&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="p">[]</span>
    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">st2</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;could be seen as a float&quot;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">st2</span><span class="p">(</span><span class="mi">9</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;That&#39;s odd!&quot;</span><span class="p">,</span> <span class="s2">&quot;could be seen as a float&quot;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">st2</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;More than a digit&quot;</span><span class="p">,</span> <span class="s2">&quot;could be seen as a float&quot;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">st2</span><span class="p">(</span><span class="mi">11</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span>
        <span class="s2">&quot;More than a digit&quot;</span><span class="p">,</span>
        <span class="s2">&quot;That&#39;s odd!&quot;</span><span class="p">,</span>
        <span class="s2">&quot;could be seen as a float&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">rf2</span> <span class="o">=</span> <span class="n">RoutingForest</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">5</span><span class="p">,</span>
                <span class="n">LiteralVal</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="n">FinalNode</span><span class="p">(</span><span class="s2">&quot;zero_mod_5&quot;</span><span class="p">),</span> <span class="mi">1</span><span class="p">:</span> <span class="n">FinalNode</span><span class="p">(</span><span class="s2">&quot;one_mod_5&quot;</span><span class="p">)}),</span>
                <span class="n">FinalNode</span><span class="p">(</span><span class="s2">&quot;default_mod_5&quot;</span><span class="p">),</span>
            <span class="p">),</span>
            <span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span>
                <span class="n">LiteralVal</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="n">FinalNode</span><span class="p">(</span><span class="s2">&quot;even&quot;</span><span class="p">),</span> <span class="mi">1</span><span class="p">:</span> <span class="n">FinalNode</span><span class="p">(</span><span class="s2">&quot;odd&quot;</span><span class="p">)}),</span>
                <span class="n">FinalNode</span><span class="p">(</span><span class="s2">&quot;that is not an int&quot;</span><span class="p">),</span>
            <span class="p">),</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">rf2</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;zero_mod_5&quot;</span><span class="p">,</span> <span class="s2">&quot;odd&quot;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">rf2</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;one_mod_5&quot;</span><span class="p">,</span> <span class="s2">&quot;even&quot;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">rf2</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;default_mod_5&quot;</span><span class="p">,</span> <span class="s2">&quot;odd&quot;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">rf2</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;default_mod_5&quot;</span><span class="p">,</span> <span class="s2">&quot;even&quot;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">rf2</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="o">==</span> <span class="p">[</span><span class="s2">&quot;zero_mod_5&quot;</span><span class="p">,</span> <span class="s2">&quot;even&quot;</span><span class="p">]</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright NO COPYRIGHT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
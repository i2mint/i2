<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>i2.tests.util &mdash; i2 0.0.175 documentation</title><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script src="../../../_static/toggleprompt.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> i2
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2.html">i2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/_deprecated.html">i2._deprecated</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/base.html">i2.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/chain_map.html">i2.chain_map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/deco.html">i2.deco</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/doc_mint.html">i2.doc_mint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/errors.html">i2.errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/examples.html">i2.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/examples/signature_calculus.html">i2.examples.signature_calculus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/footprints.html">i2.footprints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/io_trans.html">i2.io_trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/itypes.html">i2.itypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/key_path.html">i2.key_path</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/multi_object.html">i2.multi_object</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/routing_forest.html">i2.routing_forest</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/scrap.html">i2.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/scrap/scrap.html">i2.scrap.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/scrap/scrap_ch_variadics.html">i2.scrap.scrap_ch_variadics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/scrap/scrap_kwargs.html">i2.scrap.scrap_kwargs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/scrap/signature_bops.html">i2.scrap.signature_bops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/scrap/simple_pymint.html">i2.scrap.simple_pymint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/signatures.html">i2.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/switch_case_tree.html">i2.switch_case_tree</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/tests.html">i2.tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/tests/footprints_test.html">i2.tests.footprints_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/tests/objects_for_testing.html">i2.tests.objects_for_testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/tests/signatures_test.html">i2.tests.signatures_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/tests/test_util.html">i2.tests.test_util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/tests/test_wrapper.html">i2.tests.test_wrapper</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/tests/util.html">i2.tests.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/util.html">i2.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/wrapper.html">i2.wrapper</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">i2</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">i2.tests.util</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for i2.tests.util</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Utils for testing&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">Signature</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Iterator</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>

<span class="kn">from</span> <span class="nn">i2.signatures</span> <span class="kn">import</span> <span class="n">KO</span><span class="p">,</span> <span class="n">PK</span><span class="p">,</span> <span class="n">PO</span><span class="p">,</span> <span class="n">VP</span><span class="p">,</span> <span class="n">VK</span><span class="p">,</span> <span class="n">var_param_kinds</span>
<span class="kn">from</span> <span class="nn">i2.signatures</span> <span class="kn">import</span> <span class="n">_empty</span>
<span class="kn">from</span> <span class="nn">i2.signatures</span> <span class="kn">import</span> <span class="n">ParamsAble</span><span class="p">,</span> <span class="n">Sig</span><span class="p">,</span> <span class="n">ensure_param</span><span class="p">,</span> <span class="n">SignatureAble</span>

<span class="n">ParameterAble</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">ParamsAble_</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">ParamsAble</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span>


<span class="k">def</span> <span class="nf">_is_valid_arg_for_sig</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">Callable</span><span class="p">,</span> <span class="n">Signature</span><span class="p">))</span>
        <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">)</span>
        <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">)</span>
    <span class="p">)</span>


<div class="viewcode-block" id="generate_params"><a class="viewcode-back" href="../../../module_docs/i2/tests/util.html#i2.tests.util.generate_params">[docs]</a><span class="k">def</span> <span class="nf">generate_params</span><span class="p">(</span><span class="n">params</span><span class="p">:</span> <span class="n">ParamsAble_</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate inspect.Parameter instances quickly.</span>

<span class="sd">    Example: Generate params solely from a list of their kinds</span>

<span class="sd">    &gt;&gt;&gt; str(Sig(generate_params([0, 0, 1, 1, 1, 2, 3, 4])))</span>
<span class="sd">    &#39;(a00, a01, /, a12, a13, a14, *a25, a36, **a47)&#39;</span>

<span class="sd">    &gt;&gt;&gt; str(Sig(generate_params(&quot;00111234&quot;)))</span>
<span class="sd">    &#39;(a00, a01, /, a12, a13, a14, *a25, a36, **a47)&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">_is_valid_arg_for_sig</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
        <span class="c1"># generate params from a callable or signature</span>
        <span class="k">yield from</span> <span class="n">Sig</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="o">.</span><span class="n">params</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">spec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">kind</span> <span class="o">=</span> <span class="n">spec</span>
                <span class="k">yield</span> <span class="n">Parameter</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;a</span><span class="si">{</span><span class="n">kind</span><span class="si">}{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">):</span>
                <span class="n">param</span> <span class="o">=</span> <span class="n">spec</span>
                <span class="k">yield</span> <span class="n">param</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spec</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">spec</span><span class="o">.</span><span class="n">isnumeric</span><span class="p">():</span>
                <span class="n">kind</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">Parameter</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;a</span><span class="si">{</span><span class="n">kind</span><span class="si">}{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">ensure_param</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Don&#39;t know how to handle this type of obj: </span><span class="si">{</span><span class="n">spec</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span></div>


<div class="viewcode-block" id="params_to_arg_name_and_val"><a class="viewcode-back" href="../../../module_docs/i2/tests/util.html#i2.tests.util.params_to_arg_name_and_val">[docs]</a><span class="k">def</span> <span class="nf">params_to_arg_name_and_val</span><span class="p">(</span><span class="n">params</span><span class="p">:</span> <span class="n">ParamsAble_</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a `{argname: argval, ...}` dictionary from an iterable of params.</span>

<span class="sd">    &gt;&gt;&gt; assert dict(params_to_arg_name_and_val(generate_params(&quot;00111234&quot;))) == {</span>
<span class="sd">    ...     &quot;a00&quot;: 0,</span>
<span class="sd">    ...     &quot;a01&quot;: 1,</span>
<span class="sd">    ...     &quot;a12&quot;: 2,</span>
<span class="sd">    ...     &quot;a13&quot;: 3,</span>
<span class="sd">    ...     &quot;a14&quot;: 4,</span>
<span class="sd">    ...     &quot;a25&quot;: (5, -5),</span>
<span class="sd">    ...     &quot;a36&quot;: 6,</span>
<span class="sd">    ...     &quot;a47&quot;: {&quot;a47&quot;: 7, &quot;a47_&quot;: -7},</span>
<span class="sd">    ... }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">generate_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">-</span><span class="n">i</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="p">{</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span><span class="p">:</span> <span class="o">-</span><span class="n">i</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">yield</span> <span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span></div>


<div class="viewcode-block" id="inject_defaults"><a class="viewcode-back" href="../../../module_docs/i2/tests/util.html#i2.tests.util.inject_defaults">[docs]</a><span class="k">def</span> <span class="nf">inject_defaults</span><span class="p">(</span><span class="n">params</span><span class="p">:</span> <span class="n">ParamsAble_</span><span class="p">,</span> <span class="n">defaults</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Yields params with defaults ({argname: default_val,...}) edited.</span>

<span class="sd">    &gt;&gt;&gt; assert (</span>
<span class="sd">    ...     str(</span>
<span class="sd">    ...         Sig(</span>
<span class="sd">    ...             inject_defaults(</span>
<span class="sd">    ...                 generate_params(&quot;00111234&quot;), defaults={&quot;a14&quot;: 40, &quot;a36&quot;: 60}</span>
<span class="sd">    ...             )</span>
<span class="sd">    ...         )</span>
<span class="sd">    ...     )</span>
<span class="sd">    ...     == &quot;(a00, a01, /, a12, a13, a14=40, *a25, a36=60, **a47)&quot;</span>
<span class="sd">    ... )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">generate_params</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">defaults</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">param</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">defaults</span><span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">param</span></div>


<span class="k">def</span> <span class="nf">_str_of_call_args</span><span class="p">(</span><span class="n">_call_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">=</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_call_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">_params_to_name</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;f&#39;</span> <span class="o">+</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span><span class="p">))</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">)</span>


<div class="viewcode-block" id="mk_func_from_params"><a class="viewcode-back" href="../../../module_docs/i2/tests/util.html#i2.tests.util.mk_func_from_params">[docs]</a><span class="k">def</span> <span class="nf">mk_func_from_params</span><span class="p">(</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">ParamsAble</span> <span class="o">=</span> <span class="s1">&#39;00111234&#39;</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">defaults</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">callback</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">dict</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">_str_of_call_args</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a function (that actually returns something based on args) from params.</span>

<span class="sd">    See Also: ``sig_to_func``</span>

<span class="sd">    :param params: params (arguments) of the function (can be expressed in many ways!)</span>
<span class="sd">    :param defaults: Optional {argname: default,...} dict to inject defaults</span>
<span class="sd">    :param name: Optional name to give the function</span>
<span class="sd">    :param callback: The function defining what the function actually does.</span>
<span class="sd">        Must be a function taking a single dict input encapsulating the all arguments.</span>
<span class="sd">        The default will return a string representation of this dict.</span>
<span class="sd">    :return: A function with the specified params, returning a string of it&#39;s (call) args</span>

<span class="sd">    There&#39;s many ways you can express the `params` input.</span>
<span class="sd">    Any of the ways understood by the `signatures.ensure_params` function, for one;</span>
<span class="sd">    plus a few more.</span>

<span class="sd">    One nice way to express the params is through an actual function.</span>
<span class="sd">    Note that the code of the function isn&#39;t even looked out.</span>
<span class="sd">    Only it&#39;s signature is taken into consideration.</span>
<span class="sd">    The returned function will have the same signature.</span>
<span class="sd">    Instead, the callback function will be acalled on the infered _call_kwargs</span>
<span class="sd">    dict of {argname: argval} pairs.</span>
<span class="sd">    The default callaback is a string exhibiting these argname/argval pairs.</span>

<span class="sd">    &gt;&gt;&gt; f = mk_func_from_params(lambda x, /, y, *, z: None)</span>
<span class="sd">    &gt;&gt;&gt; print(f&quot;{f.__name__}{Sig(f)}&quot;)</span>
<span class="sd">    f(x, /, y, *, z)</span>
<span class="sd">    &gt;&gt;&gt; f(1, 2, z=3)</span>
<span class="sd">    &#39;x=1, y=2, z=3&#39;</span>
<span class="sd">    &gt;&gt;&gt; f(1, y=2, z=3)</span>
<span class="sd">    &#39;x=1, y=2, z=3&#39;</span>
<span class="sd">    &gt;&gt;&gt; f = mk_func_from_params(lambda x, /, y=42, *, z=&#39;ZZZ&#39;: None)</span>
<span class="sd">    &gt;&gt;&gt; print(f&quot;{f.__name__}{Sig(f)}&quot;)</span>
<span class="sd">    f(x, /, y=42, *, z=&#39;ZZZ&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f(3.14)</span>
<span class="sd">    &#39;x=3.14, y=42, z=ZZZ&#39;</span>

<span class="sd">    If you&#39;re not interested in having that level of control, but are just</span>
<span class="sd">    interested in the number and kinds of the arguments, you can specify only that;</span>
<span class="sd">    a sequence of kinds.</span>
<span class="sd">    These must be a non-decreasing sequence of integers between</span>
<span class="sd">    0 and 4 inclusive. These integers represent kinds of parameters.</span>
<span class="sd">    See https://docs.python.org/3/library/inspect.html#inspect.Parameter.kind</span>
<span class="sd">    to see what each integer value means.</span>
<span class="sd">    You can also specify this integer sequence as a single string, as shown below.</span>

<span class="sd">    &gt;&gt;&gt; f = mk_func_from_params(params=&quot;00111234&quot;)</span>
<span class="sd">    &gt;&gt;&gt; str(Sig(f))</span>
<span class="sd">    &#39;(a00, a01, /, a12, a13, a14, *a25, a36, **a47)&#39;</span>
<span class="sd">    &gt;&gt;&gt; f(0, 1, 2, 3, 4, 5, -5, a36=6, a47={&quot;a47&quot;: 7, &quot;a47_&quot;: -7})</span>
<span class="sd">    &quot;a00=0, a01=1, a12=2, a13=3, a14=4, a25=(5, -5), a36=6, a47={&#39;a47&#39;: 7, &#39;a47_&#39;: -7}&quot;</span>
<span class="sd">    &gt;&gt;&gt; f(0, 1, 2, a13=3, a14=4, a36=6)</span>
<span class="sd">    &#39;a00=0, a01=1, a12=2, a13=3, a14=4, a25=(), a36=6, a47={}&#39;</span>

<span class="sd">    What just happened?</span>
<span class="sd">    Well, `params=&quot;00111234&quot;` was transformed to `params=[0, 0, 1, 1, 1, 2, 3, 4]`,</span>
<span class="sd">    which was transformed to a list of the same size, using</span>

<span class="sd">    Now, if you really want full control over those params, you can specify them</span>
<span class="sd">    completely using the `inspect.Parameter` class.</span>
<span class="sd">    You can also decide what level of control you want, and mix and match all kinds of</span>
<span class="sd">    specifications, as below.</span>

<span class="sd">    &gt;&gt;&gt; from inspect import Parameter</span>
<span class="sd">    &gt;&gt;&gt; f = mk_func_from_params([</span>
<span class="sd">    ...     0,</span>
<span class="sd">    ...     &#39;blah&#39;,</span>
<span class="sd">    ...     Parameter(name=&#39;hello&#39;,</span>
<span class="sd">    ...               kind=Parameter.POSITIONAL_OR_KEYWORD,</span>
<span class="sd">    ...               default=&#39;world&#39;)</span>
<span class="sd">    ... ])</span>
<span class="sd">    &gt;&gt;&gt; print(f&quot;{f.__name__}{Sig(f)}&quot;)</span>
<span class="sd">    f(a00, /, blah, hello=&#39;world&#39;)</span>
<span class="sd">    &gt;&gt;&gt; assert f(11, 22) == &#39;a00=11, blah=22, hello=world&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">generate_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">inject_defaults</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="n">defaults</span> <span class="ow">or</span> <span class="p">{})</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="nd">@sig</span>
    <span class="k">def</span> <span class="nf">arg_str_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">_call_kwargs</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
            <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">apply_defaults</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="n">_call_kwargs</span><span class="p">)</span>

    <span class="n">arg_str_func</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="n">_params_to_name</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">arg_str_func</span></div>


<span class="k">def</span> <span class="nf">_sig_to_str_of_call_args_code_str</span><span class="p">(</span><span class="n">sig</span><span class="p">:</span> <span class="n">Sig</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="s1">&#39;return &#39;</span> <span class="o">+</span> <span class="s1">&#39;f&quot;&#39;</span> <span class="o">+</span> <span class="n">_str_of_call_args</span><span class="p">({</span><span class="n">p</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="se">{{</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="se">}}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">names</span><span class="p">})</span> <span class="o">+</span> <span class="s1">&#39;&quot;&#39;</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_is_simple_expression</span><span class="p">(</span><span class="n">code_lines</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">code_lines</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">code_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">line</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;pass&#39;</span><span class="p">,</span> <span class="s1">&#39;...&#39;</span><span class="p">}</span>
            <span class="ow">or</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;return&#39;</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">line</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>


<div class="viewcode-block" id="sig_to_func"><a class="viewcode-back" href="../../../module_docs/i2/tests/util.html#i2.tests.util.sig_to_func">[docs]</a><span class="k">def</span> <span class="nf">sig_to_func</span><span class="p">(</span>
    <span class="n">sig</span><span class="p">:</span> <span class="n">ParamsAble</span> <span class="o">=</span> <span class="s1">&#39;00111234&#39;</span><span class="p">,</span>
    <span class="n">code_lines</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Sig</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">_sig_to_str_of_call_args_code_str</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="nb">globals</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="nb">locals</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a function from a signature</span>

<span class="sd">    See Also: ``mk_func_from_params``</span>

<span class="sd">    More information: https://github.com/i2mint/i2/issues/34</span>

<span class="sd">    :param sig: Signature (or something that can be made into a signature) the func</span>
<span class="sd">    should have</span>
<span class="sd">    :param name: Name the function should have</span>
<span class="sd">    :param code_lines: The code lines</span>

<span class="sd">    The ``globals`` must be a dictionary and ``locals`` can be any mapping, defaulting</span>
<span class="sd">    to the current globals and locals. If only ``globals`` is given, ``locals``</span>
<span class="sd">    defaults to it.</span>

<span class="sd">    &gt;&gt;&gt; sig = Sig(&#39;(a, /, b=2)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f = sig_to_func(sig)</span>
<span class="sd">    &gt;&gt;&gt; str(Sig(f))</span>
<span class="sd">    &#39;(a, /, b=2)&#39;</span>
<span class="sd">    &gt;&gt;&gt; f(2, 3)</span>
<span class="sd">    &#39;a=2, b=3&#39;</span>
<span class="sd">    &gt;&gt;&gt; f.__name__</span>
<span class="sd">    &#39;f01&#39;</span>

<span class="sd">    See how the function was given a name automatically? This name was created by</span>
<span class="sd">    appending the kind number</span>
<span class="sd">    (see https://docs.python.org/3/library/inspect.html#inspect.Parameter.kind)</span>
<span class="sd">    to &#39;f&#39;.</span>

<span class="sd">    Let&#39;s demo how we can</span>

<span class="sd">    - use kind numbers (see `inspect` module) to specify the signature</span>

<span class="sd">    - give an explicit name to the function</span>

<span class="sd">    - specify ``locals()`` so that ``sig_to_func`` can insert the new function there</span>
<span class="sd">    (which makes it picklable, for instances)</span>

<span class="sd">    &gt;&gt;&gt; _ = sig_to_func(&#39;012&#39;, name=&#39;foo&#39;, locals=locals())</span>
<span class="sd">    &gt;&gt;&gt; # and now `foo` is in local name space, and has signature:</span>
<span class="sd">    &gt;&gt;&gt; str(Sig(foo))</span>
<span class="sd">    &#39;(a00, /, a11, *a22)&#39;</span>
<span class="sd">    &gt;&gt;&gt; foo(1,2,3,4,5)</span>
<span class="sd">    &#39;a00=1, a11=2, a22=(3, 4, 5)&#39;</span>

<span class="sd">    In the examples above, the function body was was created from the input ``sig``</span>
<span class="sd">    through the ``_sig_to_str_of_call_args_code_str`` function which outputs a string</span>
<span class="sd">    formed from the input argument names and values.</span>

<span class="sd">    But you can specify your own function. This function should take a ``Sig`` object</span>
<span class="sd">    and return the string or lines (iterable of strings) of the function&#39;s body.</span>
<span class="sd">    You can also specify a string or lines directly.</span>

<span class="sd">    &gt;&gt;&gt; g = sig_to_func(&#39;(x, y=2)&#39;, &#39;pass&#39;)</span>
<span class="sd">    &gt;&gt;&gt; assert g(2, y=3) is None</span>
<span class="sd">    &gt;&gt;&gt; h = sig_to_func(&#39;(x, y=2)&#39;, &#39;return x * y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; h(3)</span>
<span class="sd">    6</span>
<span class="sd">    &gt;&gt;&gt; h(x=10, y=3)</span>
<span class="sd">    30</span>

<span class="sd">    You can even omit the return instruction if, as in ``lambda`` functions, the body is</span>
<span class="sd">    a simple expression (not `pass`, `...`, or starting something with quotes).</span>

<span class="sd">    &gt;&gt;&gt; h = sig_to_func(&#39;(x, y=2)&#39;, &#39;x / y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; h(10, 5)</span>
<span class="sd">    2.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">generate_params</span><span class="p">(</span><span class="n">sig</span><span class="p">))</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="n">_params_to_name</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">code_lines</span><span class="p">):</span>
        <span class="n">code_lines</span> <span class="o">=</span> <span class="n">code_lines</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>  <span class="c1"># call the function on sig to get lines</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">code_lines</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">code_lines</span> <span class="o">=</span> <span class="n">code_lines</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_is_simple_expression</span><span class="p">(</span><span class="n">code_lines</span><span class="p">):</span>
        <span class="c1"># If code_lines has only one line and it seems it&#39;s an expression, prepend return</span>
        <span class="n">code_lines</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;return </span><span class="si">{</span><span class="n">code_lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span>
    <span class="n">code_string</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">code_lines</span><span class="p">)</span>
    <span class="n">func_def_string</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;def </span><span class="si">{</span><span class="n">name</span><span class="si">}{</span><span class="n">sig</span><span class="si">}</span><span class="s1">:</span><span class="se">\n\t</span><span class="si">{</span><span class="n">code_string</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="n">_locals</span> <span class="o">=</span> <span class="nb">locals</span> <span class="ow">or</span> <span class="p">{}</span>
    <span class="n">exec</span><span class="p">(</span><span class="n">func_def_string</span><span class="p">,</span> <span class="nb">globals</span><span class="p">,</span> <span class="n">_locals</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_locals</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>


<span class="k">def</span> <span class="nf">_all_prefixes</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; list(_all_prefixes([1,2,3]))</span>
<span class="sd">    [(), (1,), (1, 2), (1, 2, 3)]</span>
<span class="sd">    &gt;&gt;&gt; list(map(dict, _all_prefixes({&#39;a&#39;: 1, &#39;b&#39;: 2}.items())))</span>
<span class="sd">    [{}, {&#39;a&#39;: 1}, {&#39;a&#39;: 1, &#39;b&#39;: 2}]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">x</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_args_kwargs_combinations</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &gt;&gt;&gt; assert list(_args_kwargs_combinations((1,2), {&#39;a&#39;: 3, &#39;b&#39;: 4})) == [</span>
<span class="sd">    ...     ((), {}),</span>
<span class="sd">    ...     ((), {&#39;a&#39;: 3}),</span>
<span class="sd">    ...     ((), {&#39;a&#39;: 3, &#39;b&#39;: 4}),</span>
<span class="sd">    ...     ((1,), {}),</span>
<span class="sd">    ...     ((1,), {&#39;a&#39;: 3}),</span>
<span class="sd">    ...     ((1,), {&#39;a&#39;: 3, &#39;b&#39;: 4}),</span>
<span class="sd">    ...     ((1, 2), {}),</span>
<span class="sd">    ...     ((1, 2), {&#39;a&#39;: 3}),</span>
<span class="sd">    ...     ((1, 2), {&#39;a&#39;: 3, &#39;b&#39;: 4})</span>
<span class="sd">    ... ]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">args_prefix</span><span class="p">,</span> <span class="n">kwargs_items_prefix</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span>
        <span class="n">_all_prefixes</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">_all_prefixes</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="p">):</span>
        <span class="k">yield</span> <span class="n">args_prefix</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwargs_items_prefix</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">variadic_type</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">variadics</span><span class="p">):</span>
    <span class="n">var_kinds</span> <span class="o">=</span> <span class="p">[</span><span class="n">sig</span><span class="o">.</span><span class="n">kinds</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">variadics</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">variadics</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;no_var&#39;</span>
    <span class="k">if</span> <span class="n">VP</span> <span class="ow">in</span> <span class="n">var_kinds</span> <span class="ow">and</span> <span class="n">VK</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var_kinds</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;vp_only&#39;</span>
    <span class="k">if</span> <span class="n">VK</span> <span class="ow">in</span> <span class="n">var_kinds</span> <span class="ow">and</span> <span class="n">VP</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var_kinds</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;vk_only&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;vp_vk&#39;</span>


<span class="k">def</span> <span class="nf">create_variadic_source</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">variadics</span><span class="p">,</span> <span class="n">dflt_source</span><span class="p">):</span>
    <span class="n">var_type</span> <span class="o">=</span> <span class="n">variadic_type</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">variadics</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">var_type</span> <span class="o">==</span> <span class="s1">&#39;no_var&#39;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">((),</span> <span class="p">{})</span>
    <span class="k">elif</span> <span class="n">var_type</span> <span class="o">==</span> <span class="s1">&#39;vp_only&#39;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">dflt_source</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">{})</span>
    <span class="k">elif</span> <span class="n">var_type</span> <span class="o">==</span> <span class="s1">&#39;vk_only&#39;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">((),</span> <span class="n">dflt_source</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">var_type</span> <span class="o">==</span> <span class="s1">&#39;vp_vk&#39;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">dflt_source</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="c1"># TODO: Get rid of ignore_variadics once using code is refactored</span>
<div class="viewcode-block" id="sig_to_inputs"><a class="viewcode-back" href="../../../module_docs/i2/tests/util.html#i2.tests.util.sig_to_inputs">[docs]</a><span class="k">def</span> <span class="nf">sig_to_inputs</span><span class="p">(</span>
    <span class="n">sig</span><span class="p">:</span> <span class="n">SignatureAble</span><span class="p">,</span>
    <span class="n">argument_vals</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">variadics_source</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;args1&#39;</span><span class="p">,</span> <span class="s1">&#39;args2&#39;</span><span class="p">),</span>
        <span class="p">{</span><span class="s1">&#39;kwargs1&#39;</span><span class="p">:</span> <span class="s1">&#39;kwargs1_val&#39;</span><span class="p">},</span>
    <span class="p">),</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate all kind-valid (arg, kwargs) input combinations for a function with a</span>
<span class="sd">    given signature ``sig``, with argument values taken from the ``argument_vals``</span>

<span class="sd">    :param sig: A signature or anything that ``i2.Sig`` can use to create one (e.g.</span>
<span class="sd">        function, string, list of dicts etc.)</span>
<span class="sd">    :param argument_vals: An interable from which the argument values will be drawn.</span>
<span class="sd">        Defaults to ``list(range(n_args))``.</span>
<span class="sd">    :param variadics_source: The ``(tuple, dict)`` pair that will be used to extract</span>
<span class="sd">        variadics&#39; inputs.</span>
<span class="sd">    :return: A generator of ``(args: tuple, kwargs: dict)`` pairs</span>

<span class="sd">    &gt;&gt;&gt; assert list(</span>
<span class="sd">    ...     sig_to_inputs(lambda a, b, /, c, d, *, e, f: None)</span>
<span class="sd">    ... ) == [</span>
<span class="sd">    ...     ((0, 1), {&#39;c&#39;: 2, &#39;d&#39;: 3, &#39;e&#39;: 4, &#39;f&#39;: 5}),</span>
<span class="sd">    ...     ((0, 1, 2), {&#39;d&#39;: 3, &#39;e&#39;: 4, &#39;f&#39;: 5}),</span>
<span class="sd">    ...     ((0, 1, 2, 3), {&#39;e&#39;: 4, &#39;f&#39;: 5})</span>
<span class="sd">    ... ]</span>

<span class="sd">    &gt;&gt;&gt; list(sig_to_inputs(Sig(&#39;(a, *args, b, **kwargs)&#39;)))  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    [((), {&#39;a&#39;: 0, &#39;b&#39;: 1}),</span>
<span class="sd">     ((), {&#39;a&#39;: 0, &#39;b&#39;: 1, &#39;kwargs1&#39;: &#39;kwargs1_val&#39;}),</span>
<span class="sd">     ((&#39;args1&#39;,), {&#39;a&#39;: 0, &#39;b&#39;: 1}),</span>
<span class="sd">     ((&#39;args1&#39;,), {&#39;a&#39;: 0, &#39;b&#39;: 1, &#39;kwargs1&#39;: &#39;kwargs1_val&#39;}),</span>
<span class="sd">     ((&#39;args1&#39;, &#39;args2&#39;), {&#39;a&#39;: 0, &#39;b&#39;: 1}),</span>
<span class="sd">     ((&#39;args1&#39;, &#39;args2&#39;), {&#39;a&#39;: 0, &#39;b&#39;: 1, &#39;kwargs1&#39;: &#39;kwargs1_val&#39;}),</span>
<span class="sd">     ((0,), {&#39;b&#39;: 1}),</span>
<span class="sd">     ((0,), {&#39;b&#39;: 1, &#39;kwargs1&#39;: &#39;kwargs1_val&#39;}),</span>
<span class="sd">     ((0, &#39;args1&#39;), {&#39;b&#39;: 1}),</span>
<span class="sd">     ((0, &#39;args1&#39;), {&#39;b&#39;: 1, &#39;kwargs1&#39;: &#39;kwargs1_val&#39;}),</span>
<span class="sd">     ((0, &#39;args1&#39;, &#39;args2&#39;), {&#39;b&#39;: 1}),</span>
<span class="sd">     ((0, &#39;args1&#39;, &#39;args2&#39;), {&#39;b&#39;: 1, &#39;kwargs1&#39;: &#39;kwargs1_val&#39;})]</span>

<span class="sd">    Tip: To ignore variadics all together, you can specify ``variadics_source=((), {})``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
    <span class="n">init_sig</span> <span class="o">=</span> <span class="n">sig</span>
    <span class="n">already_yielded</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">variadics</span> <span class="o">=</span> <span class="p">[</span><span class="n">param</span> <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">kind</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">kinds</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">kind</span> <span class="ow">in</span> <span class="n">var_param_kinds</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">variadics</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variadics</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">-=</span> <span class="n">v</span>
        <span class="n">variadics_source</span> <span class="o">=</span> <span class="n">create_variadic_source</span><span class="p">(</span>
            <span class="n">init_sig</span><span class="p">,</span> <span class="n">variadics</span><span class="p">,</span> <span class="n">dflt_source</span><span class="o">=</span><span class="n">variadics_source</span>
        <span class="p">)</span>
        <span class="n">var_args</span><span class="p">,</span> <span class="n">var_kwargs</span> <span class="o">=</span> <span class="n">variadics_source</span>
        <span class="k">for</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="ow">in</span> <span class="n">sig_to_inputs</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">argument_vals</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">_args</span><span class="p">,</span> <span class="n">_kwargs</span> <span class="ow">in</span> <span class="n">_args_kwargs_combinations</span><span class="p">(</span><span class="n">var_args</span><span class="p">,</span> <span class="n">var_kwargs</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">args</span> <span class="o">+</span> <span class="n">_args</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">_kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">sub_sig</span> <span class="ow">in</span> <span class="n">_get_sub_sigs_from_default_values</span><span class="p">(</span><span class="n">sig</span><span class="p">):</span>
            <span class="n">po</span><span class="p">,</span> <span class="n">pk</span><span class="p">,</span> <span class="n">ko</span> <span class="o">=</span> <span class="n">_get_non_variadic_kind_counts</span><span class="p">(</span><span class="n">sub_sig</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs_vals</span> <span class="ow">in</span> <span class="n">_sig_to_inputs</span><span class="p">(</span>
                <span class="n">po</span><span class="p">,</span> <span class="n">pk</span><span class="p">,</span> <span class="n">ko</span><span class="p">,</span> <span class="n">argument_vals</span><span class="o">=</span><span class="n">argument_vals</span>
            <span class="p">):</span>
                <span class="n">input_</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">),</span>
                    <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sub_sig</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="p">:],</span> <span class="n">kwargs_vals</span><span class="p">)},</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">input_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">already_yielded</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">input_</span>
                    <span class="n">already_yielded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_sig_to_inputs</span><span class="p">(</span><span class="n">po</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pk</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ko</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">argument_vals</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &gt;&gt;&gt; list(_sig_to_inputs(2,2,2))</span>
<span class="sd">    [([0, 1], [2, 3, 4, 5]), ([0, 1, 2], [3, 4, 5]), ([0, 1, 2, 3], [4, 5])]</span>

<span class="sd">    :param po: Number of POSITION_ONLY args in signature.</span>
<span class="sd">    :param pk: Number of POSITION_OR_KEYWORD args in signature.</span>
<span class="sd">    :param ko: Number of KEYWORD_ONLY args in signature.</span>
<span class="sd">    :param argument_vals: An interable from which the argument values will be drawn.</span>
<span class="sd">        Defaults to ``list(range(n_args))``.</span>
<span class="sd">    :return: A generator of ``(vals_for_args: tuple, vals_for_kwargs)`` pairs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">argument_vals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">argument_vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">po</span> <span class="o">+</span> <span class="n">pk</span> <span class="o">+</span> <span class="n">ko</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">argument_vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">argument_vals</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n_args_from_pk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">argument_vals</span><span class="p">[:</span> <span class="p">(</span><span class="n">po</span> <span class="o">+</span> <span class="n">n_args_from_pk</span><span class="p">)],</span> <span class="n">argument_vals</span><span class="p">[</span>
            <span class="p">(</span><span class="n">po</span> <span class="o">+</span> <span class="n">n_args_from_pk</span><span class="p">)</span> <span class="p">:</span>
        <span class="p">]</span>


<span class="k">def</span> <span class="nf">_get_sub_sigs_from_default_values</span><span class="p">(</span><span class="n">sig</span><span class="p">:</span> <span class="n">Sig</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Sig</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate all the signatures compatible with the given signature</span>
<span class="sd">    by ignoring the arguments that have default values.</span>
<span class="sd">    &gt;&gt;&gt; sig = Sig(&#39;(a=0, /, b=0, *args, c=0, **kwargs)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; assert [str(s) for s in _get_sub_sigs_from_default_values(sig)] == [</span>
<span class="sd">    ...     &#39;(*args, **kwargs)&#39;,</span>
<span class="sd">    ...     &#39;(a=0, /, *args, **kwargs)&#39;,</span>
<span class="sd">    ...     &#39;(*args, b=0, **kwargs)&#39;,</span>
<span class="sd">    ...     &#39;(a=0, /, b=0, *args, **kwargs)&#39;,</span>
<span class="sd">    ...     &#39;(*args, c=0, **kwargs)&#39;,</span>
<span class="sd">    ...     &#39;(a=0, /, *args, c=0, **kwargs)&#39;,</span>
<span class="sd">    ...     &#39;(*args, b=0, c=0, **kwargs)&#39;,</span>
<span class="sd">    ...     &#39;(a=0, /, b=0, *args, c=0, **kwargs)&#39;</span>
<span class="sd">    ... ]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">internal_get_sub_sigs</span><span class="p">(</span><span class="n">sig</span><span class="p">):</span>
        <span class="n">kos</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">names_of_kind</span><span class="p">[</span><span class="n">KO</span><span class="p">]</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">defaults</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ko</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">kos</span><span class="p">):</span>
            <span class="n">_sig</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">-</span> <span class="n">ko</span>
            <span class="k">yield from</span> <span class="n">internal_get_sub_sigs</span><span class="p">(</span><span class="n">_sig</span><span class="p">)</span>

        <span class="n">pks</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">names_of_kind</span><span class="p">[</span><span class="n">PK</span><span class="p">]</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">defaults</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pk</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">pks</span><span class="p">))):</span>
            <span class="n">_sig</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">-</span> <span class="n">pk</span>
            <span class="n">pks_to_transform_to_ko</span> <span class="o">=</span> <span class="n">pks</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">p</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">KO</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">pks_to_transform_to_ko</span> <span class="k">else</span> <span class="n">p</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">_sig</span><span class="o">.</span><span class="n">params</span>
            <span class="p">]</span>
            <span class="n">params</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span><span class="p">)</span>
            <span class="n">_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="k">yield from</span> <span class="n">internal_get_sub_sigs</span><span class="p">(</span><span class="n">_sig</span><span class="p">)</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">names_of_kind</span><span class="p">[</span><span class="n">PO</span><span class="p">]</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">defaults</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">pos</span><span class="p">:</span>
            <span class="n">_sig</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">-</span> <span class="n">pos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">KO</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">PK</span> <span class="k">else</span> <span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">_sig</span><span class="o">.</span><span class="n">params</span><span class="p">]</span>
            <span class="n">params</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span><span class="p">)</span>
            <span class="n">_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
            <span class="k">yield from</span> <span class="n">internal_get_sub_sigs</span><span class="p">(</span><span class="n">_sig</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sig</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">already_yielded</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">sig</span>
            <span class="n">already_yielded</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>

    <span class="n">already_yielded</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">yield from</span> <span class="n">internal_get_sub_sigs</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_non_variadic_kind_counts</span><span class="p">(</span><span class="n">sig</span><span class="p">:</span> <span class="n">Sig</span><span class="p">):</span>
    <span class="n">po</span> <span class="o">=</span> <span class="n">pk</span> <span class="o">=</span> <span class="n">ko</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">kind</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">kinds</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">po</span> <span class="o">+=</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">sig</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span>
        <span class="n">pk</span> <span class="o">+=</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">sig</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span>
        <span class="n">ko</span> <span class="o">+=</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">sig</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span>
    <span class="k">return</span> <span class="n">po</span><span class="p">,</span> <span class="n">pk</span><span class="p">,</span> <span class="n">ko</span>


<span class="k">def</span> <span class="nf">mk_func_inputs_for_params</span><span class="p">(</span><span class="n">params</span><span class="p">:</span> <span class="n">ParamsAble_</span><span class="p">,</span> <span class="n">param_to_input</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="c1"># ---------------------------------------------------------------------------------------</span>
<span class="c1"># Tools to analyze compatibility between signature and function call</span>

<span class="kn">from</span> <span class="nn">i2</span> <span class="kn">import</span> <span class="n">Pipe</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="n">_signature_msg_patterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;keyword arguments$&#39;</span><span class="p">,</span>
    <span class="s1">&#39;invalid keyword argument&#39;</span><span class="p">,</span>
    <span class="s1">&#39;expected at most&#39;</span><span class="p">,</span>
    <span class="s1">&#39;keyword argument&#39;</span><span class="p">,</span>
    <span class="s1">&#39;got some positional\-only arguments passed as keyword arguments&#39;</span><span class="p">,</span>
    <span class="s1">&#39;no signature found&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">_signature_msg_regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="s1">&#39;(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">_signature_msg_patterns</span><span class="p">)))</span>
<span class="n">is_signature_msg</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">_signature_msg_regex</span><span class="o">.</span><span class="n">search</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_is_signature_error</span><span class="p">(</span>
    <span class="n">error_obj</span><span class="p">,</span>
    <span class="n">signature_error_types</span><span class="o">=</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">),</span>
    <span class="n">is_signature_msg</span><span class="o">=</span><span class="n">is_signature_msg</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">error_obj</span><span class="p">,</span> <span class="n">signature_error_types</span><span class="p">):</span>
        <span class="n">error_msg</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">error_obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">is_signature_msg</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span> <span class="nf">call_and_return_error</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">error_obj</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">error_obj</span>


<span class="k">def</span> <span class="nf">on_error_return_none</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">error_obj</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="n">call_raises_signature_error</span> <span class="o">=</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">call_and_return_error</span><span class="p">,</span> <span class="n">_is_signature_error</span><span class="p">)</span>

<span class="n">call_raises_signature_error</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">&gt;&gt;&gt; call_raises_signature_error(lambda x, /, y: None, 1, y=2)</span>
<span class="s1">False</span>
<span class="s1">&gt;&gt;&gt; call_raises_signature_error(lambda x, /, y: None, x=1, y=2)</span>
<span class="s1">True</span>
<span class="s1">&#39;&#39;&#39;</span>

<span class="c1"># Yes, I too see that this can be made into yet another Pipe!</span>
<div class="viewcode-block" id="function_is_compatible_with_signature"><a class="viewcode-back" href="../../../module_docs/i2/tests/util.html#i2.tests.util.function_is_compatible_with_signature">[docs]</a><span class="k">def</span> <span class="nf">function_is_compatible_with_signature</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Runs through all combinations of positional and keyword arguments,</span>

<span class="sd">    &gt;&gt;&gt; function_is_compatible_with_signature(hasattr, Sig(lambda obj, name: ...))</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; function_is_compatible_with_signature(hasattr, Sig(lambda obj, name, /: ...))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_call_raises_sig_error</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="ow">in</span> <span class="n">sig_to_inputs</span><span class="p">(</span><span class="n">sig</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">call_raises_signature_error</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">_call_raises_sig_error</span><span class="p">())</span></div>


<span class="k">def</span> <span class="nf">builtin_objects</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">__builtins__</span><span class="p">):</span>
        <span class="k">yield</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">__builtins__</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>


<div class="viewcode-block" id="builtin_signatureless_callables"><a class="viewcode-back" href="../../../module_docs/i2/tests/util.html#i2.tests.util.builtin_signatureless_callables">[docs]</a><span class="k">def</span> <span class="nf">builtin_signatureless_callables</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A generator of builtin callables that don&#39;t have signatures.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">builtin_objects</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">and</span> <span class="n">call_raises_signature_error</span><span class="p">(</span><span class="n">signature</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">obj</span></div>


<span class="c1"># ---------------------------------------------------------------------------------------</span>

<span class="c1">#</span>
<span class="c1"># @mk_func_from_params.register</span>
<span class="c1"># def mk_func_from_params(params: Iterable[int], defaults=None, name=None):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#     :param kinds:</span>
<span class="c1">#     :param defaults:</span>
<span class="c1">#     :return:</span>
<span class="c1">#</span>
<span class="c1">#     Make a sequence of kinds (must be a non-decreasing sequence of integers between</span>
<span class="c1">#     0 and 4 inclusive. These integers represent kinds of parameters.</span>
<span class="c1">#     See https://docs.python.org/3/library/inspect.html#inspect.Parameter.kind</span>
<span class="c1">#     to see what each integer value means.</span>
<span class="c1">#</span>
<span class="c1">#     &gt;&gt;&gt; kinds = list(map(int, &quot;00111234&quot;))</span>
<span class="c1">#     &gt;&gt;&gt; kinds</span>
<span class="c1">#     [0, 0, 1, 1, 1, 2, 3, 4]</span>
<span class="c1">#</span>
<span class="c1">#     Note: `kinds_to_arg_str_func` also works directly with strings such as &quot;00111234&quot;.</span>
<span class="c1">#</span>
<span class="c1">#     Now tell `kinds_to_arg_str_func` to make a function with those kinds.</span>
<span class="c1">#</span>
<span class="c1">#     &gt;&gt;&gt; f = kinds_to_arg_str_func(kinds)</span>
<span class="c1">#     &gt;&gt;&gt; str(Sig(f))</span>
<span class="c1">#     &#39;(a00, a01, /, a12, a13, a14, *a25, a36, **a47)&#39;</span>
<span class="c1">#     &gt;&gt;&gt; f(0, 1, 2, 3, 4, 5, -5, a36=6, a47={&quot;a47&quot;: 7, &quot;a47_&quot;: -7})</span>
<span class="c1">#     &quot;a00=0, a01=1, a12=2, a13=3, a14=4, a25=(5, -5), a36=6, a47={&#39;a47&#39;: {&#39;a47&#39;: 7, &#39;a47_&#39;: -7}}&quot;</span>
<span class="c1">#     &gt;&gt;&gt; f(0, 1, 2, a13=3, a14=4, a36=6)</span>
<span class="c1">#     &#39;a00=0, a01=1, a12=2, a13=3, a14=4, a25=(), a36=6, a47={}&#39;</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     kinds = params</span>
<span class="c1">#     params = inject_defaults(generate_params(kinds), defaults=defaults or {})</span>
<span class="c1">#     name = name or &quot;f&quot; + &quot;&quot;.join(map(str, kinds))</span>
<span class="c1">#</span>
<span class="c1">#     return mk_func_from_params(params, defaults, name)</span>

<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># @mk_func_from_params.register</span>
<span class="c1"># def _(kinds: str):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     &gt;&gt;&gt; f = kinds_to_arg_str_func(&quot;00111234&quot;)</span>
<span class="c1">#     &gt;&gt;&gt; str(Sig(f))</span>
<span class="c1">#     &#39;(a00, a01, /, a12, a13, a14, *a25, a36, **a47)&#39;</span>
<span class="c1">#     &gt;&gt;&gt; f(0, 1, 2, 3, 4, 5, -5, a36=6, a47={&quot;a47&quot;: 7, &quot;a47_&quot;: -7})</span>
<span class="c1">#     &quot;a00=0, a01=1, a12=2, a13=3, a14=4, a25=(5, -5), a36=6, a47={&#39;a47&#39;: {&#39;a47&#39;: 7, &#39;a47_&#39;: -7}}&quot;</span>
<span class="c1">#     &gt;&gt;&gt; f(0, 1, 2, a13=3, a14=4, a36=6)</span>
<span class="c1">#     &#39;a00=0, a01=1, a12=2, a13=3, a14=4, a25=(), a36=6, a47={}&#39;</span>
<span class="c1">#</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     return mk_func_from_params(_kinds_str_to_int_list(kinds))</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># f = mk_func_from_params(&quot;00111234&quot;)</span>
<span class="c1"># assert str(Sig(f)) == &quot;(a00, a01, /, a12, a13, a14, *a25, a36, **a47)&quot;</span>
<span class="c1"># assert (</span>
<span class="c1">#     f(0, 1, 2, 3, 4, 5, -5, a36=6, a47={&quot;a47&quot;: 7, &quot;a47_&quot;: -7})</span>
<span class="c1">#     == &quot;a00=0, a01=1, a12=2, a13=3, a14=4, a25=(5, -5), a36=6, a47={&#39;a47&#39;: {&#39;a47&#39;: 7, &#39;a47_&#39;: -7}}&quot;</span>
<span class="c1"># )</span>


<span class="n">empty</span> <span class="o">=</span> <span class="n">_empty</span>

<span class="n">mappingproxy</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">Signature</span><span class="p">()</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">trace_call</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">local_vars</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">(&#39;</span>
        <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">argname</span><span class="si">}</span><span class="s1">=</span><span class="si">{</span><span class="n">local_vars</span><span class="p">[</span><span class="n">argname</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">argname</span> <span class="ow">in</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
        <span class="o">+</span> <span class="s1">&#39;)&#39;</span>
    <span class="p">)</span>


<span class="c1"># class KeywordArg(dict):</span>
<span class="c1">#     &quot;&quot;&quot;Just to mark a dict as a keyword argument&quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># def _separate_pk_arguments_into_positional_and_keyword(pka):</span>
<span class="c1">#     args = []</span>
<span class="c1">#     kwargs = {}</span>
<span class="c1">#     pka_iter = iter(pka)</span>
<span class="c1">#     for a in pka_iter:</span>
<span class="c1">#         if not isinstance(a, KeywordArg):</span>
<span class="c1">#             args.append(a)</span>
<span class="c1">#         else:</span>
<span class="c1">#             kwargs.update(dict(a))</span>
<span class="c1">#     for a in pka_iter:</span>
<span class="c1">#         kwargs.update(dict(a))</span>
<span class="c1">#</span>
<span class="c1">#     return args, kwargs</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright OtoSense 2020.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
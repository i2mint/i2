<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>i2.tests.signatures_test &mdash; i2 0.0.184 documentation</title><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script src="../../../_static/toggleprompt.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            i2
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2.html">i2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/_deprecated.html">i2._deprecated</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/base.html">i2.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/chain_map.html">i2.chain_map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/deco.html">i2.deco</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/doc_mint.html">i2.doc_mint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/errors.html">i2.errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/examples.html">i2.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/examples/signature_calculus.html">i2.examples.signature_calculus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/footprints.html">i2.footprints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/io_trans.html">i2.io_trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/itypes.html">i2.itypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/key_path.html">i2.key_path</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/multi_object.html">i2.multi_object</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/routing_forest.html">i2.routing_forest</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/scrap.html">i2.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/scrap/scrap.html">i2.scrap.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/scrap/scrap_ch_variadics.html">i2.scrap.scrap_ch_variadics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/scrap/scrap_kwargs.html">i2.scrap.scrap_kwargs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/scrap/signature_bops.html">i2.scrap.signature_bops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/scrap/simple_pymint.html">i2.scrap.simple_pymint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/scrap/switch_case_tree.html">i2.scrap.switch_case_tree</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/signatures.html">i2.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/tests.html">i2.tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/tests/footprints_test.html">i2.tests.footprints_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/tests/objects_for_testing.html">i2.tests.objects_for_testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/tests/signatures_test.html">i2.tests.signatures_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/tests/test_util.html">i2.tests.test_util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/tests/test_wrapper.html">i2.tests.test_wrapper</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/tests/util.html">i2.tests.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/util.html">i2.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/i2/wrapper.html">i2.wrapper</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">i2</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">i2.tests.signatures_test</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for i2.tests.signatures_test</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Test signatures module</span>


<span class="sd"># Notes to the reader</span>

<span class="sd">Both in the code and in the docs, we&#39;ll use short hands for parameter (argument) kind.</span>
<span class="sd">    PK = Parameter.POSITIONAL_OR_KEYWORD</span>
<span class="sd">    VP = Parameter.VAR_POSITIONAL</span>
<span class="sd">    VK = Parameter.VAR_KEYWORD</span>
<span class="sd">    PO = Parameter.POSITIONAL_ONLY</span>
<span class="sd">    KO = Parameter.KEYWORD_ONLY</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">pytest</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span>

<span class="kn">from</span> <span class="nn">i2</span> <span class="kn">import</span> <span class="n">Sig</span>
<span class="kn">from</span> <span class="nn">i2.signatures</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">i2.signatures</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">normalized_func</span><span class="p">,</span>
    <span class="n">sigs_for_sigless_builtin_name</span><span class="p">,</span>
    <span class="n">_robust_signature_of_callable</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">i2.tests.util</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">call_and_return_error</span><span class="p">,</span>
    <span class="n">sig_to_inputs</span><span class="p">,</span>
    <span class="n">trace_call</span><span class="p">,</span>
    <span class="n">function_is_compatible_with_signature</span><span class="p">,</span>
<span class="p">)</span>


<span class="k">def</span> <span class="nf">test_signature_equality_and_hashing</span><span class="p">():</span>

    <span class="kn">import</span> <span class="nn">pickle</span>

    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="c1"># different instances of (should be a) same signature</span>
    <span class="n">ref_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>

    <span class="n">sigs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">ref_sig</span><span class="p">,</span>
        <span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span>  <span class="c1"># another instance of the same Sig(foo)</span>
        <span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;(x, y, z=3)&#39;</span><span class="p">),</span>  <span class="c1"># signature made explicitly from a string</span>
        <span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;(y, z=3)&#39;</span><span class="p">),</span>  <span class="c1"># signature made from an add operation</span>
        <span class="n">Sig</span><span class="p">(</span><span class="n">bar</span><span class="p">),</span>  <span class="c1"># different function, same signature</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">ref_sig</span><span class="p">)),</span>  <span class="c1"># un-pickled signature</span>
    <span class="p">]</span>

    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
        <span class="n">sig</span> <span class="o">==</span> <span class="n">ref_sig</span> <span class="k">for</span> <span class="n">sig</span> <span class="ow">in</span> <span class="n">sigs</span>
    <span class="p">),</span> <span class="s1">&#39;sigs should be equal from a == point of view&#39;</span>

    <span class="c1"># Let&#39;s see that</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
        <span class="nb">hash</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">==</span> <span class="nb">hash</span><span class="p">(</span><span class="n">ref_sig</span><span class="p">)</span> <span class="k">for</span> <span class="n">sig</span> <span class="ow">in</span> <span class="n">sigs</span>
    <span class="p">),</span> <span class="s1">&#39;sigs should have the same hash&#39;</span>

    <span class="c1"># ... and if that wasn&#39;t convincing, let&#39;s see how the sigs behave as dict keys:</span>
    <span class="c1"># If sigs were different, the following would add key-value pairs to the base dict.</span>
    <span class="c1"># But it doesn&#39;t. You always get the same one key (same signature) with different</span>
    <span class="c1"># values:</span>
    <span class="n">t</span> <span class="o">=</span> <span class="p">{</span><span class="n">ref_sig</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="k">assert</span> <span class="n">t</span> <span class="o">==</span> <span class="p">{</span><span class="n">ref_sig</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="n">t</span><span class="p">[</span><span class="n">sigs</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="n">t</span> <span class="o">==</span> <span class="p">{</span><span class="n">ref_sig</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>  <span class="c1"># same signature with new 2 value</span>
    <span class="n">t</span><span class="p">[</span><span class="n">sigs</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="k">assert</span> <span class="n">t</span> <span class="o">==</span> <span class="p">{</span><span class="n">ref_sig</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>  <span class="c1"># same signature with new 3 value</span>

    <span class="c1"># What if we just have a return annotation?</span>
    <span class="k">def</span> <span class="nf">baz</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">assert</span> <span class="n">Sig</span><span class="p">(</span><span class="n">baz</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ref_sig</span><span class="p">,</span> <span class="s1">&#39;return annotation of baz should make it different&#39;</span>


<span class="k">def</span> <span class="nf">test_signature_of_partial</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span>

    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">))</span> <span class="o">==</span> <span class="s1">&#39;(a, b, c=3) -&gt; int&#39;</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">==</span> <span class="s1">&#39;(b, c=3) -&gt; int&#39;</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">)))</span> <span class="o">==</span> <span class="s1">&#39;(*, a=1, b=2, c=3) -&gt; int&#39;</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span> <span class="o">==</span> <span class="s1">&#39;(c=3) -&gt; int&#39;</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">)))</span> <span class="o">==</span> <span class="s1">&#39;(*, b=2, c=3) -&gt; int&#39;</span>


<span class="k">def</span> <span class="nf">test_some_edge_cases_of_sig</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span><span class="p">,</span> <span class="n">attrgetter</span><span class="p">,</span> <span class="n">methodcaller</span>

    <span class="k">assert</span> <span class="n">Sig</span><span class="p">(</span><span class="n">itemgetter</span><span class="p">)</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;keys&#39;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">Sig</span><span class="p">(</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;iterable&#39;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">Sig</span><span class="p">(</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;iterable&#39;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">Sig</span><span class="p">(</span><span class="n">attrgetter</span><span class="p">)</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;key&#39;</span><span class="p">,</span> <span class="s1">&#39;keys&#39;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">Sig</span><span class="p">(</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;iterable&#39;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">Sig</span><span class="p">(</span><span class="n">attrgetter</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;iterable&#39;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">Sig</span><span class="p">(</span><span class="n">methodcaller</span><span class="p">)</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;args&#39;</span><span class="p">,</span> <span class="s1">&#39;kwargs&#39;</span><span class="p">]</span>
    <span class="c1"># assert Sig(methodcaller(&#39;foo&#39;)).names == []  # fix!!</span>


<div class="viewcode-block" id="test_sig_wrap_edge_cases"><a class="viewcode-back" href="../../../module_docs/i2/tests/signatures_test.html#i2.tests.signatures_test.test_sig_wrap_edge_cases">[docs]</a><span class="k">def</span> <span class="nf">test_sig_wrap_edge_cases</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Tests some edge cases involving simultaneous changes of defaults and kinds.</span>

<span class="sd">    Current Sig.wrap design allows you to change defaults, and this will have the</span>
<span class="sd">    effect of changing the ``__defaults__`` and ``__kwdefaults__`` of the wrapped</span>
<span class="sd">    function.</span>

<span class="sd">    But, when we change the default of a parameter and change it&#39;s kind at the same</span>
<span class="sd">    time, bad things happen (see https://github.com/i2mint/i2/issues/16).</span>

<span class="sd">    So `Sig.wrap` makes a few checks and raises an error if it&#39;s thinks it&#39;s not</span>
<span class="sd">    safe to do the wrapping.</span>

<span class="sd">    Some of these facts may change with new designs. When this is the case,</span>
<span class="sd">    this test should be invalidated.&quot;&quot;&quot;</span>

    <span class="c1"># Non edge-case tests:</span>

    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">z</span>

    <span class="k">assert</span> <span class="n">foo</span><span class="o">.</span><span class="vm">__defaults__</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
    <span class="k">assert</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="nd">@Sig</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">3</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">z</span>

    <span class="k">assert</span> <span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">_defaults_</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)</span>

    <span class="k">assert</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">7</span>
    <span class="c1">#    works because Sig also changed __defaults__:</span>
    <span class="k">assert</span> <span class="n">foo</span><span class="o">.</span><span class="vm">__defaults__</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)</span>

    <span class="nd">@Sig</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">3</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">z</span>

    <span class="k">assert</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">7</span>
    <span class="c1">#    works because Sig also changed __defaults__ and __kwdefaults__:</span>
    <span class="k">assert</span> <span class="n">foo</span><span class="o">.</span><span class="vm">__defaults__</span> <span class="o">==</span> <span class="p">()</span>
    <span class="k">assert</span> <span class="n">foo</span><span class="o">.</span><span class="vm">__kwdefaults__</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
    <span class="k">assert</span> <span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">_defaults_</span> <span class="o">==</span> <span class="p">()</span>
    <span class="k">assert</span> <span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">_kwdefaults_</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>

    <span class="c1"># The following (where we go from a (same kind) param not having a default,</span>
    <span class="c1"># to having one, also work</span>

    <span class="nd">@Sig</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">3</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">z</span>

    <span class="k">assert</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">7</span>
    <span class="k">assert</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">21</span>

    <span class="nd">@Sig</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">3</span><span class="p">:</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">z</span>

    <span class="k">assert</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">7</span>
    <span class="k">assert</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">21</span>
    <span class="k">assert</span> <span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">_defaults_</span> <span class="o">==</span> <span class="p">()</span>
    <span class="k">assert</span> <span class="n">Sig</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span><span class="o">.</span><span class="n">_kwdefaults_</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span></div>


<span class="k">def</span> <span class="nf">test_tuple_the_args</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">i2.signatures</span> <span class="kn">import</span> <span class="n">tuple_the_args</span>

    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">bar</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">trace_call</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">locals</span><span class="p">())</span>

    <span class="k">assert</span> <span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;func(a=1, args=(2, 3), bar=4)&#39;</span>

    <span class="n">wfunc</span> <span class="o">=</span> <span class="n">tuple_the_args</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

    <span class="c1"># here, not that (1) args is specified as one iterable ([2, 3] instead of 2,</span>
    <span class="c1"># 3) and (2) the function name is the same as the wrapped (func)</span>
    <span class="k">assert</span> <span class="n">wfunc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">bar</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;func(a=1, args=(2, 3), bar=4)&#39;</span>

    <span class="c1"># See the func itself hasn&#39;t changed</span>
    <span class="k">assert</span> <span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;func(a=1, args=(2, 3), bar=4)&#39;</span>

    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">))</span> <span class="o">==</span> <span class="s1">&#39;(a, *args, bar)&#39;</span>
    <span class="c1"># See that args is now a PK kind with a default of (). Also, bar became KO.</span>
    <span class="k">assert</span> <span class="nb">str</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="n">wfunc</span><span class="p">))</span> <span class="o">==</span> <span class="s1">&#39;(a, args=(), *, bar)&#39;</span>

    <span class="c1"># -----------------------------------------------------------------------------------</span>
    <span class="c1"># Let&#39;s see what happens when we give bar a default value</span>

    <span class="k">def</span> <span class="nf">func2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">bar</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">trace_call</span><span class="p">(</span><span class="n">func2</span><span class="p">,</span> <span class="nb">locals</span><span class="p">())</span>

    <span class="n">wfunc</span> <span class="o">=</span> <span class="n">tuple_the_args</span><span class="p">(</span><span class="n">func2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">wfunc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="o">==</span> <span class="s1">&#39;func2(a=1, args=(2, 3), bar=10)&#39;</span>
    <span class="k">assert</span> <span class="n">wfunc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">bar</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;func2(a=1, args=(2, 3), bar=4)&#39;</span>

    <span class="c1"># On the other hand, specifying bar as a positional won&#39;t work.</span>
    <span class="c1"># The reason is: args was a variadic, so everything after it should be KO or VK</span>
    <span class="c1"># The tuple_the_args doesn&#39;t change those signatures.</span>
    <span class="c1">#</span>
    <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="n">FuncCallNotMatchingSignature</span><span class="p">)</span> <span class="k">as</span> <span class="n">e_info</span><span class="p">:</span>
        <span class="n">wfunc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">e_info</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="p">(</span>
            <span class="s1">&#39;There should be only keyword arguments after the Variadic args. &#39;</span>
            <span class="s1">&#39;Function was called with (positional=(1, [2, 3], 4), keywords=</span><span class="si">{}</span><span class="s1">)&#39;</span>
        <span class="p">)</span>

    <span class="c1"># pytest.raises()</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">xfail</span>
<span class="k">def</span> <span class="nf">test_normalize_func_simply</span><span class="p">(</span><span class="n">function_normalizer</span><span class="o">=</span><span class="n">normalized_func</span><span class="p">):</span>
    <span class="c1"># -----------------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">p0113</span><span class="p">(</span><span class="n">po1</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">pk1</span><span class="p">,</span> <span class="n">pk2</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ko1</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">po1</span><span class="si">=}</span><span class="s1">, </span><span class="si">{</span><span class="n">pk1</span><span class="si">=}</span><span class="s1">, </span><span class="si">{</span><span class="n">pk2</span><span class="si">=}</span><span class="s1">, </span><span class="si">{</span><span class="n">ko1</span><span class="si">=}</span><span class="s1">&#39;</span>

    <span class="n">func</span> <span class="o">=</span> <span class="n">p0113</span>
    <span class="n">po1</span><span class="p">,</span> <span class="n">pk1</span><span class="p">,</span> <span class="n">pk2</span><span class="p">,</span> <span class="n">ko1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span>

    <span class="n">norm_func</span> <span class="o">=</span> <span class="n">function_normalizer</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

    <span class="n">func_output</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">po1</span><span class="p">,</span> <span class="n">pk1</span><span class="p">,</span> <span class="n">pk2</span><span class="o">=</span><span class="n">pk2</span><span class="p">,</span> <span class="n">ko1</span><span class="o">=</span><span class="n">ko1</span><span class="p">)</span>

    <span class="n">norm_func_output</span> <span class="o">=</span> <span class="n">norm_func</span><span class="p">(</span><span class="n">po1</span><span class="p">,</span> <span class="n">pk1</span><span class="p">,</span> <span class="n">pk2</span><span class="p">,</span> <span class="n">ko1</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">norm_func_output</span> <span class="o">==</span> <span class="n">func_output</span>
    <span class="n">norm_func_output</span> <span class="o">=</span> <span class="n">norm_func</span><span class="p">(</span><span class="n">po1</span><span class="p">,</span> <span class="n">pk1</span><span class="p">,</span> <span class="n">pk2</span><span class="p">,</span> <span class="n">ko1</span><span class="o">=</span><span class="n">ko1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">norm_func_output</span> <span class="o">==</span> <span class="n">func_output</span>
    <span class="n">norm_func_output</span> <span class="o">=</span> <span class="n">norm_func</span><span class="p">(</span><span class="n">po1</span><span class="p">,</span> <span class="n">pk1</span><span class="p">,</span> <span class="n">pk2</span><span class="o">=</span><span class="n">pk2</span><span class="p">,</span> <span class="n">ko1</span><span class="o">=</span><span class="n">ko1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">norm_func_output</span> <span class="o">==</span> <span class="n">func_output</span>
    <span class="n">norm_func_output</span> <span class="o">=</span> <span class="n">norm_func</span><span class="p">(</span><span class="n">po1</span><span class="p">,</span> <span class="n">pk1</span><span class="o">=</span><span class="n">pk1</span><span class="p">,</span> <span class="n">pk2</span><span class="o">=</span><span class="n">pk2</span><span class="p">,</span> <span class="n">ko1</span><span class="o">=</span><span class="n">ko1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">norm_func_output</span> <span class="o">==</span> <span class="n">func_output</span>
    <span class="n">norm_func_output</span> <span class="o">=</span> <span class="n">norm_func</span><span class="p">(</span><span class="n">po1</span><span class="o">=</span><span class="n">po1</span><span class="p">,</span> <span class="n">pk1</span><span class="o">=</span><span class="n">pk1</span><span class="p">,</span> <span class="n">pk2</span><span class="o">=</span><span class="n">pk2</span><span class="p">,</span> <span class="n">ko1</span><span class="o">=</span><span class="n">ko1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">norm_func_output</span> <span class="o">==</span> <span class="n">func_output</span>

    <span class="c1"># -----------------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">p1234</span><span class="p">(</span><span class="n">pka</span><span class="p">,</span> <span class="o">*</span><span class="n">vpa</span><span class="p">,</span> <span class="n">koa</span><span class="p">,</span> <span class="o">**</span><span class="n">vka</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">pka</span><span class="si">=}</span><span class="s1">, </span><span class="si">{</span><span class="n">vpa</span><span class="si">=}</span><span class="s1">, </span><span class="si">{</span><span class="n">koa</span><span class="si">=}</span><span class="s1">, </span><span class="si">{</span><span class="n">vka</span><span class="si">=}</span><span class="s1">&#39;</span>

    <span class="n">pka</span><span class="p">,</span> <span class="n">vpa</span><span class="p">,</span> <span class="n">koa</span><span class="p">,</span> <span class="n">vka</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="mi">4</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="s1">&#39;d&#39;</span><span class="p">}</span>

    <span class="n">func</span> <span class="o">=</span> <span class="n">p1234</span>
    <span class="n">norm_func</span> <span class="o">=</span> <span class="n">function_normalizer</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

    <span class="n">func_output</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">pka</span><span class="p">,</span> <span class="o">*</span><span class="n">vpa</span><span class="p">,</span> <span class="n">koa</span><span class="p">,</span> <span class="o">**</span><span class="n">vka</span><span class="p">)</span>
    <span class="n">norm_func_output</span> <span class="o">=</span> <span class="n">norm_func</span><span class="p">(</span><span class="n">pka</span><span class="p">,</span> <span class="n">vpa</span><span class="p">,</span> <span class="n">koa</span><span class="p">,</span> <span class="n">vka</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">norm_func_output</span> <span class="o">==</span> <span class="n">func_output</span>


<span class="c1"># -----------------------------------------------------------------------------------</span>


<span class="k">def</span> <span class="nf">p1234</span><span class="p">(</span><span class="n">pka</span><span class="p">,</span> <span class="o">*</span><span class="n">vpa</span><span class="p">,</span> <span class="n">koa</span><span class="p">,</span> <span class="o">**</span><span class="n">vka</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">pka</span><span class="si">=}</span><span class="s1">, </span><span class="si">{</span><span class="n">vpa</span><span class="si">=}</span><span class="s1">, </span><span class="si">{</span><span class="n">koa</span><span class="si">=}</span><span class="s1">, </span><span class="si">{</span><span class="n">vka</span><span class="si">=}</span><span class="s1">&#39;</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">xfail</span>
<span class="k">def</span> <span class="nf">test_normalize_func_combinatorially</span><span class="p">(</span><span class="n">function_normalizer</span><span class="o">=</span><span class="n">normalized_func</span><span class="p">):</span>
    <span class="c1"># -----------------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">p0113</span><span class="p">(</span><span class="n">po1</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">pk1</span><span class="p">,</span> <span class="n">pk2</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ko1</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">po1</span><span class="si">=}</span><span class="s1">, </span><span class="si">{</span><span class="n">pk1</span><span class="si">=}</span><span class="s1">, </span><span class="si">{</span><span class="n">pk2</span><span class="si">=}</span><span class="s1">, </span><span class="si">{</span><span class="n">ko1</span><span class="si">=}</span><span class="s1">&#39;</span>

    <span class="n">func</span> <span class="o">=</span> <span class="n">p0113</span>
    <span class="n">po1</span><span class="p">,</span> <span class="n">pk1</span><span class="p">,</span> <span class="n">pk2</span><span class="p">,</span> <span class="n">ko1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span>

    <span class="n">poa</span> <span class="o">=</span> <span class="p">[</span><span class="n">po1</span><span class="p">]</span>
    <span class="n">ppka</span><span class="p">,</span> <span class="n">kpka</span> <span class="o">=</span> <span class="p">[</span><span class="n">pk1</span><span class="p">],</span> <span class="p">{</span><span class="s1">&#39;pk2&#39;</span><span class="p">:</span> <span class="n">pk2</span><span class="p">}</span>
    <span class="n">vpa</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># no VP argument</span>
    <span class="n">koa</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ko1&#39;</span><span class="p">:</span> <span class="n">ko1</span><span class="p">}</span>
    <span class="n">vka</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># no VK argument</span>

    <span class="n">norm_func</span> <span class="o">=</span> <span class="n">function_normalizer</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

    <span class="n">func_output</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">poa</span><span class="p">,</span> <span class="o">*</span><span class="n">ppka</span><span class="p">,</span> <span class="o">*</span><span class="n">vpa</span><span class="p">,</span> <span class="o">**</span><span class="n">kpka</span><span class="p">,</span> <span class="o">**</span><span class="n">koa</span><span class="p">,</span> <span class="o">**</span><span class="n">vka</span><span class="p">)</span>
    <span class="n">norm_func_output</span> <span class="o">=</span> <span class="n">norm_func</span><span class="p">(</span><span class="n">po1</span><span class="p">,</span> <span class="n">pk1</span><span class="p">,</span> <span class="n">pk2</span><span class="p">,</span> <span class="n">ko1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">norm_func_output</span> <span class="o">==</span> <span class="n">func_output</span>
    <span class="n">norm_func_output</span> <span class="o">=</span> <span class="n">norm_func</span><span class="p">(</span><span class="n">po1</span><span class="p">,</span> <span class="n">pk1</span><span class="p">,</span> <span class="n">pk2</span><span class="p">,</span> <span class="n">ko1</span><span class="o">=</span><span class="n">ko1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">norm_func_output</span> <span class="o">==</span> <span class="n">func_output</span>
    <span class="n">norm_func_output</span> <span class="o">=</span> <span class="n">norm_func</span><span class="p">(</span><span class="n">po1</span><span class="p">,</span> <span class="n">pk1</span><span class="p">,</span> <span class="n">pk2</span><span class="o">=</span><span class="n">pk2</span><span class="p">,</span> <span class="n">ko1</span><span class="o">=</span><span class="n">ko1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">norm_func_output</span> <span class="o">==</span> <span class="n">func_output</span>
    <span class="n">norm_func_output</span> <span class="o">=</span> <span class="n">norm_func</span><span class="p">(</span><span class="n">po1</span><span class="p">,</span> <span class="n">pk1</span><span class="o">=</span><span class="n">pk1</span><span class="p">,</span> <span class="n">pk2</span><span class="o">=</span><span class="n">pk2</span><span class="p">,</span> <span class="n">ko1</span><span class="o">=</span><span class="n">ko1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">norm_func_output</span> <span class="o">==</span> <span class="n">func_output</span>
    <span class="n">norm_func_output</span> <span class="o">=</span> <span class="n">norm_func</span><span class="p">(</span><span class="n">po1</span><span class="o">=</span><span class="n">po1</span><span class="p">,</span> <span class="n">pk1</span><span class="o">=</span><span class="n">pk1</span><span class="p">,</span> <span class="n">pk2</span><span class="o">=</span><span class="n">pk2</span><span class="p">,</span> <span class="n">ko1</span><span class="o">=</span><span class="n">ko1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">norm_func_output</span> <span class="o">==</span> <span class="n">func_output</span>

    <span class="c1"># -----------------------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">p1234</span><span class="p">(</span><span class="n">pka</span><span class="p">,</span> <span class="o">*</span><span class="n">vpa</span><span class="p">,</span> <span class="n">koa</span><span class="p">,</span> <span class="o">**</span><span class="n">vka</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">pka</span><span class="si">=}</span><span class="s1">, </span><span class="si">{</span><span class="n">vpa</span><span class="si">=}</span><span class="s1">, </span><span class="si">{</span><span class="n">koa</span><span class="si">=}</span><span class="s1">, </span><span class="si">{</span><span class="n">vka</span><span class="si">=}</span><span class="s1">&#39;</span>

    <span class="n">pka</span><span class="p">,</span> <span class="n">vpa</span><span class="p">,</span> <span class="n">koa</span><span class="p">,</span> <span class="n">vka</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="mi">4</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="s1">&#39;d&#39;</span><span class="p">}</span>

    <span class="n">func</span> <span class="o">=</span> <span class="n">p1234</span>
    <span class="n">norm_func</span> <span class="o">=</span> <span class="n">function_normalizer</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

    <span class="n">func_output</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">pka</span><span class="p">,</span> <span class="o">*</span><span class="n">vpa</span><span class="p">,</span> <span class="n">koa</span><span class="p">,</span> <span class="o">**</span><span class="n">vka</span><span class="p">)</span>
    <span class="n">norm_func_output</span> <span class="o">=</span> <span class="n">norm_func</span><span class="p">(</span><span class="n">pka</span><span class="p">,</span> <span class="n">vpa</span><span class="p">,</span> <span class="n">koa</span><span class="p">,</span> <span class="n">vka</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">norm_func_output</span> <span class="o">==</span> <span class="n">func_output</span>

    <span class="c1"># -----------------------------------------------------------------------------------</span>


<span class="c1"># TODO: It seems in some cases, the better choice would be to oblige the user to deal</span>
<span class="c1">#  with return annotation explicitly</span>


<div class="viewcode-block" id="mk_sig"><a class="viewcode-back" href="../../../module_docs/i2/tests/signatures_test.html#i2.tests.signatures_test.mk_sig">[docs]</a><span class="k">def</span> <span class="nf">mk_sig</span><span class="p">(</span>
    <span class="n">obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Signature</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">return_annotations</span><span class="o">=</span><span class="n">empty</span><span class="p">,</span>
    <span class="o">**</span><span class="n">annotations</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convenience function to make a signature or inject annotations to an existing one.</span>

<span class="sd">    &gt;&gt;&gt; s = mk_sig(lambda a, b, c=1, d=&#39;bar&#39;: ..., b=int, d=str)</span>
<span class="sd">    &gt;&gt;&gt; s</span>
<span class="sd">    &lt;Signature (a, b: int, c=1, d: str = &#39;bar&#39;)&gt;</span>
<span class="sd">    &gt;&gt;&gt; # showing that sig can take a signature input, and overwrite an existing annotation:</span>
<span class="sd">    &gt;&gt;&gt; mk_sig(s, a=list, b=float)  # note the b=float</span>
<span class="sd">    &lt;Signature (a: list, b: float, c=1, d: str = &#39;bar&#39;)&gt;</span>
<span class="sd">    &gt;&gt;&gt; mk_sig()</span>
<span class="sd">    &lt;Signature ()&gt;</span>

<span class="sd">    Trying to annotate an argument that doesn&#39;t exist will lead to an AssertionError:</span>

<span class="sd">    &gt;&gt;&gt; mk_sig(lambda a, b=2, c=3: ..., d=int)  # doctest: +SKIP</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    AssertionError: These argument names weren&#39;t found in the signature: {&#39;d&#39;}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Signature</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">Signature</span><span class="o">.</span><span class="n">from_callable</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>  <span class="c1"># get a signature object from a callable</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Signature</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">parameters</span>  <span class="c1"># get the parameters attribute from a signature</span>
    <span class="n">params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>  <span class="c1"># get a writable copy of parameters</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">annotations</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">return_annotations</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="n">params</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;These argument names weren&#39;t found in the signature: </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nb">set</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">annotations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">default</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">Signature</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">return_annotations</span><span class="p">)</span></div>


<div class="viewcode-block" id="mk_signature"><a class="viewcode-back" href="../../../module_docs/i2/tests/signatures_test.html#i2.tests.signatures_test.mk_signature">[docs]</a><span class="k">def</span> <span class="nf">mk_signature</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">empty</span><span class="p">,</span> <span class="n">__validate_parameters__</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make an inspect.Signature object with less boilerplate verbosity.</span>
<span class="sd">    Args:</span>
<span class="sd">        signature: A list of parameter specifications. This could be an inspect.Parameter object or anything that</span>
<span class="sd">            the mk_param function can resolve into an inspect.Parameter object.</span>
<span class="sd">        return_annotation: Passed on to inspect.Signature.</span>
<span class="sd">        __validate_parameters__: Passed on to inspect.Signature.</span>

<span class="sd">    Returns:</span>
<span class="sd">        An inspect.Signature object</span>

<span class="sd">    # &gt;&gt;&gt; mk_signature([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">    # &lt;Signature (a, b, c)&gt;</span>
<span class="sd">    # &gt;&gt;&gt; mk_signature([&#39;a&#39;, (&#39;b&#39;, None), (&#39;c&#39;, 42, int)])  # specifying defaults and annotations</span>
<span class="sd">    # &lt;Signature (a, b=None, c: int = 42)&gt;</span>
<span class="sd">    # &gt;&gt;&gt; import inspect</span>
<span class="sd">    # &gt;&gt;&gt; mk_signature([&#39;a&#39;, (&#39;b&#39;, inspect._empty, int)])  # specifying an annotation without a default</span>
<span class="sd">    # &lt;Signature (a, b: int)&gt;</span>
<span class="sd">    # &gt;&gt;&gt; mk_signature([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], return_annotation=str)  # specifying return annotation</span>
<span class="sd">    # &lt;Signature (a, b, c) -&gt; str&gt;</span>
<span class="sd">    # &gt;&gt;&gt;</span>
<span class="sd">    # &gt;&gt;&gt; # But you can always specify parameters the &quot;long&quot; way</span>
<span class="sd">    # &gt;&gt;&gt; mk_signature([inspect.Parameter(name=&#39;kws&#39;, kind=inspect.Parameter.VAR_KEYWORD)], return_annotation=str)</span>
<span class="sd">    # &lt;Signature (**kws) -&gt; str&gt;</span>
<span class="sd">    # &gt;&gt;&gt;</span>
<span class="sd">    # &gt;&gt;&gt; # Note that mk_signature is an inverse of signature_to_dict:</span>
<span class="sd">    # &gt;&gt;&gt; def foo(a, b: int=0, c=None) -&gt; int: ...</span>
<span class="sd">    # &gt;&gt;&gt; sig_foo = signature(foo)</span>
<span class="sd">    # &gt;&gt;&gt; assert mk_signature(**signature_to_dict(sig_foo)) == sig_foo</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Sig</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">return_annotation</span><span class="p">)</span></div>


<span class="c1"># PATTERN: tree crud pattern</span>
<span class="k">def</span> <span class="nf">signature_to_dict</span><span class="p">(</span><span class="n">sig</span><span class="p">:</span> <span class="n">Signature</span><span class="p">):</span>
    <span class="c1"># warn(&quot;Use Sig instead&quot;, DeprecationWarning)</span>
    <span class="c1"># return Sig(sig).to_simple_signature()</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;parameters&#39;</span><span class="p">:</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">,</span>
        <span class="s1">&#39;return_annotation&#39;</span><span class="p">:</span> <span class="n">sig</span><span class="o">.</span><span class="n">return_annotation</span><span class="p">,</span>
    <span class="p">}</span>


<span class="k">def</span> <span class="nf">_merge_sig_dicts</span><span class="p">(</span><span class="n">sig1_dict</span><span class="p">,</span> <span class="n">sig2_dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Merge two signature dicts. A in dict.update(sig1_dict, **sig2_dict),</span>
<span class="sd">    but specialized for signature dicts.</span>
<span class="sd">    If sig1_dict and sig2_dict both define a parameter or return annotation,</span>
<span class="sd">    sig2_dict decides on what the output is.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;parameters&#39;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="n">sig1_dict</span><span class="p">[</span><span class="s1">&#39;parameters&#39;</span><span class="p">],</span> <span class="o">**</span><span class="n">sig2_dict</span><span class="p">[</span><span class="s1">&#39;parameters&#39;</span><span class="p">]),</span>
        <span class="s1">&#39;return_annotation&#39;</span><span class="p">:</span> <span class="n">sig2_dict</span><span class="p">[</span><span class="s1">&#39;return_annotation&#39;</span><span class="p">]</span>
        <span class="ow">or</span> <span class="n">sig1_dict</span><span class="p">[</span><span class="s1">&#39;return_annotation&#39;</span><span class="p">],</span>
    <span class="p">}</span>


<span class="k">def</span> <span class="nf">_merge_signatures</span><span class="p">(</span><span class="n">sig1</span><span class="p">,</span> <span class="n">sig2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the merged signatures of two signatures (sig2 is the final decider of conflics)</span>

<span class="sd">    &gt;&gt;&gt; def foo(a=&#39;a&#39;, b: int=0, c=None) -&gt; int: ...</span>
<span class="sd">    &gt;&gt;&gt; def bar(b: float=0.0, d: str=&#39;hi&#39;) -&gt; float: ...</span>
<span class="sd">    &gt;&gt;&gt; foo_sig = signature(foo)</span>
<span class="sd">    &gt;&gt;&gt; bar_sig = signature(bar)</span>
<span class="sd">    &gt;&gt;&gt; foo_sig</span>
<span class="sd">    &lt;Signature (a=&#39;a&#39;, b: int = 0, c=None) -&gt; int&gt;</span>
<span class="sd">    &gt;&gt;&gt; bar_sig</span>
<span class="sd">    &lt;Signature (b: float = 0.0, d: str = &#39;hi&#39;) -&gt; float&gt;</span>
<span class="sd">    &gt;&gt;&gt; _merge_signatures(foo_sig, bar_sig)</span>
<span class="sd">    &lt;Signature (a=&#39;a&#39;, b: float = 0.0, c=None, d: str = &#39;hi&#39;) -&gt; float&gt;</span>
<span class="sd">    &gt;&gt;&gt; _merge_signatures(bar_sig, foo_sig)</span>
<span class="sd">    &lt;Signature (b: int = 0, d: str = &#39;hi&#39;, a=&#39;a&#39;, c=None) -&gt; int&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># sig1_dict = Sig(sig1).to_simple_signature()</span>
    <span class="c1"># sig1_dict = signature_to_dict(sig1)</span>
    <span class="c1"># # remove variadic kinds from sig1</span>
    <span class="c1"># sig1_dict[&#39;parameters&#39;] = {k: v for k, v in sig1_dict[&#39;parameters&#39;].items() if v.kind not in var_param_kinds}</span>
    <span class="c1"># return Sig(**_merge_sig_dicts(sig1_dict, Sig(sig2).to_simple_dict()))</span>
    <span class="n">sig1_dict</span> <span class="o">=</span> <span class="n">signature_to_dict</span><span class="p">(</span><span class="n">sig1</span><span class="p">)</span>
    <span class="c1"># remove variadic kinds from sig1</span>
    <span class="n">sig1_dict</span><span class="p">[</span><span class="s1">&#39;parameters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sig1_dict</span><span class="p">[</span><span class="s1">&#39;parameters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var_param_kinds</span>
    <span class="p">}</span>
    <span class="n">kws</span> <span class="o">=</span> <span class="n">_merge_sig_dicts</span><span class="p">(</span><span class="n">sig1_dict</span><span class="p">,</span> <span class="n">signature_to_dict</span><span class="p">(</span><span class="n">sig2</span><span class="p">))</span>
    <span class="n">kws</span><span class="p">[</span><span class="s1">&#39;obj&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kws</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;parameters&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Sig</span><span class="p">(</span><span class="o">**</span><span class="n">kws</span><span class="p">)</span><span class="o">.</span><span class="n">to_simple_signature</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_merge_signatures_of_funcs</span><span class="p">(</span><span class="n">func1</span><span class="p">,</span> <span class="n">func2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the merged signatures of two functions (func2 is the final decider of conflics)</span>

<span class="sd">    &gt;&gt;&gt; def foo(a=&#39;a&#39;, b: int=0, c=None) -&gt; int: ...</span>
<span class="sd">    &gt;&gt;&gt; def bar(b: float=0.0, d: str=&#39;hi&#39;) -&gt; float: ...</span>
<span class="sd">    &gt;&gt;&gt; _merge_signatures_of_funcs(foo, bar)</span>
<span class="sd">    &lt;Signature (a=&#39;a&#39;, b: float = 0.0, c=None, d: str = &#39;hi&#39;) -&gt; float&gt;</span>
<span class="sd">    &gt;&gt;&gt; _merge_signatures_of_funcs(bar, foo)</span>
<span class="sd">    &lt;Signature (b: int = 0, d: str = &#39;hi&#39;, a=&#39;a&#39;, c=None) -&gt; int&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_merge_signatures</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">func1</span><span class="p">),</span> <span class="n">signature</span><span class="p">(</span><span class="n">func2</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_merged_signatures_of_func_list</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">return_annotation</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">empty</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &gt;&gt;&gt; def foo(a=&#39;a&#39;, b: int=0, c=None) -&gt; int: ...</span>
<span class="sd">    &gt;&gt;&gt; def bar(b: float=0.0, d: str=&#39;hi&#39;) -&gt; float: ...</span>
<span class="sd">    &gt;&gt;&gt; def hello(x: str=&#39;hi&#39;, y=1) -&gt; str: ...</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Test how the order of the functions affect the order of the parameters</span>
<span class="sd">    &gt;&gt;&gt; _merged_signatures_of_func_list([foo, bar, hello])</span>
<span class="sd">    &lt;Signature (a=&#39;a&#39;, b: float = 0.0, c=None, d: str = &#39;hi&#39;, x: str = &#39;hi&#39;, y=1)&gt;</span>
<span class="sd">    &gt;&gt;&gt; _merged_signatures_of_func_list([hello, foo, bar])</span>
<span class="sd">    &lt;Signature (x: str = &#39;hi&#39;, y=1, a=&#39;a&#39;, b: float = 0.0, c=None, d: str = &#39;hi&#39;)&gt;</span>
<span class="sd">    &gt;&gt;&gt; _merged_signatures_of_func_list([foo, bar, hello])</span>
<span class="sd">    &lt;Signature (a=&#39;a&#39;, b: float = 0.0, c=None, d: str = &#39;hi&#39;, x: str = &#39;hi&#39;, y=1)&gt;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Test the return_annotation argument</span>
<span class="sd">    &gt;&gt;&gt; _merged_signatures_of_func_list([foo, bar], list)  # specifying that the return type is a list</span>
<span class="sd">    &lt;Signature (a=&#39;a&#39;, b: float = 0.0, c=None, d: str = &#39;hi&#39;) -&gt; list&gt;</span>
<span class="sd">    &gt;&gt;&gt; _merged_signatures_of_func_list([foo, bar], foo)  # specifying that the return type is a list</span>
<span class="sd">    &lt;Signature (a=&#39;a&#39;, b: float = 0.0, c=None, d: str = &#39;hi&#39;) -&gt; int&gt;</span>
<span class="sd">    &gt;&gt;&gt; _merged_signatures_of_func_list([foo, bar], bar)  # specifying that the return type is a list</span>
<span class="sd">    &lt;Signature (a=&#39;a&#39;, b: float = 0.0, c=None, d: str = &#39;hi&#39;) -&gt; float&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">_merge_signatures</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="n">signature</span><span class="p">,</span> <span class="n">funcs</span><span class="p">))</span>
    <span class="c1"># s = Sig.from_objs(*funcs).to_simple_signature()</span>

    <span class="k">if</span> <span class="p">(</span>
        <span class="n">return_annotation</span> <span class="ow">in</span> <span class="n">funcs</span>
    <span class="p">):</span>  <span class="c1"># then you want the return annotation of a specific func of funcs</span>
        <span class="n">return_annotation</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">return_annotation</span><span class="p">)</span><span class="o">.</span><span class="n">return_annotation</span>

    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">return_annotation</span><span class="o">=</span><span class="n">return_annotation</span><span class="p">)</span>


<span class="c1"># TODO: will we need more options for the priority argument? Like position?</span>
<div class="viewcode-block" id="update_signature_with_signatures_from_funcs"><a class="viewcode-back" href="../../../module_docs/i2/tests/signatures_test.html#i2.tests.signatures_test.update_signature_with_signatures_from_funcs">[docs]</a><span class="k">def</span> <span class="nf">update_signature_with_signatures_from_funcs</span><span class="p">(</span><span class="o">*</span><span class="n">funcs</span><span class="p">,</span> <span class="n">priority</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;last&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a decorator that will merge the signatures of given funcs to the signature of the wrapped func.</span>
<span class="sd">    By default, the funcs signatures will be placed last, but can be given priority by asking priority = &#39;first&#39;</span>

<span class="sd">    &gt;&gt;&gt; def foo(a=&#39;a&#39;, b: int=0, c=None) -&gt; int: ...</span>
<span class="sd">    &gt;&gt;&gt; def bar(b: float=0.0, d: str=&#39;hi&#39;) -&gt; float: ...</span>
<span class="sd">    &gt;&gt;&gt; def something(y=(1, 2)): ...</span>
<span class="sd">    &gt;&gt;&gt; def another(y=10): ...</span>
<span class="sd">    &gt;&gt;&gt; @update_signature_with_signatures_from_funcs(foo, bar)</span>
<span class="sd">    ... def hello(x: str=&#39;hi&#39;, y=1) -&gt; str:</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; signature(hello)</span>
<span class="sd">    &lt;Signature (x: str = &#39;hi&#39;, y=1, a=&#39;a&#39;, b: float = 0.0, c=None, d: str = &#39;hi&#39;)&gt;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Try a different order and priority == &#39;first&#39;. Notice the b arg type and default!</span>
<span class="sd">    &gt;&gt;&gt; add_foobar_to_signature_first = update_signature_with_signatures_from_funcs(</span>
<span class="sd">    ...     bar, foo, priority=&#39;first&#39;</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; bar_foo_something = add_foobar_to_signature_first(something)</span>
<span class="sd">    &gt;&gt;&gt; signature(bar_foo_something)</span>
<span class="sd">    &lt;Signature (b: int = 0, d: str = &#39;hi&#39;, a=&#39;a&#39;, c=None, y=(1, 2))&gt;</span>
<span class="sd">    &gt;&gt;&gt; # See how you can reuse the decorator several times</span>
<span class="sd">    &gt;&gt;&gt; bar_foo_another = add_foobar_to_signature_first(another)</span>
<span class="sd">    &gt;&gt;&gt; signature(bar_foo_another)</span>
<span class="sd">    &lt;Signature (b: int = 0, d: str = &#39;hi&#39;, a=&#39;a&#39;, c=None, y=10)&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">priority</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;priority should be a string&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">priority</span> <span class="o">==</span> <span class="s1">&#39;last&#39;</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">transform_signature</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="c1"># func.__signature__ = Sig.from_objs(func, *funcs).to_simple_signature()</span>
            <span class="n">func</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">_merged_signatures_of_func_list</span><span class="p">([</span><span class="n">func</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">funcs</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">func</span>

    <span class="k">elif</span> <span class="n">priority</span> <span class="o">==</span> <span class="s1">&#39;first&#39;</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">transform_signature</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="c1"># func.__signature__ = Sig.from_objs(*funcs, func).to_simple_signature()</span>
            <span class="n">func</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">_merged_signatures_of_func_list</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">funcs</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">func</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">func</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;priority should be &#39;last&#39; or &#39;first&#39;&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">transform_signature</span></div>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span>
    <span class="s1">&#39;sig_spec&#39;</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;(po, /)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(po=0, /)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(pk)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(pk=0)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(*, ko)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(*, ko=0)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(po, /, pk, *, ko)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(po=0, /, pk=0, *, ko=0)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(*args)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(**kwargs)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(*args, **kwargs)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(po, /, pk, *args, ko)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(po=0, /, pk=0, *args, ko=0)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(po, /, pk, *, ko, **kwargs)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(po=0, /, pk=0, *, ko=0, **kwargs)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(po, /, pk, *args, ko, **kwargs)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(po=0, /, pk=0, *args, ko=0, **kwargs)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(po1, po2, /)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(pk1, pk2)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(*, ko1, ko2)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(po1, po2, /, pk1, pk2, *, ko1, ko2)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(po1, po2, /, pk1, pk2, *args, ko1, ko2, **kwargs)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(po1=0, po2=0, /, pk1=0, pk2=0, *args, ko1=0, ko2=0, **kwargs)&#39;</span><span class="p">),</span>
    <span class="p">],</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">test_call_forgivingly</span><span class="p">(</span><span class="n">sig_spec</span><span class="p">):</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">sig_spec</span><span class="p">)</span>

    <span class="nd">@sig</span>
    <span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="k">def</span> <span class="nf">validate_call_forgivingly</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">expected_output_kwargs</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">kwargs</span>
            <span class="k">if</span> <span class="n">VK</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">kinds</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="k">else</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sig</span><span class="p">}</span>
        <span class="p">)</span>
        <span class="n">pk_in_kwargs_count</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="n">kind</span> <span class="o">==</span> <span class="n">PK</span>
            <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">kind</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">kinds</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">expected_output_kwargs</span>
        <span class="p">)</span>
        <span class="n">expected_output_args_count</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">VP</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">kinds</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="k">else</span> <span class="nb">sum</span><span class="p">(</span><span class="n">kind</span> <span class="o">&lt;=</span> <span class="n">PK</span> <span class="k">for</span> <span class="n">kind</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">kinds</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">-</span> <span class="n">pk_in_kwargs_count</span>
        <span class="p">)</span>
        <span class="n">expected_output_args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="n">expected_output_args_count</span><span class="p">]</span>
        <span class="n">expected_output</span> <span class="o">=</span> <span class="p">(</span><span class="n">expected_output_args</span><span class="p">,</span> <span class="n">expected_output_kwargs</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">call_forgivingly</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># print()</span>
        <span class="c1"># print(args, kwargs)</span>
        <span class="c1"># print(expected_output)</span>
        <span class="c1"># print(output)</span>
        <span class="k">assert</span> <span class="n">output</span> <span class="o">==</span> <span class="n">expected_output</span>

    <span class="k">for</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="ow">in</span> <span class="n">sig_to_inputs</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">variadics_source</span><span class="o">=</span><span class="p">((),</span> <span class="p">{})):</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s1">&#39;some&#39;</span><span class="p">:</span> <span class="s1">&#39;extra&#39;</span><span class="p">,</span> <span class="s1">&#39;added&#39;</span><span class="p">:</span> <span class="s1">&#39;kwargs&#39;</span><span class="p">})</span>
        <span class="n">po_pk_count</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">kind</span> <span class="o">&lt;=</span> <span class="n">PK</span> <span class="k">for</span> <span class="n">kind</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">kinds</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="n">po_pk_count</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;some&#39;</span><span class="p">,</span> <span class="s1">&#39;extra&#39;</span><span class="p">,</span> <span class="s1">&#39;args&#39;</span><span class="p">)</span>

        <span class="n">validate_call_forgivingly</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="nd">@pytest</span><span class="o">.</span><span class="n">mark</span><span class="o">.</span><span class="n">parametrize</span><span class="p">(</span>
    <span class="s1">&#39;sig_spec1, sig_spec2&#39;</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;()&#39;</span><span class="p">,</span> <span class="s1">&#39;(a)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;()&#39;</span><span class="p">,</span> <span class="s1">&#39;(a=0)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(a, /, *, c)&#39;</span><span class="p">,</span> <span class="s1">&#39;(a, /, b, *, c)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(a, /, *, c)&#39;</span><span class="p">,</span> <span class="s1">&#39;(a, /, b=0, *, c)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(a, /, b)&#39;</span><span class="p">,</span> <span class="s1">&#39;(a, /, b, *, c)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(a, /, b)&#39;</span><span class="p">,</span> <span class="s1">&#39;(a, /, b, *, c=0)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(a, /, b, *, c)&#39;</span><span class="p">,</span> <span class="s1">&#39;(*args)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(a, /, b, *, c)&#39;</span><span class="p">,</span> <span class="s1">&#39;(**kwargs)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(a, /, b, *, c)&#39;</span><span class="p">,</span> <span class="s1">&#39;(*args, **kwargs)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(a, /, b, *, c)&#39;</span><span class="p">,</span> <span class="s1">&#39;(a, /, b, *args, c, **kwargs)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(a, /, b, *, c)&#39;</span><span class="p">,</span> <span class="s1">&#39;(a, b, c)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(a, /, b, *, c)&#39;</span><span class="p">,</span> <span class="s1">&#39;(a, b, /, *, c)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(a, /, b, *, c)&#39;</span><span class="p">,</span> <span class="s1">&#39;(a, /, *, b, c)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(a, /, b, *, c)&#39;</span><span class="p">,</span> <span class="s1">&#39;(a, b, /, c)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(a, /, b, *, c)&#39;</span><span class="p">,</span> <span class="s1">&#39;(a, *, b, c)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(a, /, b, *, c)&#39;</span><span class="p">,</span> <span class="s1">&#39;(x, /, b, *, c)&#39;</span><span class="p">,),</span>
        <span class="p">(</span><span class="s1">&#39;(a, /, b, *, c)&#39;</span><span class="p">,</span> <span class="s1">&#39;(a, /, x, *, c)&#39;</span><span class="p">,),</span>
        <span class="p">(</span><span class="s1">&#39;(a, /, b, *, c)&#39;</span><span class="p">,</span> <span class="s1">&#39;(a, /, b, *, x)&#39;</span><span class="p">,),</span>
        <span class="p">(</span><span class="s1">&#39;(a, /, b, *, c)&#39;</span><span class="p">,</span> <span class="s1">&#39;(a=0, b=0, c=0)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(a=0, /, b=0, *, c=0)&#39;</span><span class="p">,</span> <span class="s1">&#39;(a, b, c)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(a, b, /, c, d, *, e, f)&#39;</span><span class="p">,</span> <span class="s1">&#39;(b, a, /, d, c, *, f, e)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(a, b, /, c, d, *, e, f)&#39;</span><span class="p">,</span> <span class="s1">&#39;(a, c, /, b, e, *, d, f)&#39;</span><span class="p">,),</span>
        <span class="p">(</span><span class="s1">&#39;()&#39;</span><span class="p">,</span> <span class="s1">&#39;(*args)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;()&#39;</span><span class="p">,</span> <span class="s1">&#39;(**kwargs)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;()&#39;</span><span class="p">,</span> <span class="s1">&#39;(*args, **kwargs)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(*args)&#39;</span><span class="p">,</span> <span class="s1">&#39;()&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(*args)&#39;</span><span class="p">,</span> <span class="s1">&#39;(**kwargs)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(*args)&#39;</span><span class="p">,</span> <span class="s1">&#39;(*args, **kwargs)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(**kwargs)&#39;</span><span class="p">,</span> <span class="s1">&#39;()&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(**kwargs)&#39;</span><span class="p">,</span> <span class="s1">&#39;(*args)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(**kwargs)&#39;</span><span class="p">,</span> <span class="s1">&#39;(*args, **kwargs)&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;(*args, **kwargs)&#39;</span><span class="p">,</span> <span class="s1">&#39;(*args, **kwargs)&#39;</span><span class="p">),</span>
    <span class="p">],</span>
<span class="p">)</span>
<span class="k">def</span> <span class="nf">test_call_compatibility</span><span class="p">(</span><span class="n">sig_spec1</span><span class="p">,</span> <span class="n">sig_spec2</span><span class="p">):</span>
    <span class="n">sig1</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">sig_spec1</span><span class="p">)</span>
    <span class="n">sig2</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">sig_spec2</span><span class="p">)</span>
    <span class="n">is_compatible</span> <span class="o">=</span> <span class="n">sig1</span><span class="o">.</span><span class="n">is_call_compatible_with</span><span class="p">(</span><span class="n">sig2</span><span class="p">)</span>

    <span class="n">exec_env</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">f_def</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;def f</span><span class="si">{</span><span class="n">sig_spec2</span><span class="si">}</span><span class="s1">: pass&#39;</span>
    <span class="n">exec</span><span class="p">(</span><span class="n">f_def</span><span class="p">,</span> <span class="n">exec_env</span><span class="p">)</span>
    <span class="n">foo</span> <span class="o">=</span> <span class="n">exec_env</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span>

    <span class="c1"># @sig2</span>
    <span class="c1"># def foo(*args, **kwargs):</span>
    <span class="c1">#     pass</span>

    <span class="n">pos1</span><span class="p">,</span> <span class="n">pks1</span><span class="p">,</span> <span class="n">vp1</span><span class="p">,</span> <span class="n">kos1</span><span class="p">,</span> <span class="n">vk1</span> <span class="o">=</span> <span class="n">sig1</span><span class="o">.</span><span class="n">detail_names_by_kind</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="ow">in</span> <span class="n">sig_to_inputs</span><span class="p">(</span><span class="n">sig1</span><span class="p">,</span> <span class="n">variadics_source</span><span class="o">=</span><span class="p">((),</span> <span class="p">{})):</span>
        <span class="k">if</span> <span class="n">vp1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">pks1</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;extra_arg&#39;</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">vk1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;extra_kwarg_key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;extra_kwarg_value&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">foo</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_compatible</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_compatible</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;sig1 is not compatible with sig2, when it should.&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">test_bool</span><span class="p">():</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;bool&#39;</span>

    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">sigs_for_sigless_builtin_name</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

    <span class="k">assert</span> <span class="n">function_is_compatible_with_signature</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>


<div class="viewcode-block" id="visualize_errors_for_function_call"><a class="viewcode-back" href="../../../module_docs/i2/tests/signatures_test.html#i2.tests.signatures_test.visualize_errors_for_function_call">[docs]</a><span class="k">def</span> <span class="nf">visualize_errors_for_function_call</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">sig</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calls func on sig_to_inputs and prints error if any</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;============================================================</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="ow">in</span> <span class="n">sig_to_inputs</span><span class="p">(</span><span class="n">sig</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">call_and_return_error</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">args</span><span class="si">=}</span><span class="s1"> , </span><span class="si">{</span><span class="n">kwargs</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">test_sigless_builtins</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span><span class="p">,</span> <span class="n">attrgetter</span><span class="p">,</span> <span class="n">methodcaller</span>

    <span class="n">mapping_methods</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;__eq__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__ne__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__iter__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__getitem__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__len__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__contains__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__setitem__&#39;</span><span class="p">,</span>
        <span class="s1">&#39;__delitem__&#39;</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">special_cases</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;breakpoint&#39;</span><span class="p">}</span> <span class="o">|</span> <span class="n">mapping_methods</span>

    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sigs_for_sigless_builtin_name</span><span class="p">:</span>
        <span class="c1"># removed breakpoint as it triggers a pdb session</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">special_cases</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">sigs_for_sigless_builtin_name</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">function_is_compatible_with_signature</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">sig</span><span class="p">)</span>

    <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">mapping_methods</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">function_is_compatible_with_signature</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">Sig</span><span class="p">(</span><span class="n">method</span><span class="p">))</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright OtoSense 2020.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
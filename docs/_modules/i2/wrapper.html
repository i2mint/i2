<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>i2.wrapper &mdash; i2 0.0.59 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/toggleprompt.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> i2
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2.html">i2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/base.html">i2.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/chain_map.html">i2.chain_map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/deco.html">i2.deco</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/doc_mint.html">i2.doc_mint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/errors.html">i2.errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/examples.html">i2.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/examples/signature_calculus.html">i2.examples.signature_calculus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/footprints.html">i2.footprints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/io_trans.html">i2.io_trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/itypes.html">i2.itypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/key_path.html">i2.key_path</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/multi_object.html">i2.multi_object</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/routing_forest.html">i2.routing_forest</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/scrap.html">i2.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/scrap/scrap.html">i2.scrap.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/scrap/simple_pymint.html">i2.scrap.simple_pymint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/signatures.html">i2.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/switch_case_tree.html">i2.switch_case_tree</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests.html">i2.tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/footprints_test.html">i2.tests.footprints_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/objects_for_testing.html">i2.tests.objects_for_testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/signatures_test.html">i2.tests.signatures_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/test_util.html">i2.tests.test_util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/wrapper_test.html">i2.tests.wrapper_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/util.html">i2.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/wrapper.html">i2.wrapper</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">i2</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>i2.wrapper</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for i2.wrapper</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;A wrapper object and tools to work with it&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span><span class="p">,</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">signature</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Callable</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">MethodType</span>

<span class="kn">from</span> <span class="nn">i2.signatures</span> <span class="kn">import</span> <span class="n">Sig</span>
<span class="kn">from</span> <span class="nn">i2.multi_object</span> <span class="kn">import</span> <span class="n">Pipe</span>

<span class="n">empty</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span>


<div class="viewcode-block" id="identity"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.identity">[docs]</a><span class="k">def</span> <span class="nf">identity</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transparent function, returning what&#39;s been input&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="double_up_as_factory"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.double_up_as_factory">[docs]</a><span class="k">def</span> <span class="nf">double_up_as_factory</span><span class="p">(</span><span class="n">decorator_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Repurpose a decorator both as it&#39;s original form, and as a decorator factory.</span>

<span class="sd">    That is, from a decorator that is defined do ``wrapped_func = decorator(func, **params)``,</span>
<span class="sd">    make it also be able to do ``wrapped_func = decorator(**params)(func)``.</span>

<span class="sd">    Note: You&#39;ll only be able to do this if all but the first argument are keyword-only,</span>
<span class="sd">    and the first argument (the function to decorate) has a default of ``None`` (this is for your own good).</span>
<span class="sd">    This is validated before making the &quot;double up as factory&quot; decorator.</span>

<span class="sd">    &gt;&gt;&gt; @double_up_as_factory</span>
<span class="sd">    ... def decorator(func=None, *, multiplier=2):</span>
<span class="sd">    ...     def _func(x):</span>
<span class="sd">    ...         return func(x) * multiplier</span>
<span class="sd">    ...     return _func</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; def foo(x):</span>
<span class="sd">    ...     return x + 1</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; foo(2)</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; wrapped_foo = decorator(foo, multiplier=10)</span>
<span class="sd">    &gt;&gt;&gt; wrapped_foo(2)</span>
<span class="sd">    30</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; multiply_by_3 = decorator(multiplier=3)</span>
<span class="sd">    &gt;&gt;&gt; wrapped_foo = multiply_by_3(foo)</span>
<span class="sd">    &gt;&gt;&gt; wrapped_foo(2)</span>
<span class="sd">    9</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; @decorator(multiplier=3)</span>
<span class="sd">    ... def foo(x):</span>
<span class="sd">    ...     return x + 1</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; foo(2)</span>
<span class="sd">    9</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">validate_decorator_func</span><span class="p">(</span><span class="n">decorator_func</span><span class="p">):</span>
        <span class="n">first_param</span><span class="p">,</span> <span class="o">*</span><span class="n">other_params</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">decorator_func</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">first_param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;First argument of the decorator function needs to default to None. &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;Was </span><span class="si">{</span><span class="n">first_param</span><span class="o">.</span><span class="n">default</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">}</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">other_params</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;All arguments (besides the first) need to be keyword-only&#39;</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="n">validate_decorator_func</span><span class="p">(</span><span class="n">decorator_func</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">decorator_func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_double_up_as_factory</span><span class="p">(</span><span class="n">wrapped</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># then we want a factory</span>
            <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">decorator_func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">decorator_func</span><span class="p">(</span><span class="n">wrapped</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_double_up_as_factory</span></div>


<div class="viewcode-block" id="transparent_ingress"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.transparent_ingress">[docs]</a><span class="k">def</span> <span class="nf">transparent_ingress</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; transparent_ingress(1, 2, test=1)</span>
<span class="sd">    ((1, 2), {&#39;test&#39;: 1})</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span></div>


<div class="viewcode-block" id="transparent_egress"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.transparent_egress">[docs]</a><span class="k">def</span> <span class="nf">transparent_egress</span><span class="p">(</span><span class="n">output</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; transparent_egress(&#39;unnecessary_doctest&#39;)</span>
<span class="sd">    &#39;unnecessary_doctest&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">output</span></div>


<span class="c1"># TODO: Put in module docs when md docs work!</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    How the `Wrap` class works:</span>

<span class="sd">    ```</span>
<span class="sd">          *outer_args, **outer_kwargs</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">    ┌───────────────────────────────────┐</span>
<span class="sd">    │              ingress              │</span>
<span class="sd">    └───────────────────────────────────┘</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">          *inner_args, **inner_kwargs</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">    ┌───────────────────────────────────┐</span>
<span class="sd">    │               func                │</span>
<span class="sd">    └───────────────────────────────────┘</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">                 func_output</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">    ┌───────────────────────────────────┐</span>
<span class="sd">    │              egress               │</span>
<span class="sd">    └───────────────────────────────────┘</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">                final_output</span>
<span class="sd">    ```</span>
<span class="sd">    </span>
<span class="sd">    How the `Ingress` class (ingress templated function maker) works:</span>
<span class="sd">    </span>
<span class="sd">    ```</span>
<span class="sd">          *outer_args, **outer_kwargs</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">    ┌───────────────────────────────────┐</span>
<span class="sd">    │          outer_sig_bind           │</span>
<span class="sd">    └───────────────────────────────────┘</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">              outer_all_kwargs</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">    ┌───────────────────────────────────┐</span>
<span class="sd">    │            kwargs_trans           │</span>
<span class="sd">    └───────────────────────────────────┘</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">              inner_all_kwargs</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">    ┌───────────────────────────────────┐</span>
<span class="sd">    │          inner_sig_bind           │</span>
<span class="sd">    └───────────────────────────────────┘</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">          *inner_args, **inner_kwargs</span>
<span class="sd">    ```</span>
<span class="sd">    </span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="Wrap"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.Wrap">[docs]</a><span class="k">class</span> <span class="nc">Wrap</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A function wrapper with interface modifiers.</span>

<span class="sd">    :param func: The wrapped function</span>
<span class="sd">    :param ingress: The incoming data transformer. It determines the argument properties</span>
<span class="sd">        (name, kind, default and annotation) as well as the actual input of the</span>
<span class="sd">        wrapped function.</span>
<span class="sd">    :param egress: The outgoing data transformer. It also takes precedence over the</span>
<span class="sd">        wrapped function to determine the return annotation of the ``Wrap`` instance</span>
<span class="sd">    :return: A callable instance wrapping ``func``</span>

<span class="sd">    Some examples:</span>

<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; from i2 import Sig</span>

<span class="sd">    &gt;&gt;&gt; def func(a, b):</span>
<span class="sd">    ...     return a * b</span>

<span class="sd">    &gt;&gt;&gt; wrapped_func = wrap(func)  # no transformations: wrapped_func is the same as func</span>
<span class="sd">    &gt;&gt;&gt; assert wrapped_func(2, &#39;Hi&#39;) == func(2, &#39;Hi&#39;) == &#39;HiHi&#39;</span>

<span class="sd">    Modifying the first argument</span>

<span class="sd">    &gt;&gt;&gt; def ingress(a, b):</span>
<span class="sd">    ...   return (2 * a, b), dict()</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func = wrap(func, ingress=ingress)  # first variable is now multiplied by 2</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func(2, &#39;Hi&#39;)</span>
<span class="sd">    &#39;HiHiHiHi&#39;</span>

<span class="sd">    Same using keyword args, we need to use tuple to represent an empty tuple</span>

<span class="sd">    &gt;&gt;&gt; def ingress(a, b):</span>
<span class="sd">    ...   return tuple(), dict(a=2 * a, b=b) # Note that b MUST be present as well, or an error will be raised</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func = wrap(func, ingress=ingress)  # first variable is now multiplied by 2</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func(2, &#39;Hi&#39;)</span>
<span class="sd">    &#39;HiHiHiHi&#39;</span>

<span class="sd">    Using both args and kwargs</span>

<span class="sd">    &gt;&gt;&gt; def ingress(a, b):</span>
<span class="sd">    ...   return (2 * a, ), dict(b=b)</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func = wrap(func, ingress=ingress)  # first variable is now multiplied by 2</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func(2, &#39;Hi&#39;)</span>
<span class="sd">    &#39;HiHiHiHi&#39;</span>

<span class="sd">    We can use ingress to ADD parameters to func</span>

<span class="sd">    &gt;&gt;&gt; def ingress(a, b, c):</span>
<span class="sd">    ...   return (a, b + c), dict()</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func = wrap(func, ingress=ingress)</span>
<span class="sd">    &gt;&gt;&gt; # now wrapped_func takes three arguments</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func(2, &#39;Hi&#39;, &#39;world!&#39;)</span>
<span class="sd">    &#39;Hiworld!Hiworld!&#39;</span>

<span class="sd">    Egress is a bit more straightforward, it simply applies to the output of the</span>
<span class="sd">    wrapped function. We can use ingress to ADD parameters to func</span>

<span class="sd">    &gt;&gt;&gt; def egress(output):</span>
<span class="sd">    ...   return output + &#39; ITSME!!!&#39;</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func = wrap(func, ingress=ingress, egress=egress)</span>
<span class="sd">    &gt;&gt;&gt; # now wrapped_func takes three arguments</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func(2, &#39;Hi&#39;, &#39;world!&#39;)</span>
<span class="sd">    &#39;Hiworld!Hiworld! ITSME!!!&#39;</span>


<span class="sd">    A more involved example:</span>

<span class="sd">    &gt;&gt;&gt; def ingress(a, b: str, c=&quot;hi&quot;):</span>
<span class="sd">    ...     return (a + len(b) % 2,), dict(string=f&quot;{c} {b}&quot;)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; def func(times, string):</span>
<span class="sd">    ...     return times * string</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func = wrap(func, ingress)</span>
<span class="sd">    &gt;&gt;&gt; assert wrapped_func(2, &quot;world! &quot;, &quot;Hi&quot;) == &quot;Hi world! Hi world! Hi world! &quot;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func = wrap(func, egress=len)</span>
<span class="sd">    &gt;&gt;&gt; assert wrapped_func(2, &quot;co&quot;) == 4 == len(&quot;coco&quot;) == len(func(2, &quot;co&quot;))</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func = wrap(func, ingress, egress=len)</span>
<span class="sd">    &gt;&gt;&gt; assert (</span>
<span class="sd">    ...     wrapped_func(2, &quot;world! &quot;, &quot;Hi&quot;)</span>
<span class="sd">    ...     == 30</span>
<span class="sd">    ...     == len(&quot;Hi world! Hi world! Hi world! &quot;)</span>
<span class="sd">    ... )</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        ``wrap`` function.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">ingress</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">egress</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># TODO: should we really copy everything by default?</span>

        <span class="c1"># remember the actual value of ingress and egress (for reduce to reproduce)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ingress</span> <span class="o">=</span> <span class="n">ingress</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_egress</span> <span class="o">=</span> <span class="n">egress</span>

        <span class="n">return_annotation</span> <span class="o">=</span> <span class="n">empty</span>
        <span class="k">if</span> <span class="n">ingress</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ingress</span> <span class="o">=</span> <span class="n">ingress</span>
            <span class="n">return_annotation</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">return_annotation</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ingress</span> <span class="o">=</span> <span class="n">transparent_ingress</span>

        <span class="k">if</span> <span class="n">egress</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">egress</span> <span class="o">=</span> <span class="n">egress</span>
            <span class="n">egress_return_annotation</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">egress</span><span class="p">)</span><span class="o">.</span><span class="n">return_annotation</span>
            <span class="k">if</span> <span class="n">egress_return_annotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">return_annotation</span> <span class="o">=</span> <span class="n">egress_return_annotation</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">egress</span> <span class="o">=</span> <span class="n">transparent_egress</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">ingress</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">return_annotation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__wrapped__</span> <span class="o">=</span> <span class="n">func</span>
        <span class="c1"># TODO: Pros and cons analysis of pointing __wrapped__ to func. partial uses</span>
        <span class="c1">#  .func, but wraps looks for __wrapped__</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">ingress_args</span><span class="p">,</span> <span class="o">**</span><span class="n">ingress_kwargs</span><span class="p">):</span>
        <span class="n">func_args</span><span class="p">,</span> <span class="n">func_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ingress</span><span class="p">(</span><span class="o">*</span><span class="n">ingress_args</span><span class="p">,</span> <span class="o">**</span><span class="n">ingress_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">egress</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">func_args</span><span class="p">,</span> <span class="o">**</span><span class="n">func_kwargs</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ingress</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_egress</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">MethodType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">)</span></div>


<div class="viewcode-block" id="wrap"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.wrap">[docs]</a><span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">ingress</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">egress</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrap a function, optionally transforming interface, input and output.</span>

<span class="sd">    :param func: The wrapped function</span>
<span class="sd">    :param ingress: The incoming data transformer. It determines the argument properties</span>
<span class="sd">        (name, kind, default and annotation) as well as the actual input of the</span>
<span class="sd">        wrapped function.</span>
<span class="sd">    :param egress: The outgoing data transformer. It also takes precedence over the</span>
<span class="sd">        wrapped function to determine the return annotation of the ``Wrap`` instance</span>
<span class="sd">    :return: A callable instance wrapping ``func``</span>

<span class="sd">    Consider the following function.</span>

<span class="sd">    &gt;&gt;&gt; def f(w, /, x: float = 1, y=2, *, z: int = 3):</span>
<span class="sd">    ...     return w + x * y ** z</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; assert f(0) == 8</span>
<span class="sd">    &gt;&gt;&gt; assert f(1,2) == 17 == 1 + 2 * 2 ** 3</span>

<span class="sd">    See that ``f`` is restricted to use ``z`` as keyword only argument kind:</span>

<span class="sd">    &gt;&gt;&gt; f(1, 2, 3, 4)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    TypeError: f() takes from 1 to 3 positional arguments but 4 were given</span>

<span class="sd">    and ``w`` has position only argument kind:</span>

<span class="sd">    &gt;&gt;&gt; f(w=1, x=2, y=3, z=4)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    TypeError: f() got some positional-only arguments passed as keyword arguments: &#39;w&#39;</span>

<span class="sd">    Say we wanted a version of this function that didn&#39;t have the argument kind</span>
<span class="sd">    restrinctions, where the annotation of ``x`` was ``int`` and where the default</span>
<span class="sd">    of ``z`` was ``10`` instead of ``3``, and doesn&#39;t have an annotation.</span>
<span class="sd">    We can do so using the following ingress function:</span>

<span class="sd">    &gt;&gt;&gt; def ingress(w, x: int = 1, y: int=2, z = 10):</span>
<span class="sd">    ...     return (w,), dict(x=x, y=y, z=z)</span>

<span class="sd">    The ingress function serves two purposes:</span>

<span class="sd">    - Redefining the signature (i.e. the argument names, kinds, defaults,</span>
<span class="sd">    and annotations (not including the return annotation, which is taken care of by the</span>
<span class="sd">    egress argument).</span>

<span class="sd">    - Telling the wrapper how to get from that interface to the interface of the</span>
<span class="sd">    wrapped function.</span>

<span class="sd">    If we also wanted to add a return_annotation, we could do so via an ``egress``</span>
<span class="sd">    function argument:</span>

<span class="sd">    &gt;&gt;&gt; def egress(wrapped_func_output) -&gt; float:</span>
<span class="sd">    ...     return wrapped_func_output  # because here we don&#39;t want to do anything extra</span>

<span class="sd">    Now we can use these ingress and egress functions to get the version of ``f`` of</span>
<span class="sd">    our dreams:</span>

<span class="sd">    &gt;&gt;&gt; h = wrap(f, ingress, egress)</span>

<span class="sd">    Let&#39;s see what the signature of our new function looks like:</span>

<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; str(signature(h))</span>
<span class="sd">    &#39;(w, x: int = 1, y: int = 2, z=10) -&gt; float&#39;</span>

<span class="sd">    Now let&#39;s see that we can actually use this new function ``h``, without the</span>
<span class="sd">    restrictions of argument kind, getting the same results as the wrapped ``f``,</span>
<span class="sd">    but with default ``z=10``.</span>

<span class="sd">    What we wanted (but couldn&#39;t) do with ``f``:</span>

<span class="sd">    &gt;&gt;&gt; h(1, 2, 3, 4)  # == 1 + 2 * 3 ** 4</span>
<span class="sd">    163</span>
<span class="sd">    &gt;&gt;&gt; h(w=1, x=2, y=3, z=4)</span>
<span class="sd">    163</span>

<span class="sd">    &gt;&gt;&gt; assert h(0) == h(0, 1) == h(0, 1, 2) == 0 + 1 * 2 ** 10 == 2 ** 10 == 1024</span>

<span class="sd">    For more examples, see also the</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        ``Wrap`` class.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Wrap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">ingress</span><span class="p">,</span> <span class="n">egress</span><span class="p">)</span></div>


<div class="viewcode-block" id="append_empty_args"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.append_empty_args">[docs]</a><span class="k">def</span> <span class="nf">append_empty_args</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;To use to transform an ingress function that only returns kwargs to one that</span>
<span class="sd">    returns the normal form of ingress functions: ((), kwargs)&quot;&quot;&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(),</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_func</span></div>


<div class="viewcode-block" id="Ingress"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.Ingress">[docs]</a><span class="k">class</span> <span class="nc">Ingress</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;The Ingress class offers a template for creating ingress classes.</span>

<span class="sd">    Note that when writing a decorator with i2.wrapper, you&#39;re usually better off</span>
<span class="sd">    writing an ingress function for the purpose. As a result, your code will usually</span>
<span class="sd">    be less complex, easier to read, and more efficient than using the Ingress class.</span>

<span class="sd">    So why use the Ingress class at all? For one, because it&#39;ll take care of some common</span>
<span class="sd">    mechanics for you, so once you understand how to use it,</span>
<span class="sd">    you&#39;ll probably create a correct wrapper faster.</span>

<span class="sd">    Further, if you&#39;re writing a general wrapping tool (e.g. your own currying machine,</span>
<span class="sd">    some rule-based input casting function, etc.) then you&#39;ll find that using</span>
<span class="sd">    Ingres will usually with on the complexity, readability and/or efficiency front.</span>

<span class="sd">    &gt;&gt;&gt; from i2.wrapper import Ingress, wrap</span>
<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; from i2.wrapper import InnerMapIngress</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Ingress = InnerMapIngress</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; def f(w, /, x: float, y=2, *, z: int = 3):</span>
<span class="sd">    ...     return f&quot;(w:={w}) + (x:={x}) * (y:={y}) ** (z:={z}) == {w + x * y ** z}&quot;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; f(0, 1)</span>
<span class="sd">    &#39;(w:=0) + (x:=1) * (y:=2) ** (z:=3) == 8&#39;</span>

<span class="sd">    Let’s say you wanted to dispatch this function to a command line interface,</span>
<span class="sd">    or a webservice where all arguments are taken from the url.</span>
<span class="sd">    The problem here is that this means that all incoming values will be strings</span>
<span class="sd">    in that case.</span>
<span class="sd">    Say you wanted all input values to be cast to ints. In that case you could do:</span>

<span class="sd">    &gt;&gt;&gt; trans_all_vals_to_ints = lambda d: {k: int(v) for k, v in d.items()}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; cli_f = wrap(</span>
<span class="sd">    ...     f,</span>
<span class="sd">    ...     ingress=Ingress(signature(f), kwargs_trans=trans_all_vals_to_ints)</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; cli_f(&quot;2&quot;, &quot;3&quot;, &quot;4&quot;)</span>
<span class="sd">    &#39;(w:=2) + (x:=3) * (y:=4) ** (z:=3) == 194&#39;</span>

<span class="sd">    In a more realistic situation, you&#39;d want to have more control over this value</span>
<span class="sd">    transformation.</span>

<span class="sd">    Say you wanted to convert to int if it&#39;s possible, try float if not,</span>
<span class="sd">    and just leave the string alone otherwise.</span>

<span class="sd">    &gt;&gt;&gt; def _try_casting_to_numeric(x):</span>
<span class="sd">    ...     try:</span>
<span class="sd">    ...         return int(x)</span>
<span class="sd">    ...     except ValueError:</span>
<span class="sd">    ...         try:</span>
<span class="sd">    ...             return float(x)</span>
<span class="sd">    ...         except ValueError:</span>
<span class="sd">    ...             return x</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; def cast_numbers(d: dict):</span>
<span class="sd">    ...     return {k: _try_casting_to_numeric(v) for k, v in d.items()}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; cli_f = wrap(f, ingress=Ingress(signature(f), kwargs_trans=cast_numbers))</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; cli_f(&quot;2&quot;, &quot;3.14&quot;, &quot;4&quot;)</span>
<span class="sd">    &#39;(w:=2) + (x:=3.14) * (y:=4) ** (z:=3) == 202.96&#39;</span>

<span class="sd">    Let&#39;s say that our values transformations are not all 1-to-1 as in the examples</span>
<span class="sd">    above.</span>
<span class="sd">    Instead, they can be</span>

<span class="sd">    - `1-to-many` (e.g. the outer &#39;w&#39; is used to compute the inner `w` and `x`)</span>

<span class="sd">    - `many-to-1 (e.g. the outer `x` and `y` are used to compute inner `y`)</span>

<span class="sd">    ```</span>
<span class="sd">      w   x   y   z</span>
<span class="sd">     / \   \ /    |</span>
<span class="sd">    w   x   y     z</span>
<span class="sd">    ```</span>

<span class="sd">    &gt;&gt;&gt; def kwargs_trans(outer_kw):</span>
<span class="sd">    ...     return dict(</span>
<span class="sd">    ...         # e.g. 1-to-many: one outer arg (w) producing two inner args (w, and y)</span>
<span class="sd">    ...         w=outer_kw[&#39;w&#39;] * 2,</span>
<span class="sd">    ...         x=outer_kw[&#39;w&#39;] * 3,</span>
<span class="sd">    ...         # e.g. many-to-1: two outer args (x and y) producing one inner arg (y)</span>
<span class="sd">    ...         y=outer_kw[&#39;x&#39;] + outer_kw[&#39;y&#39;],</span>
<span class="sd">    ...         # Note that no z is mentioned: This means we&#39;re just leaving it alone</span>
<span class="sd">    ...     )</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; ingress = Ingress(signature(f), kwargs_trans=kwargs_trans)</span>
<span class="sd">    &gt;&gt;&gt; assert ingress(2, x=3, y=4) == ((4,), {&#39;x&#39;: 6, &#39;y&#39;: 7, &#39;z&#39;: 3})</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; wrapped_f = wrap(f, ingress)</span>
<span class="sd">    &gt;&gt;&gt; assert wrapped_f(2, x=3, y=4) == &#39;(w:=4) + (x:=6) * (y:=7) ** (z:=3) == 2062&#39;</span>


<span class="sd">    The following is an example that involves several aspects of the `Ingress` class.</span>

<span class="sd">    &gt;&gt;&gt; from i2 import Sig</span>
<span class="sd">    &gt;&gt;&gt; def kwargs_trans(outer_kw):</span>
<span class="sd">    ...     return dict(</span>
<span class="sd">    ...         w=outer_kw[&#39;w&#39;] * 2,</span>
<span class="sd">    ...         x=outer_kw[&#39;w&#39;] * 3,</span>
<span class="sd">    ...         # need to pop you (inner func has no you argument)</span>
<span class="sd">    ...         y=outer_kw[&#39;x&#39;] + outer_kw.pop(&#39;you&#39;),</span>
<span class="sd">    ...         # Note that no z is mentioned: This means we&#39;re just leaving it alone</span>
<span class="sd">    ...     )</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; ingress = Ingress(</span>
<span class="sd">    ...     inner_sig=signature(f),</span>
<span class="sd">    ...     kwargs_trans=kwargs_trans,</span>
<span class="sd">    ...     outer_sig=Sig(f).ch_names(y=&#39;you&#39;)  # need to give the outer sig a you</span>
<span class="sd">    ...     # You could also express it this way (though you&#39;d loose the annotations)</span>
<span class="sd">    ...     # outer_sig=lambda w, /, x, you=2, *, z=3: None</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; assert ingress(2, x=3, you=4) == ((4,), {&#39;x&#39;: 6, &#39;y&#39;: 7, &#39;z&#39;: 3})</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; wrapped_f = wrap(f, ingress)</span>
<span class="sd">    &gt;&gt;&gt; assert wrapped_f(2, x=3, you=4) == &#39;(w:=4) + (x:=6) * (y:=7) ** (z:=3) == 2062&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inner_sig</span><span class="p">,</span> <span class="n">kwargs_trans</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">outer_sig</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Init of an Ingress instance.</span>

<span class="sd">        :param inner_sig: Signature of the inner function the ingress is for.</span>
<span class="sd">            The function itself can be given and the signature will be extracted.</span>
<span class="sd">        :param kwargs_trans: A dict-to-dict transformation of the outer kwargs to</span>
<span class="sd">            the kwargs that should be input to the inner function.</span>
<span class="sd">        :param outer_sig: The outer signature. The signature the ingress function</span>
<span class="sd">            (there for the wrapped function) will have. Also serves to convert input</span>
<span class="sd">            (args, kwargs) to the kwargs that will be given to kwargs_trans.</span>

<span class="sd">        When making an Ingress function directly, one must take care that</span>
<span class="sd">        `inner_sig`, `kwargs_trans` and `outer_sig` are aligned.</span>

<span class="sd">        Namely, &#39;kwargs_trans&#39; must be able to handle outputs of</span>
<span class="sd">        `outer_sig.kwargs_from_args_and_kwargs` and itself output kwargs that</span>
<span class="sd">        can be handled by `inner_sig.args_and_kwargs_from_kwargs`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inner_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">inner_sig</span><span class="p">)</span>

        <span class="c1"># kwargs_trans should be callable and have one required arg: a dict</span>
        <span class="c1"># if it&#39;s None, we&#39;ll just make it be the identity function</span>
        <span class="k">if</span> <span class="n">kwargs_trans</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs_trans</span> <span class="o">=</span> <span class="n">identity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs_trans</span> <span class="o">=</span> <span class="n">kwargs_trans</span>

        <span class="c1"># default to inner_sig = outer_sig</span>
        <span class="k">if</span> <span class="n">outer_sig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outer_sig</span> <span class="o">=</span> <span class="n">inner_sig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outer_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">outer_sig</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">outer_sig</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">ingress_args</span><span class="p">,</span> <span class="o">**</span><span class="n">ingress_kwargs</span><span class="p">):</span>
        <span class="c1"># Get the all-keywords version of the arguments (args,kwargs-&gt;kwargs)</span>
        <span class="n">func_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outer_sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
            <span class="n">ingress_args</span><span class="p">,</span> <span class="n">ingress_kwargs</span><span class="p">,</span> <span class="n">apply_defaults</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="n">func_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">func_kwargs</span><span class="p">,</span>  <span class="c1"># by default, keep the func_kwargs, but</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs_trans</span><span class="p">(</span><span class="n">func_kwargs</span><span class="p">),</span>  <span class="c1"># change those that kwargs_trans desires</span>
        <span class="p">)</span>

        <span class="c1"># Return an (args,kwargs) pair the respects the inner function&#39;s</span>
        <span class="c1"># argument kind restrictions.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner_sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span>
            <span class="n">func_kwargs</span><span class="p">,</span> <span class="n">apply_defaults</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Ingress.name_map"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.Ingress.name_map">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">name_map</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">wrapped</span><span class="p">,</span> <span class="o">**</span><span class="n">new_names</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change argument names&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">wrapped</span><span class="p">,</span>
            <span class="n">partial</span><span class="p">(</span><span class="n">Pipe</span><span class="p">(</span><span class="n">items_with_mapped_keys</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="n">key_mapper</span><span class="o">=</span><span class="n">new_names</span><span class="p">),</span>
            <span class="n">Sig</span><span class="p">(</span><span class="n">wrapped</span><span class="p">)</span><span class="o">.</span><span class="n">ch_names</span><span class="p">(</span><span class="o">**</span><span class="n">new_names</span><span class="p">),</span>
        <span class="p">)</span></div></div>

    <span class="c1">#     @classmethod</span>
    <span class="c1">#     def defaults(cls, wrapped, **defaults):</span>
    <span class="c1">#         &quot;&quot;&quot;&quot;&quot;&quot;</span>
    <span class="c1">#</span>
    <span class="c1">#     @classmethod</span>
    <span class="c1">#     def order(cls, wrapped, arg_order):</span>
    <span class="c1">#         &quot;&quot;&quot;&quot;&quot;&quot;</span>
    <span class="c1">#</span>
    <span class="c1">#     @classmethod</span>
    <span class="c1">#     def factory(cls, wrapped, **func_for_name):</span>
    <span class="c1">#         &quot;&quot;&quot;&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">items_with_mapped_keys</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">key_mapper</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># key_mapper.get(k, k) will give the new key name if present, else will use</span>
        <span class="c1"># the old</span>
        <span class="k">yield</span> <span class="n">key_mapper</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">v</span>


<span class="k">def</span> <span class="nf">invert_map</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="n">new_d</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_d</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">new_d</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;There are duplicate keys so I can invert map: </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>


<span class="kn">from</span> <span class="nn">i2.signatures</span> <span class="kn">import</span> <span class="n">parameter_to_dict</span>


<span class="k">def</span> <span class="nf">parameters_to_dict</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">parameter_to_dict</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>


<span class="k">def</span> <span class="nf">_handle_ingress_class_inputs</span><span class="p">(</span>
    <span class="n">inner_sig</span><span class="p">,</span> <span class="n">kwargs_trans</span><span class="p">,</span> <span class="n">outer_sig</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">_allow_reordering</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
    <span class="n">inner_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">inner_sig</span><span class="p">)</span>

    <span class="c1"># kwargs_trans should be callable and have one required arg: a dict</span>
    <span class="c1"># if it&#39;s None, we&#39;ll just make it be the identity function</span>
    <span class="k">if</span> <span class="n">kwargs_trans</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kwargs_trans</span> <span class="o">=</span> <span class="n">identity</span>

    <span class="c1"># default to inner_sig = outer_sig</span>
    <span class="k">if</span> <span class="n">outer_sig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">outer_sig</span> <span class="o">=</span> <span class="n">inner_sig</span>  <span class="c1"># if nothing specified, want same outer and inner sigs</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outer_sig</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
        <span class="n">changes_for_name</span> <span class="o">=</span> <span class="n">outer_sig</span>  <span class="c1"># it&#39;s a dict of modifications of the inner sig</span>
        <span class="n">outer_sig</span> <span class="o">=</span> <span class="n">inner_sig</span><span class="o">.</span><span class="n">modified</span><span class="p">(</span>
            <span class="n">_allow_reordering</span><span class="o">=</span><span class="n">_allow_reordering</span><span class="p">,</span> <span class="o">**</span><span class="n">changes_for_name</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">outer_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">outer_sig</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">inner_sig</span><span class="p">,</span> <span class="n">kwargs_trans</span><span class="p">,</span> <span class="n">outer_sig</span>


<div class="viewcode-block" id="InnerMapIngress"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.InnerMapIngress">[docs]</a><span class="k">class</span> <span class="nc">InnerMapIngress</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A class to help build ingresses systematically by mapping the inner signature.</span>

<span class="sd">    *Systematically*, i.e. &quot;according to a fixed plan/system&quot; is what it&#39;s about</span>
<span class="sd">    here. As we&#39;ll see below, if you need to write a particular adapter for a</span>
<span class="sd">    specific</span>

<span class="sd">    :param inner_sig: The signature of the wrapped function.</span>
<span class="sd">    :param _allow_reordering: Whether we want to allow reordering of variables</span>
<span class="sd">    :param in_to_out_sig_changes: The `inner_name=dict_of_changes_for_that_name`</span>
<span class="sd">    pairs, the `dict_of_changes_for_that_name` is a `dict` with keys being valid</span>
<span class="sd">    `inspect.Parameter`</span>

<span class="sd">    Consider the following function that has a position only, a keyword only,</span>
<span class="sd">    two arguments with annotations, and three with a default.</span>

<span class="sd">    &gt;&gt;&gt; def f(w, /, x: float = 1, y=2, *, z: int = 3):</span>
<span class="sd">    ...     return w + x * y ** z</span>

<span class="sd">    Say we wanted a version of this function</span>

<span class="sd">    - that didn&#39;t have the argument kind restrinctions (all POSITION_OR_KEYWORD),</span>

<span class="sd">    - where the annotation of ``x`` was changed ``int`` and the default removed</span>

<span class="sd">    - where `y` was named `you` instead, and has an annotation (`int`).</span>

<span class="sd">    - where the default of ``z`` was ``10`` instead of ``3``, and doesn&#39;t have an</span>
<span class="sd">    annotation.</span>

<span class="sd">    In order to get a version of this function we wanted (more lenient kinds,</span>
<span class="sd">    with some annotations and a default change), we can use the ingress function:</span>

<span class="sd">    &gt;&gt;&gt; def directly_defined_ingress(w, x: int, you: int=2, z = 10):</span>
<span class="sd">    ...     return (w,), dict(x=x, y=you, z=z)</span>


<span class="sd">    When we need to wrap a specific function in a specific way, defining an</span>
<span class="sd">    ingress</span>
<span class="sd">    function  this way is usually the simplest way.</span>
<span class="sd">    But in some cases we need to build the ingress function using some predefined</span>
<span class="sd">    rule/protocol to make applying rule/protocol systematic.</span>

<span class="sd">    For those cases, ``InnerMapIngress`` comes in handy.</span>

<span class="sd">    With `InnerMapIngress` we&#39;d build our ingress function like this:</span>

<span class="sd">    &gt;&gt;&gt; from inspect import Parameter, signature</span>
<span class="sd">    &gt;&gt;&gt; PK = Parameter.POSITIONAL_OR_KEYWORD</span>
<span class="sd">    &gt;&gt;&gt; empty = Parameter.empty</span>
<span class="sd">    &gt;&gt;&gt; ingress = InnerMapIngress(</span>
<span class="sd">    ...     f,</span>
<span class="sd">    ...     # change kind to PK:</span>
<span class="sd">    ...     w=dict(kind=PK),</span>
<span class="sd">    ...     # change annotation of x from float to int and remove default</span>
<span class="sd">    ...     x=dict(annotation=int, default=empty),</span>
<span class="sd">    ...     # rename y to you and add annotation int:</span>
<span class="sd">    ...     y=dict(name=&#39;you&#39;, annotation=int),</span>
<span class="sd">    ...     # change kind to PK, default to 10, and remove annotation:</span>
<span class="sd">    ...     z=dict(kind=PK, default=10, annotation=empty),</span>
<span class="sd">    ... )</span>

<span class="sd">    Note:</span>

<span class="sd">    - Only the changes we wish to make to the parameters are mentioned.</span>
<span class="sd">    You could also define the parameters explicitly by simply listing all three</span>
<span class="sd">    of the dimensions (kind, annotation, and default)</span>

<span class="sd">    - Three? But a `Parameter` object has four; what about the name?</span>
<span class="sd">    Indeed, you can use name as well, more on that later.</span>

<span class="sd">    - Note that in order to specify that you want no default, or no annotation,</span>
<span class="sd">    you cannot use `None` since `None` is both a valid default and a valid</span>
<span class="sd">    annotation; So instead you need to use `Parameter.empty` (conveniently</span>
<span class="sd">    assigned</span>
<span class="sd">    to a constant named `empty` in the `wrapping` module.</span>

<span class="sd">    Now see that all arguments are `POSITIONAL_OR_KEYWORD`, `x` and `y` are</span>
<span class="sd">    `int`,</span>
<span class="sd">    and default of `z` is 10:</span>

<span class="sd">    &gt;&gt;&gt; assert (</span>
<span class="sd">    ...     str(signature(ingress))</span>
<span class="sd">    ...     == str(signature(directly_defined_ingress))</span>
<span class="sd">    ...     == &#39;(w, x: int, you: int = 2, z=10)&#39;</span>
<span class="sd">    ... )</span>

<span class="sd">    Additionally, `ingress` function does it&#39;s job of dispatching the right args</span>
<span class="sd">    and kwargs to the target function:</span>

<span class="sd">    &gt;&gt;&gt; assert (</span>
<span class="sd">    ...     ingress(0,1,2,3)</span>
<span class="sd">    ...     == directly_defined_ingress(0,1,2,3)</span>
<span class="sd">    ...     == ((0,), {&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;z&#39;: 3})</span>
<span class="sd">    ... )</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inner_sig</span><span class="p">,</span>
        <span class="n">kwargs_trans</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">_allow_reordering</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">changes_for_name</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inner_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">inner_sig</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">outer_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner_sig</span><span class="o">.</span><span class="n">modified</span><span class="p">(</span>
            <span class="n">_allow_reordering</span><span class="o">=</span><span class="n">_allow_reordering</span><span class="p">,</span> <span class="o">**</span><span class="n">changes_for_name</span>
        <span class="p">)</span>

        <span class="c1"># kwargs_trans should be callable and have one required arg: a dict</span>
        <span class="c1"># if it&#39;s None, we&#39;ll just make it be the identity function</span>
        <span class="k">if</span> <span class="n">kwargs_trans</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs_trans</span> <span class="o">=</span> <span class="n">identity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs_trans</span> <span class="o">=</span> <span class="n">kwargs_trans</span>

        <span class="n">outer_name_for_inner_name</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">inner_name</span><span class="p">:</span> <span class="n">change</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">inner_name</span><span class="p">,</span> <span class="n">change</span> <span class="ow">in</span> <span class="n">changes_for_name</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="s1">&#39;name&#39;</span> <span class="ow">in</span> <span class="n">change</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inner_name_for_outer_name</span> <span class="o">=</span> <span class="n">invert_map</span><span class="p">(</span><span class="n">outer_name_for_inner_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outer_sig</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">ingress_args</span><span class="p">,</span> <span class="o">**</span><span class="n">ingress_kwargs</span><span class="p">):</span>
        <span class="c1"># Get the all-keywords version of the arguments (args,kwargs-&gt;kwargs)</span>
        <span class="n">func_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outer_sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
            <span class="n">ingress_args</span><span class="p">,</span> <span class="n">ingress_kwargs</span><span class="p">,</span> <span class="n">apply_defaults</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># Modify the keys of func_kwargs so they reflect the inner signature&#39;s names</span>
        <span class="c1"># That is, map outer names to inner names.</span>
        <span class="n">func_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">items_with_mapped_keys</span><span class="p">(</span><span class="n">func_kwargs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner_name_for_outer_name</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">func_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">func_kwargs</span><span class="p">,</span>  <span class="c1"># by default, keep the func_kwargs, but</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs_trans</span><span class="p">(</span><span class="n">func_kwargs</span><span class="p">),</span>  <span class="c1"># change those that kwargs_trans desires</span>
        <span class="p">)</span>

        <span class="c1"># Return an (args,kwargs) pair the respects the inner function&#39;s</span>
        <span class="c1"># argument kind restrictions.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner_sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="n">func_kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="InnerMapIngress.from_signature"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.InnerMapIngress.from_signature">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_signature</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">inner_sig</span><span class="p">,</span> <span class="n">outer_sig</span><span class="p">,</span> <span class="n">_allow_reordering</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param inner_sig:</span>
<span class="sd">        :param outer_sig:</span>
<span class="sd">        :param _allow_reordering:</span>
<span class="sd">        :return:</span>

<span class="sd">        Say we wanted to get a version of the function:</span>

<span class="sd">        &gt;&gt;&gt; def f(w, /, x: float = 1, y=2, *, z: int = 3):</span>
<span class="sd">        ...     return w + x * y ** z</span>

<span class="sd">        That was equivalent to (note the kind, default and annotation differences):</span>

<span class="sd">        &gt;&gt;&gt; def g(w, x=1, y=2, z=10):</span>
<span class="sd">        ...     return w + x * y ** z</span>


<span class="sd">        &gt;&gt;&gt; ingress = InnerMapIngress.from_signature(</span>
<span class="sd">        ... f, outer_sig=lambda w, x=1, y=2, z=10: None</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; Sig(ingress)</span>
<span class="sd">        &lt;Sig (w, x=1, y=2, z=10)&gt;</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; h = wrap(f, ingress=InnerMapIngress.from_signature(f, g))</span>
<span class="sd">        &gt;&gt;&gt; assert h(0) == g(0) == 1024 == 0 + 1 * 2 ** 10</span>
<span class="sd">        &gt;&gt;&gt; assert h(1,2) == g(1,2) == 2049 == 1 + 2 * 2 ** 10</span>
<span class="sd">        &gt;&gt;&gt; assert h(1,2,3,4) == g(1,2,3,4) == 1 + 2 * 3 ** 4</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; assert h(w=1,x=2,y=3,z=4) == g(1,2,3,4) == 1 + 2 * 3 ** 4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">outer_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">outer_sig</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">inner_sig</span><span class="p">,</span>
            <span class="n">_allow_reordering</span><span class="o">=</span><span class="n">_allow_reordering</span><span class="p">,</span>
            <span class="o">**</span><span class="n">parameters_to_dict</span><span class="p">(</span><span class="n">outer_sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">),</span>
        <span class="p">)</span></div></div>


<span class="c1"># TODO: Fits global pattern -- merge</span>
<span class="k">class</span> <span class="nc">ArgNameMappingIngress</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inner_sig</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">conserve_kind</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">outer_name_for_inner_name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inner_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">inner_sig</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outer_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner_sig</span><span class="o">.</span><span class="n">ch_names</span><span class="p">(</span><span class="o">**</span><span class="n">outer_name_for_inner_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">conserve_kind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outer_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outer_sig</span><span class="o">.</span><span class="n">ch_kinds_to_position_or_keyword</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inner_name_for_outer_name</span> <span class="o">=</span> <span class="n">invert_map</span><span class="p">(</span><span class="n">outer_name_for_inner_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outer_sig</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">ingress_args</span><span class="p">,</span> <span class="o">**</span><span class="n">ingress_kwargs</span><span class="p">):</span>
        <span class="c1"># Get the all-keywords version of the arguments (args,kwargs-&gt;kwargs)</span>
        <span class="n">func_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outer_sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
            <span class="n">ingress_args</span><span class="p">,</span> <span class="n">ingress_kwargs</span>
        <span class="p">)</span>
        <span class="c1"># Modify the keys of func_kwargs so they reflect the inner signature&#39;s names</span>
        <span class="c1"># That is, map outer names to inner names.</span>
        <span class="n">func_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">items_with_mapped_keys</span><span class="p">(</span><span class="n">func_kwargs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner_name_for_outer_name</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Return an (args,kwargs) pair the respects the inner function&#39;s</span>
        <span class="c1"># argument kind restrictions.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner_sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="n">func_kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">mk_ingress_from_name_mapper</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">name_mapper</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">conserve_kind</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ArgNameMappingIngress</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">conserve_kind</span><span class="o">=</span><span class="n">conserve_kind</span><span class="p">,</span> <span class="o">**</span><span class="n">name_mapper</span><span class="p">)</span>


<div class="viewcode-block" id="nice_kinds"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.nice_kinds">[docs]</a><span class="k">def</span> <span class="nf">nice_kinds</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wraps the func so it will only have POSITIONAL_OR_KEYWORD argument kinds.</span>

<span class="sd">    The original purpose of this function is to remove argument-kind restriction</span>
<span class="sd">    annoyances when doing functional manipulations such as:</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; isinstance_of_str = partial(isinstance, class_or_tuple=str)</span>
<span class="sd">    &gt;&gt;&gt; isinstance_of_str(&#39;I am a string&#39;)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    TypeError: isinstance() takes no keyword arguments</span>

<span class="sd">    Here, instead, we can just get a kinder version of the function and do what we</span>
<span class="sd">    want to do:</span>

<span class="sd">    &gt;&gt;&gt; _isinstance = nice_kinds(isinstance)</span>
<span class="sd">    &gt;&gt;&gt; isinstance_of_str = partial(_isinstance, class_or_tuple=str)</span>
<span class="sd">    &gt;&gt;&gt; isinstance_of_str(&#39;I am a string&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; isinstance_of_str(42)</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">i2</span> <span class="kn">import</span> <span class="n">Sig</span><span class="p">,</span> <span class="n">call_somewhat_forgivingly</span>

    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">ch_kinds</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">Sig</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">names</span><span class="p">})</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">call_somewhat_forgivingly</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">enforce_sig</span><span class="o">=</span><span class="n">sig</span><span class="p">)</span>

    <span class="n">_func</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">sig</span>
    <span class="k">return</span> <span class="n">_func</span></div>


<span class="c1"># ---------------------------------------------------------------------------------------</span>
<span class="c1"># wrap tools</span>


<span class="k">def</span> <span class="nf">arg_val_converter</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">conversion_for_arg</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Wrap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">ingress</span><span class="o">=</span><span class="n">ArgValConverterIngress</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">conversion_for_arg</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">arg_val_converter_ingress</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">__strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">conversion_for_arg</span><span class="p">):</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">__strict</span><span class="p">:</span>
        <span class="n">conversion_names_that_are_not_func_args</span> <span class="o">=</span> <span class="n">conversion_for_arg</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="n">sig</span><span class="o">.</span><span class="n">names</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">conversion_names_that_are_not_func_args</span><span class="p">,</span> <span class="p">(</span>
            <span class="s1">&#39;Some of the arguments you want to convert are not argument names &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;for the function: </span><span class="si">{</span><span class="n">conversion_names_that_are_not_func_args</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">)</span>

    <span class="nd">@sig</span>
    <span class="k">def</span> <span class="nf">ingress</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># TODO: Make a helper function for this ak -&gt; k -&gt; proc -&gt; ak pattern</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">convert_dict_values</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">conversion_for_arg</span><span class="p">))</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="k">return</span> <span class="n">ingress</span>


<span class="c1"># TODO: Fits global pattern -- merge</span>
<span class="k">class</span> <span class="nc">ArgValConverterIngress</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">__strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">conversion_for_arg</span><span class="p">):</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">__strict</span><span class="p">:</span>
            <span class="n">conversion_names_that_are_not_func_args</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">conversion_for_arg</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="n">sig</span><span class="o">.</span><span class="n">names</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">conversion_names_that_are_not_func_args</span><span class="p">,</span> <span class="p">(</span>
                <span class="s1">&#39;Some of the arguments you want to convert are not argument names &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;for the function: </span><span class="si">{</span><span class="n">conversion_names_that_are_not_func_args</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conversion_for_arg</span> <span class="o">=</span> <span class="n">conversion_for_arg</span>
        <span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># TODO: Make a helper function for this ak -&gt; k -&gt; proc -&gt; ak pattern</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">convert_dict_values</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">conversion_for_arg</span><span class="p">))</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span>


<span class="k">def</span> <span class="nf">convert_dict_values</span><span class="p">(</span><span class="n">to_convert</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">key_to_conversion_function</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">to_convert</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">key_to_conversion_function</span><span class="p">:</span>
            <span class="n">conversion_func</span> <span class="o">=</span> <span class="n">key_to_conversion_function</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">conversion_func</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  <span class="c1"># converted kv pair</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>  <span class="c1"># unconverted kv pair</span>


<span class="c1"># TODO: Test for performance an ask about readability</span>
<span class="k">def</span> <span class="nf">_alt_convert_dict_values</span><span class="p">(</span><span class="n">to_convert</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">key_to_conversion_function</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">to_convert</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">conversion_func</span> <span class="o">=</span> <span class="n">key_to_conversion_function</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">conversion_func</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright OtoSense 2020.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
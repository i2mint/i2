<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>i2.wrapper &mdash; i2 0.0.143 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/toggleprompt.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> i2
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2.html">i2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/_deprecated.html">i2._deprecated</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/base.html">i2.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/chain_map.html">i2.chain_map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/deco.html">i2.deco</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/doc_mint.html">i2.doc_mint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/errors.html">i2.errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/examples.html">i2.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/examples/signature_calculus.html">i2.examples.signature_calculus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/footprints.html">i2.footprints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/io_trans.html">i2.io_trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/itypes.html">i2.itypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/key_path.html">i2.key_path</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/multi_object.html">i2.multi_object</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/routing_forest.html">i2.routing_forest</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/scrap.html">i2.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/scrap/scrap.html">i2.scrap.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/scrap/scrap_ch_variadics.html">i2.scrap.scrap_ch_variadics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/scrap/scrap_kwargs.html">i2.scrap.scrap_kwargs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/scrap/simple_pymint.html">i2.scrap.simple_pymint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/signatures.html">i2.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/switch_case_tree.html">i2.switch_case_tree</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests.html">i2.tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/footprints_test.html">i2.tests.footprints_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/objects_for_testing.html">i2.tests.objects_for_testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/signatures_test.html">i2.tests.signatures_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/test_util.html">i2.tests.test_util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/util.html">i2.tests.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/wrapper_test.html">i2.tests.wrapper_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/util.html">i2.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/wrapper.html">i2.wrapper</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">i2</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>i2.wrapper</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for i2.wrapper</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;A wrapper object and tools to work with it</span>

<span class="sd">How the ``Wrap`` class works:</span>

<span class="sd">.. code-block::</span>

<span class="sd">          *outer_args, **outer_kwargs</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">    ┌───────────────────────────────────┐</span>
<span class="sd">    │              ingress              │</span>
<span class="sd">    └───────────────────────────────────┘</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">          *inner_args, **inner_kwargs</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">    ┌───────────────────────────────────┐</span>
<span class="sd">    │               func                │</span>
<span class="sd">    └───────────────────────────────────┘</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">                 func_output</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">    ┌───────────────────────────────────┐</span>
<span class="sd">    │              egress               │</span>
<span class="sd">    └───────────────────────────────────┘</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">                final_output</span>


<span class="sd">How the ``Ingress`` class (ingress templated function maker) works:</span>

<span class="sd">.. code-block::</span>

<span class="sd">          *outer_args, **outer_kwargs</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">    ┌───────────────────────────────────┐</span>
<span class="sd">    │          outer_sig_bind           │</span>
<span class="sd">    └───────────────────────────────────┘</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">              outer_all_kwargs</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">    ┌───────────────────────────────────┐</span>
<span class="sd">    │            kwargs_trans           │</span>
<span class="sd">    └───────────────────────────────────┘</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">              inner_all_kwargs</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">    ┌───────────────────────────────────┐</span>
<span class="sd">    │          inner_sig_bind           │</span>
<span class="sd">    └───────────────────────────────────┘</span>
<span class="sd">                     │</span>
<span class="sd">                     ▼</span>
<span class="sd">          *inner_args, **inner_kwargs</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span><span class="p">,</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">signature</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">NewType</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">MethodType</span>

<span class="kn">from</span> <span class="nn">i2.signatures</span> <span class="kn">import</span> <span class="n">Sig</span><span class="p">,</span> <span class="n">name_of_obj</span><span class="p">,</span> <span class="n">KO</span><span class="p">,</span> <span class="n">PK</span><span class="p">,</span> <span class="n">VK</span>
<span class="kn">from</span> <span class="nn">i2.multi_object</span> <span class="kn">import</span> <span class="n">Pipe</span>
<span class="kn">from</span> <span class="nn">i2.deco</span> <span class="kn">import</span> <span class="n">double_up_as_factory</span>

<span class="c1"># ---------------------------------------------------------------------------------------</span>
<span class="c1"># Wrap</span>

<span class="n">empty</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span>
<span class="n">OuterKwargs</span> <span class="o">=</span> <span class="nb">dict</span>
<span class="n">InnerKwargs</span> <span class="o">=</span> <span class="nb">dict</span>
<span class="n">KwargsTrans</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">OuterKwargs</span><span class="p">],</span> <span class="n">InnerKwargs</span><span class="p">]</span>


<div class="viewcode-block" id="identity"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.identity">[docs]</a><span class="k">def</span> <span class="nf">identity</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transparent function, returning what&#39;s been input&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="transparent_ingress"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.transparent_ingress">[docs]</a><span class="k">def</span> <span class="nf">transparent_ingress</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; transparent_ingress(1, 2, test=1)</span>
<span class="sd">    ((1, 2), {&#39;test&#39;: 1})</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span></div>


<div class="viewcode-block" id="transparent_egress"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.transparent_egress">[docs]</a><span class="k">def</span> <span class="nf">transparent_egress</span><span class="p">(</span><span class="n">output</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; transparent_egress(&#39;unnecessary_doctest&#39;)</span>
<span class="sd">    &#39;unnecessary_doctest&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="MakeFromFunc"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.MakeFromFunc">[docs]</a><span class="k">class</span> <span class="nc">MakeFromFunc</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Used to indicate that an object should be made as a function of an input func&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func_to_obj</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_to_obj</span> <span class="o">=</span> <span class="n">func_to_obj</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_to_obj</span><span class="p">(</span><span class="n">func</span><span class="p">)</span></div>


<span class="c1"># from wrapt import decorator</span>
<span class="c1"># TODO: Continue factoring out Wrap and Wrapx code</span>
<span class="k">class</span> <span class="nc">_Wrap</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;To be used as the base of actual Wrap objects.&quot;&quot;&quot;</span>

    <span class="n">_init_args</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">_init_kwargs</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_args</span> <span class="o">=</span> <span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="c1"># wraps(func)(self) is there to copy over to self anything that func may</span>
        <span class="c1"># have had. It should be before anything else so it doesn&#39;t overwrite stuff</span>
        <span class="c1"># that we may add to self in init (like .func for example!)</span>
        <span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># TODO: should we really copy everything by default?</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">:=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>  <span class="c1"># Note: overwrites self.func that wraps MAY have inserted</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__wrapped__</span> <span class="o">=</span> <span class="n">func</span>
        <span class="c1"># TODO: Pros and cons analysis of pointing __wrapped__ to func. partial uses</span>
        <span class="c1">#  .func, but wraps looks for __wrapped__</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Just forward the call to the wrapped function.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;reduce is meant to control how things are pickled/unpickled&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_args</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_init_kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method allows things to work well when we use Wrap object as method&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">MethodType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: Replace i2.Wrap with dynamic (Wrap or Wrapx)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;Wrap&#39;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&lt;i2.Wrap </span><span class="si">{</span><span class="n">name</span><span class="si">}{</span><span class="n">signature</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s1">&gt;&#39;</span>

    <span class="c1"># TODO: Don&#39;t know exactly what I&#39;m doing below. Review with someone!</span>
    <span class="k">def</span> <span class="nf">__set_name__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;So that name of function is passed on to method when assigning to attribute</span>
<span class="sd">        That is, doing ``method = Wrap(func)`` in a class definition&quot;&quot;&quot;</span>
        <span class="c1"># TODO: Look into sanity of mutating the name and other ways to achieve same</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span>

    <span class="k">def</span> <span class="fm">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">instance</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1"># To get help(instance.method) to work!</span>
    <span class="c1"># TODO: Does this have undesirable side effects?</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">__code__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="vm">__code__</span>


<div class="viewcode-block" id="Wrap"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.Wrap">[docs]</a><span class="k">class</span> <span class="nc">Wrap</span><span class="p">(</span><span class="n">_Wrap</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A function wrapper with interface modifiers.</span>

<span class="sd">    :param func: The wrapped function</span>
<span class="sd">    :param ingress: The incoming data transformer. It determines the argument properties</span>
<span class="sd">        (name, kind, default and annotation) as well as the actual input of the</span>
<span class="sd">        wrapped function.</span>
<span class="sd">    :param egress: The outgoing data transformer. It also takes precedence over the</span>
<span class="sd">        wrapped function to determine the return annotation of the ``Wrap`` instance</span>
<span class="sd">    :param name: Name to give the wrapper (will use wrapped func name by default)</span>
<span class="sd">    :return: A callable instance wrapping ``func``</span>

<span class="sd">    Some examples:</span>

<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; from i2 import Sig</span>

<span class="sd">    &gt;&gt;&gt; def func(a, b):</span>
<span class="sd">    ...     return a * b</span>

<span class="sd">    &gt;&gt;&gt; wrapped_func = wrap(func)  # no transformations: wrapped_func is the same as func</span>
<span class="sd">    &gt;&gt;&gt; assert wrapped_func(2, &#39;Hi&#39;) == func(2, &#39;Hi&#39;) == &#39;HiHi&#39;</span>

<span class="sd">    Modifying the first argument</span>

<span class="sd">    &gt;&gt;&gt; def ingress(a, b):</span>
<span class="sd">    ...   return (2 * a, b), dict()</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func = wrap(func, ingress=ingress)  # first variable is now multiplied by 2</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func(2, &#39;Hi&#39;)</span>
<span class="sd">    &#39;HiHiHiHi&#39;</span>

<span class="sd">    Same using keyword args, we need to use tuple to represent an empty tuple</span>

<span class="sd">    &gt;&gt;&gt; def ingress(a, b):</span>
<span class="sd">    ...   return tuple(), dict(a=2 * a, b=b) # Note that b MUST be present as well, or an error will be raised</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func = wrap(func, ingress=ingress)  # first variable is now multiplied by 2</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func(2, &#39;Hi&#39;)</span>
<span class="sd">    &#39;HiHiHiHi&#39;</span>

<span class="sd">    Using both args and kwargs</span>

<span class="sd">    &gt;&gt;&gt; def ingress(a, b):</span>
<span class="sd">    ...   return (2 * a, ), dict(b=b)</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func = wrap(func, ingress=ingress)  # first variable is now multiplied by 2</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func(2, &#39;Hi&#39;)</span>
<span class="sd">    &#39;HiHiHiHi&#39;</span>

<span class="sd">    We can use ingress to ADD parameters to func</span>

<span class="sd">    &gt;&gt;&gt; def ingress(a, b, c):</span>
<span class="sd">    ...   return (a, b + c), dict()</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func = wrap(func, ingress=ingress)</span>
<span class="sd">    &gt;&gt;&gt; # now wrapped_func takes three arguments</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func(2, &#39;Hi&#39;, &#39;world!&#39;)</span>
<span class="sd">    &#39;Hiworld!Hiworld!&#39;</span>

<span class="sd">    Egress is a bit more straightforward, it simply applies to the output of the</span>
<span class="sd">    wrapped function. We can use ingress to ADD parameters to func</span>

<span class="sd">    &gt;&gt;&gt; def egress(output):</span>
<span class="sd">    ...   return output + &#39; ITSME!!!&#39;</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func = wrap(func, ingress=ingress, egress=egress)</span>
<span class="sd">    &gt;&gt;&gt; # now wrapped_func takes three arguments</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func(2, &#39;Hi&#39;, &#39;world!&#39;)</span>
<span class="sd">    &#39;Hiworld!Hiworld! ITSME!!!&#39;</span>


<span class="sd">    A more involved example:</span>

<span class="sd">    &gt;&gt;&gt; def ingress(a, b: str, c=&quot;hi&quot;):</span>
<span class="sd">    ...     return (a + len(b) % 2,), dict(string=f&quot;{c} {b}&quot;)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; def func(times, string):</span>
<span class="sd">    ...     return times * string</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func = wrap(func, ingress=ingress)</span>
<span class="sd">    &gt;&gt;&gt; assert wrapped_func(2, &quot;world! &quot;, &quot;Hi&quot;) == &quot;Hi world! Hi world! Hi world! &quot;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func = wrap(func, egress=len)</span>
<span class="sd">    &gt;&gt;&gt; assert wrapped_func(2, &quot;co&quot;) == 4 == len(&quot;coco&quot;) == len(func(2, &quot;co&quot;))</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; wrapped_func = wrap(func, ingress=ingress, egress=len)</span>
<span class="sd">    &gt;&gt;&gt; assert (</span>
<span class="sd">    ...     wrapped_func(2, &quot;world! &quot;, &quot;Hi&quot;)</span>
<span class="sd">    ...     == 30</span>
<span class="sd">    ...     == len(&quot;Hi world! Hi world! Hi world! &quot;)</span>
<span class="sd">    ... )</span>

<span class="sd">    An ingress function links the interface of the wrapper to the interface of the</span>
<span class="sd">    wrapped func; therefore it&#39;s definition often depends on information of both,</span>
<span class="sd">    and for that reason, we provide the ability to specify the ingress not only</span>
<span class="sd">    explicitly (as in the examples above), but through a factory -- a function that</span>
<span class="sd">    will be called on `func` to produce the ingress that should be used to wrap it.</span>



<span class="sd">    .. seealso::</span>

<span class="sd">        ``wrap`` function.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">ingress</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">egress</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">ingress</span><span class="p">,</span> <span class="n">egress</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="n">ingress_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ingress</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ingress</span> <span class="o">=</span> <span class="n">transparent_ingress</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ingress</span><span class="p">,</span> <span class="n">MakeFromFunc</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ingress</span> <span class="o">=</span> <span class="n">ingress</span>  <span class="c1"># the ingress function is</span>
                <span class="n">func_to_ingress</span> <span class="o">=</span> <span class="n">ingress</span>  <span class="c1"># it&#39;s not the ingress function itself</span>
                <span class="c1"># ... but an ingress factory: Should make the ingress in function of func</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ingress</span> <span class="o">=</span> <span class="n">func_to_ingress</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">ingress</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;Should be callable: </span><span class="si">{</span><span class="n">ingress</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ingress</span> <span class="o">=</span> <span class="n">ingress</span>
            <span class="n">ingress_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ingress</span><span class="p">)</span>

        <span class="n">return_annotation</span> <span class="o">=</span> <span class="n">empty</span>

        <span class="k">if</span> <span class="n">egress</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">egress</span> <span class="o">=</span> <span class="n">transparent_egress</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">egress</span> <span class="o">=</span> <span class="n">egress</span>
            <span class="n">egress_return_annotation</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">egress</span><span class="p">)</span><span class="o">.</span><span class="n">return_annotation</span>
            <span class="k">if</span> <span class="n">egress_return_annotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">return_annotation</span> <span class="o">=</span> <span class="n">egress_return_annotation</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">ingress_sig</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">return_annotation</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">ingress_args</span><span class="p">,</span> <span class="o">**</span><span class="n">ingress_kwargs</span><span class="p">):</span>
        <span class="n">func_args</span><span class="p">,</span> <span class="n">func_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ingress</span><span class="p">(</span><span class="o">*</span><span class="n">ingress_args</span><span class="p">,</span> <span class="o">**</span><span class="n">ingress_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">egress</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">func_args</span><span class="p">,</span> <span class="o">**</span><span class="n">func_kwargs</span><span class="p">))</span></div>


<span class="nd">@double_up_as_factory</span>
<span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span>
    <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ingress</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">egress</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">caller</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dflt_wrap</span><span class="o">=</span><span class="n">Wrap</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrap a function, optionally transforming interface, input and output.</span>

<span class="sd">    :param func: The wrapped function</span>
<span class="sd">    :param ingress: The incoming data transformer. It determines the argument properties</span>
<span class="sd">        (name, kind, default and annotation) as well as the actual input of the</span>
<span class="sd">        wrapped function.</span>
<span class="sd">    :param egress: The outgoing data transformer. It also takes precedence over the</span>
<span class="sd">        wrapped function to determine the return annotation of the ``Wrap`` instance</span>
<span class="sd">    :return: A callable instance wrapping ``func``</span>

<span class="sd">    Consider the following function.</span>

<span class="sd">    &gt;&gt;&gt; def f(w, /, x: float = 1, y=2, *, z: int = 3):</span>
<span class="sd">    ...     return w + x * y ** z</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; assert f(0) == 8</span>
<span class="sd">    &gt;&gt;&gt; assert f(1,2) == 17 == 1 + 2 * 2 ** 3</span>

<span class="sd">    See that ``f`` is restricted to use ``z`` as keyword only argument kind:</span>

<span class="sd">    &gt;&gt;&gt; f(1, 2, 3, 4)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    TypeError: f() takes from 1 to 3 positional arguments but 4 were given</span>

<span class="sd">    and ``w`` has position only argument kind:</span>

<span class="sd">    &gt;&gt;&gt; f(w=1, x=2, y=3, z=4)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    TypeError: f() got some positional-only arguments passed as keyword arguments: &#39;w&#39;</span>

<span class="sd">    Say we wanted a version of this function that didn&#39;t have the argument kind</span>
<span class="sd">    restrinctions, where the annotation of ``x`` was ``int`` and where the default</span>
<span class="sd">    of ``z`` was ``10`` instead of ``3``, and doesn&#39;t have an annotation.</span>
<span class="sd">    We can do so using the following ingress function:</span>

<span class="sd">    &gt;&gt;&gt; def ingress(w, x: int = 1, y: int=2, z = 10):</span>
<span class="sd">    ...     return (w,), dict(x=x, y=y, z=z)</span>

<span class="sd">    The ingress function serves two purposes:</span>

<span class="sd">    - Redefining the signature (i.e. the argument names, kinds, defaults,</span>
<span class="sd">    and annotations (not including the return annotation, which is taken care of by the</span>
<span class="sd">    egress argument).</span>

<span class="sd">    - Telling the wrapper how to get from that interface to the interface of the</span>
<span class="sd">    wrapped function.</span>

<span class="sd">    If we also wanted to add a return_annotation, we could do so via an ``egress``</span>
<span class="sd">    function argument:</span>

<span class="sd">    &gt;&gt;&gt; def egress(wrapped_func_output) -&gt; float:</span>
<span class="sd">    ...     return wrapped_func_output  # because here we don&#39;t want to do anything extra</span>

<span class="sd">    Now we can use these ingress and egress functions to get the version of ``f`` of</span>
<span class="sd">    our dreams:</span>

<span class="sd">    &gt;&gt;&gt; h = wrap(f, ingress=ingress, egress=egress)</span>

<span class="sd">    Let&#39;s see what the signature of our new function looks like:</span>

<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; str(signature(h))</span>
<span class="sd">    &#39;(w, x: int = 1, y: int = 2, z=10) -&gt; float&#39;</span>

<span class="sd">    Now let&#39;s see that we can actually use this new function ``h``, without the</span>
<span class="sd">    restrictions of argument kind, getting the same results as the wrapped ``f``,</span>
<span class="sd">    but with default ``z=10``.</span>

<span class="sd">    What we wanted (but couldn&#39;t) do with ``f``:</span>

<span class="sd">    &gt;&gt;&gt; h(1, 2, 3, 4)  # == 1 + 2 * 3 ** 4</span>
<span class="sd">    163</span>
<span class="sd">    &gt;&gt;&gt; h(w=1, x=2, y=3, z=4)</span>
<span class="sd">    163</span>

<span class="sd">    &gt;&gt;&gt; assert h(0) == h(0, 1) == h(0, 1, 2) == 0 + 1 * 2 ** 10 == 2 ** 10 == 1024</span>

<span class="sd">    Note that ``wrap`` can also be used as a decorator &quot;factory&quot;, for instance to</span>
<span class="sd">    wrap functions at definition time, and if we change ``caller`` it will automatically</span>
<span class="sd">    use ``Wrapx`` instead of ``Wrap`` to wrap the function.</span>

<span class="sd">    &gt;&gt;&gt; def iterize(func, args, kwargs):</span>
<span class="sd">    ...     first_arg_val = next(iter(kwargs.values()))</span>
<span class="sd">    ...     return list(map(func, first_arg_val))</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; @wrap(caller=iterize)</span>
<span class="sd">    ... def func(x, y=2):</span>
<span class="sd">    ...     return x + y</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; isinstance(func, Wrapx)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; func([1, 2, 3, 4])</span>
<span class="sd">    [3, 4, 5, 6]</span>

<span class="sd">    For more examples, see also the</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        ``Wrap`` class.</span>
<span class="sd">        ``Wrapx`` class.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">_should_use_wrapx</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">ingress</span><span class="p">,</span> <span class="n">egress</span><span class="p">,</span> <span class="n">caller</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Wrapx</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">ingress</span><span class="p">,</span> <span class="n">egress</span><span class="p">,</span> <span class="n">caller</span><span class="o">=</span><span class="n">caller</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dflt_wrap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">ingress</span><span class="p">,</span> <span class="n">egress</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="c1"># TODO: Add conditions on egress to route to Wrapx when complex egress</span>
<span class="k">def</span> <span class="nf">_should_use_wrapx</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">ingress</span><span class="p">,</span> <span class="n">egress</span><span class="p">,</span> <span class="n">caller</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">caller</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>


<div class="viewcode-block" id="append_empty_args"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.append_empty_args">[docs]</a><span class="k">def</span> <span class="nf">append_empty_args</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;To use to transform an ingress function that only returns kwargs to one that</span>
<span class="sd">    returns the normal form of ingress functions: ((), kwargs)&quot;&quot;&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(),</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_func</span></div>


<div class="viewcode-block" id="Ingress"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.Ingress">[docs]</a><span class="k">class</span> <span class="nc">Ingress</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;The Ingress class offers a template for creating ingress classes.</span>

<span class="sd">    Note that when writing a decorator with i2.wrapper, you&#39;re usually better off</span>
<span class="sd">    writing an ingress function for the purpose. As a result, your code will usually</span>
<span class="sd">    be less complex, easier to read, and more efficient than using the Ingress class.</span>

<span class="sd">    So why use the Ingress class at all? For one, because it&#39;ll take care of some common</span>
<span class="sd">    mechanics for you, so once you understand how to use it,</span>
<span class="sd">    you&#39;ll probably create a correct wrapper faster.</span>

<span class="sd">    Further, if you&#39;re writing a general wrapping tool (e.g. your own currying machine,</span>
<span class="sd">    some rule-based input casting function, etc.) then you&#39;ll find that using</span>
<span class="sd">    Ingres will usually with on the complexity, readability and/or efficiency front.</span>

<span class="sd">    &gt;&gt;&gt; from i2.wrapper import Ingress, wrap</span>
<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; from i2.wrapper import InnerMapIngress</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Ingress = InnerMapIngress</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; def f(w, /, x: float, y=2, *, z: int = 3):</span>
<span class="sd">    ...     return f&quot;(w:={w}) + (x:={x}) * (y:={y}) ** (z:={z}) == {w + x * y ** z}&quot;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; f(0, 1)</span>
<span class="sd">    &#39;(w:=0) + (x:=1) * (y:=2) ** (z:=3) == 8&#39;</span>

<span class="sd">    Let’s say you wanted to dispatch this function to a command line interface,</span>
<span class="sd">    or a webservice where all arguments are taken from the url.</span>
<span class="sd">    The problem here is that this means that all incoming values will be strings</span>
<span class="sd">    in that case.</span>
<span class="sd">    Say you wanted all input values to be cast to ints. In that case you could do:</span>

<span class="sd">    &gt;&gt;&gt; trans_all_vals_to_ints = lambda d: {k: int(v) for k, v in d.items()}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; cli_f = wrap(</span>
<span class="sd">    ...     f,</span>
<span class="sd">    ...     ingress=Ingress(signature(f), kwargs_trans=trans_all_vals_to_ints)</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; cli_f(&quot;2&quot;, &quot;3&quot;, &quot;4&quot;)</span>
<span class="sd">    &#39;(w:=2) + (x:=3) * (y:=4) ** (z:=3) == 194&#39;</span>

<span class="sd">    In a more realistic situation, you&#39;d want to have more control over this value</span>
<span class="sd">    transformation.</span>

<span class="sd">    Say you wanted to convert to int if it&#39;s possible, try float if not,</span>
<span class="sd">    and just leave the string alone otherwise.</span>

<span class="sd">    &gt;&gt;&gt; def _try_casting_to_numeric(x):</span>
<span class="sd">    ...     try:</span>
<span class="sd">    ...         return int(x)</span>
<span class="sd">    ...     except ValueError:</span>
<span class="sd">    ...         try:</span>
<span class="sd">    ...             return float(x)</span>
<span class="sd">    ...         except ValueError:</span>
<span class="sd">    ...             return x</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; def cast_numbers(d: dict):</span>
<span class="sd">    ...     return {k: _try_casting_to_numeric(v) for k, v in d.items()}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; cli_f = wrap(f, ingress=Ingress(signature(f), kwargs_trans=cast_numbers))</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; cli_f(&quot;2&quot;, &quot;3.14&quot;, &quot;4&quot;)</span>
<span class="sd">    &#39;(w:=2) + (x:=3.14) * (y:=4) ** (z:=3) == 202.96&#39;</span>

<span class="sd">    Let&#39;s say that our values transformations are not all 1-to-1 as in the examples</span>
<span class="sd">    above.</span>
<span class="sd">    Instead, they can be</span>

<span class="sd">    - ``1-to-many`` (e.g. the outer &#39;w&#39; is used to compute the inner ``w`` and ``x``)</span>

<span class="sd">    - ``many-to-1 (e.g. the outer ``x`` and ``y`` are used to compute inner ``y``)</span>

<span class="sd">    .. code-block::</span>
<span class="sd">          w   x   y   z</span>
<span class="sd">         / \   \ /    |</span>
<span class="sd">        w   x   y     z</span>


<span class="sd">    &gt;&gt;&gt; def kwargs_trans(outer_kw):</span>
<span class="sd">    ...     return dict(</span>
<span class="sd">    ...         # e.g. 1-to-many: one outer arg (w) producing two inner args (w, and y)</span>
<span class="sd">    ...         w=outer_kw[&#39;w&#39;] * 2,</span>
<span class="sd">    ...         x=outer_kw[&#39;w&#39;] * 3,</span>
<span class="sd">    ...         # e.g. many-to-1: two outer args (x and y) producing one inner arg (y)</span>
<span class="sd">    ...         y=outer_kw[&#39;x&#39;] + outer_kw[&#39;y&#39;],</span>
<span class="sd">    ...         # Note that no z is mentioned: This means we&#39;re just leaving it alone</span>
<span class="sd">    ...     )</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; ingress = Ingress(signature(f), kwargs_trans=kwargs_trans)</span>
<span class="sd">    &gt;&gt;&gt; assert ingress(2, x=3, y=4) == ((4,), {&#39;x&#39;: 6, &#39;y&#39;: 7, &#39;z&#39;: 3})</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; wrapped_f = wrap(f, ingress=ingress)</span>
<span class="sd">    &gt;&gt;&gt; assert wrapped_f(2, x=3, y=4) == &#39;(w:=4) + (x:=6) * (y:=7) ** (z:=3) == 2062&#39;</span>


<span class="sd">    The following is an example that involves several aspects of the ``Ingress`` class.</span>

<span class="sd">    &gt;&gt;&gt; from i2 import Sig</span>
<span class="sd">    &gt;&gt;&gt; def kwargs_trans(outer_kw):</span>
<span class="sd">    ...     return dict(</span>
<span class="sd">    ...         w=outer_kw[&#39;w&#39;] * 2,</span>
<span class="sd">    ...         x=outer_kw[&#39;w&#39;] * 3,</span>
<span class="sd">    ...         # need to pop you (inner func has no you argument)</span>
<span class="sd">    ...         y=outer_kw[&#39;x&#39;] + outer_kw.pop(&#39;you&#39;),</span>
<span class="sd">    ...         # Note that no z is mentioned: This means we&#39;re just leaving it alone</span>
<span class="sd">    ...     )</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; ingress = Ingress(</span>
<span class="sd">    ...     inner_sig=signature(f),</span>
<span class="sd">    ...     kwargs_trans=kwargs_trans,</span>
<span class="sd">    ...     outer_sig=Sig(f).ch_names(y=&#39;you&#39;)  # need to give the outer sig a you</span>
<span class="sd">    ...     # You could also express it this way (though you&#39;d lose the annotations)</span>
<span class="sd">    ...     # outer_sig=lambda w, /, x, you=2, *, z=3: None</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; assert ingress(2, x=3, you=4) == ((4,), {&#39;x&#39;: 6, &#39;y&#39;: 7, &#39;z&#39;: 3})</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; wrapped_f = wrap(f, ingress=ingress)</span>
<span class="sd">    &gt;&gt;&gt; assert wrapped_f(2, x=3, you=4) == &#39;(w:=4) + (x:=6) * (y:=7) ** (z:=3) == 2062&#39;</span>

<span class="sd">    A convenience method allows to do the same with the ingress instance itself:</span>

<span class="sd">    &gt;&gt;&gt; wrapped_f = ingress.wrap(f)</span>
<span class="sd">    &gt;&gt;&gt; assert wrapped_f(2, x=3, you=4) == &#39;(w:=4) + (x:=6) * (y:=7) ** (z:=3) == 2062&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">inner_sig</span><span class="p">,</span> <span class="n">kwargs_trans</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">KwargsTrans</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">outer_sig</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Init of an Ingress instance.</span>

<span class="sd">        :param inner_sig: Signature of the inner function the ingress is for.</span>
<span class="sd">            The function itself can be given and the signature will be extracted.</span>
<span class="sd">        :param kwargs_trans: A dict-to-dict transformation of the outer kwargs to</span>
<span class="sd">            the kwargs that should be input to the inner function.</span>
<span class="sd">            That is ``kwargs_trans`` is ``outer_kwargs -&gt; inner_kwargs``.</span>
<span class="sd">            Note that though both outer and inner signatures could have those annoying</span>
<span class="sd">            position-only kinds, you don&#39;t have to think of that.</span>
<span class="sd">            The parameter kind restrictions are taken care of automatically.</span>
<span class="sd">        :param outer_sig: The outer signature. The signature the ingress function</span>
<span class="sd">            (there for the wrapped function) will have. Also serves to convert input</span>
<span class="sd">            (args, kwargs) to the kwargs that will be given to kwargs_trans.</span>

<span class="sd">        When making an Ingress function directly, one must take care that</span>
<span class="sd">        ``inner_sig``, ``kwargs_trans`` and ``outer_sig`` are aligned.</span>

<span class="sd">        Namely, &#39;kwargs_trans&#39; must be able to handle outputs of</span>
<span class="sd">        ``outer_sig.kwargs_from_args_and_kwargs`` and itself output kwargs that</span>
<span class="sd">        can be handled by ``inner_sig.args_and_kwargs_from_kwargs``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inner_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">inner_sig</span><span class="p">)</span>

        <span class="c1"># kwargs_trans should be callable and have one required arg: a dict</span>
        <span class="c1"># if it&#39;s None, we&#39;ll just make it be the identity function</span>
        <span class="k">if</span> <span class="n">kwargs_trans</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs_trans</span> <span class="o">=</span> <span class="n">identity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs_trans</span> <span class="o">=</span> <span class="n">kwargs_trans</span>

        <span class="c1"># default to inner_sig = outer_sig</span>
        <span class="k">if</span> <span class="n">outer_sig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outer_sig</span> <span class="o">=</span> <span class="n">inner_sig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outer_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">outer_sig</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">outer_sig</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">ingress_args</span><span class="p">,</span> <span class="o">**</span><span class="n">ingress_kwargs</span><span class="p">):</span>
        <span class="c1"># Get the all-keywords version of the arguments (args,kwargs-&gt;kwargs)</span>
        <span class="n">func_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outer_sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
            <span class="n">ingress_args</span><span class="p">,</span> <span class="n">ingress_kwargs</span><span class="p">,</span> <span class="n">apply_defaults</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="n">func_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">func_kwargs</span><span class="p">,</span>  <span class="c1"># by default, keep the func_kwargs, but</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs_trans</span><span class="p">(</span><span class="n">func_kwargs</span><span class="p">),</span>  <span class="c1"># change those that kwargs_trans desires</span>
        <span class="p">)</span>

        <span class="c1"># Return an (args, kwargs) pair that respects the inner function&#39;s</span>
        <span class="c1"># argument kind restrictions.</span>
        <span class="c1"># Note: Originally was with (default) allow_excess=False. Changed to True to</span>
        <span class="c1">#       allow more flexibility in outer sig. But is this sane? Worth it?</span>
        <span class="c1"># TODO: Reflect on pros/cons of allow_excess=True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner_sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span>
            <span class="n">func_kwargs</span><span class="p">,</span> <span class="n">apply_defaults</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_excess</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;Ingress signature: </span><span class="si">{</span><span class="n">signature</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>

<div class="viewcode-block" id="Ingress.wrap"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.Ingress.wrap">[docs]</a>    <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">egress</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Wrap</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convenience method to wrap a function with the instance ingress.</span>
<span class="sd">        ``ingress.wrap(func,...)`` equivalent to ``Wrap(func, ingress, ...)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Wrap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">ingress</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">egress</span><span class="o">=</span><span class="n">egress</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Ingress.name_map"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.Ingress.name_map">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">name_map</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">wrapped</span><span class="p">,</span> <span class="o">**</span><span class="n">old_to_new_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Change argument names.</span>

<span class="sd">        &gt;&gt;&gt; def f(w, /, x: float, y=2, *, z: int = 3):</span>
<span class="sd">        ...     return f&quot;(w:={w}) + (x:={x}) * (y:={y}) ** (z:={z}) == {w + x * y ** z}&quot;</span>
<span class="sd">        &gt;&gt;&gt; ingress = Ingress.name_map(f, w=&#39;DoubleYou&#39;, z=&#39;Zee&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ingress</span>
<span class="sd">        Ingress signature: (DoubleYou, /, x: float, y=2, *, Zee: int = 3)</span>
<span class="sd">        &gt;&gt;&gt; wrapped_f = ingress.wrap(f)</span>
<span class="sd">        &gt;&gt;&gt; wrapped_f(1, 2, y=3, Zee=4)</span>
<span class="sd">        &#39;(w:=1) + (x:=2) * (y:=3) ** (z:=4) == 163&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_to_old_name</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">old_to_new_name</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_to_old_name</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">old_to_new_name</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;Inversion is not possible since </span><span class="si">{</span><span class="n">old_to_new_name</span><span class="si">=}</span><span class="s1"> has duplicate values.&#39;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">wrapped</span><span class="p">,</span>
            <span class="n">partial</span><span class="p">(</span><span class="n">Pipe</span><span class="p">(</span><span class="n">items_with_mapped_keys</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="n">key_mapper</span><span class="o">=</span><span class="n">new_to_old_name</span><span class="p">),</span>
            <span class="n">Sig</span><span class="p">(</span><span class="n">wrapped</span><span class="p">)</span><span class="o">.</span><span class="n">ch_names</span><span class="p">(</span><span class="o">**</span><span class="n">old_to_new_name</span><span class="p">),</span>
        <span class="p">)</span></div></div>

    <span class="c1">#     @classmethod</span>
    <span class="c1">#     def defaults(cls, wrapped, **defaults):</span>
    <span class="c1">#         &quot;&quot;&quot;&quot;&quot;&quot;</span>
    <span class="c1">#</span>
    <span class="c1">#     @classmethod</span>
    <span class="c1">#     def order(cls, wrapped, arg_order):</span>
    <span class="c1">#         &quot;&quot;&quot;&quot;&quot;&quot;</span>
    <span class="c1">#</span>
    <span class="c1">#     @classmethod</span>
    <span class="c1">#     def factory(cls, wrapped, **func_for_name):</span>
    <span class="c1">#         &quot;&quot;&quot;&quot;&quot;&quot;</span>


<div class="viewcode-block" id="items_with_mapped_keys"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.items_with_mapped_keys">[docs]</a><span class="k">def</span> <span class="nf">items_with_mapped_keys</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">key_mapper</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transform dict keys. More precisely yield (new_k,v) pairs from a key mapper dict.</span>

<span class="sd">    :param d: src dict</span>
<span class="sd">    :param key_mapper: {old_name: new_name, ...} mapping</span>
<span class="sd">    :return: generator of (new_name, value) pairs</span>

<span class="sd">    Often used in conjunction with dict:</span>

<span class="sd">    &gt;&gt;&gt; dict(items_with_mapped_keys(</span>
<span class="sd">    ...     {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4},</span>
<span class="sd">    ...     {&#39;a&#39;: &#39;Ay&#39;, &#39;d&#39;: &#39;Dee&#39;})</span>
<span class="sd">    ... )</span>
<span class="sd">    {&#39;Ay&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;Dee&#39;: 4}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># key_mapper.get(k, k) will give the new key name if present,</span>
        <span class="c1"># else will use the old</span>
        <span class="k">yield</span> <span class="n">key_mapper</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">v</span></div>


<span class="k">def</span> <span class="nf">invert_map</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="n">new_d</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_d</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">new_d</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;There are duplicate keys so I can invert map: </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>


<span class="kn">from</span> <span class="nn">i2.signatures</span> <span class="kn">import</span> <span class="n">parameter_to_dict</span>


<span class="k">def</span> <span class="nf">parameters_to_dict</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">parameter_to_dict</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>


<span class="k">def</span> <span class="nf">_handle_ingress_class_inputs</span><span class="p">(</span>
    <span class="n">inner_sig</span><span class="p">,</span>
    <span class="n">kwargs_trans</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">KwargsTrans</span><span class="p">],</span>
    <span class="n">outer_sig</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">_allow_reordering</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">inner_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">inner_sig</span><span class="p">)</span>

    <span class="c1"># kwargs_trans should be callable and have one required arg: a dict</span>
    <span class="c1"># if it&#39;s None, we&#39;ll just make it be the identity function</span>
    <span class="k">if</span> <span class="n">kwargs_trans</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">kwargs_trans</span> <span class="o">=</span> <span class="n">identity</span>

    <span class="c1"># default to inner_sig = outer_sig</span>
    <span class="k">if</span> <span class="n">outer_sig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">outer_sig</span> <span class="o">=</span> <span class="n">inner_sig</span>  <span class="c1"># if nothing specified, want same outer and inner sigs</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outer_sig</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
        <span class="n">changes_for_name</span> <span class="o">=</span> <span class="n">outer_sig</span>  <span class="c1"># it&#39;s a dict of modifications of the inner sig</span>
        <span class="n">outer_sig</span> <span class="o">=</span> <span class="n">inner_sig</span><span class="o">.</span><span class="n">modified</span><span class="p">(</span>
            <span class="n">_allow_reordering</span><span class="o">=</span><span class="n">_allow_reordering</span><span class="p">,</span> <span class="o">**</span><span class="n">changes_for_name</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">outer_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">outer_sig</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">inner_sig</span><span class="p">,</span> <span class="n">kwargs_trans</span><span class="p">,</span> <span class="n">outer_sig</span>


<span class="c1"># TODO: See what this adds over ``Ingress`` class. Consider merging or reusing.</span>
<div class="viewcode-block" id="InnerMapIngress"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.InnerMapIngress">[docs]</a><span class="k">class</span> <span class="nc">InnerMapIngress</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A class to help build ingresses systematically by mapping the inner signature.</span>

<span class="sd">    *Systematically*, i.e. &quot;according to a fixed plan/system&quot; is what it&#39;s about here.</span>
<span class="sd">    As we&#39;ll see below, if you need to write a particular adapter for a specific case,</span>
<span class="sd">    you probably should do by writing an actual ingress function directly.</span>
<span class="sd">    In cases where you might want to apply a same logic to wrap many functions,</span>
<span class="sd">    you may want to fix that wrapping logic: ``InnerMapIngress`` provides one</span>
<span class="sd">    way to do this.</span>

<span class="sd">    :param inner_sig: The signature of the wrapped function.</span>
<span class="sd">    :param kwargs_trans: A dict-to-dict transformation of the outer kwargs to</span>
<span class="sd">        the kwargs that should be input to the inner function.</span>
<span class="sd">        That is ``kwargs_trans`` is ``outer_kwargs -&gt; inner_kwargs``.</span>
<span class="sd">        Note that though both outer and inner signatures could have those annoying</span>
<span class="sd">        position-only kinds, you don&#39;t have to think of that.</span>
<span class="sd">        The parameter kind restrictions are taken care of automatically.</span>
<span class="sd">    :param _allow_reordering: Whether we want to allow reordering of variables</span>
<span class="sd">    :param in_to_out_sig_changes: The ``inner_name=dict_of_changes_for_that_name``</span>
<span class="sd">    pairs, the ``dict_of_changes_for_that_name`` is a ``dict`` with keys being valid</span>
<span class="sd">    ``inspect.Parameter``</span>

<span class="sd">    Consider the following function that has a position only, a keyword only,</span>
<span class="sd">    two arguments with annotations, and three with a default.</span>

<span class="sd">    &gt;&gt;&gt; def f(w, /, x: float = 1, y=2, *, z: int = 3):</span>
<span class="sd">    ...     return w + x * y ** z</span>

<span class="sd">    Say we wanted a version of this function</span>

<span class="sd">    - that didn&#39;t have the argument kind restrinctions (all POSITION_OR_KEYWORD),</span>

<span class="sd">    - where the annotation of ``x`` was changed ``int`` and the default removed</span>

<span class="sd">    - where ``y`` was named ``you`` instead, and has an annotation (``int``).</span>

<span class="sd">    - where the default of ``z`` was ``10`` instead of ``3``, and doesn&#39;t have an</span>
<span class="sd">    annotation.</span>

<span class="sd">    In order to get a version of this function we wanted (more lenient kinds,</span>
<span class="sd">    with some annotations and a default change), we can use the ingress function:</span>

<span class="sd">    &gt;&gt;&gt; def directly_defined_ingress(w, x: int, you: int=2, z = 10):</span>
<span class="sd">    ...     return (w,), dict(x=x, y=you, z=z)</span>


<span class="sd">    When we need to wrap a specific function in a specific way, defining an</span>
<span class="sd">    ingress function  this way is usually the simplest way.</span>
<span class="sd">    But in some cases we need to build the ingress function using some predefined</span>
<span class="sd">    rule/protocol to make applying the rule/protocol systematic.</span>

<span class="sd">    For those cases, ``InnerMapIngress`` comes in handy.</span>

<span class="sd">    With ``InnerMapIngress`` we&#39;d build our ingress function like this:</span>

<span class="sd">    &gt;&gt;&gt; from inspect import Parameter, signature</span>
<span class="sd">    &gt;&gt;&gt; PK = Parameter.POSITIONAL_OR_KEYWORD</span>
<span class="sd">    &gt;&gt;&gt; empty = Parameter.empty</span>
<span class="sd">    &gt;&gt;&gt; ingress = InnerMapIngress(</span>
<span class="sd">    ...     f,</span>
<span class="sd">    ...     # change kind to PK:</span>
<span class="sd">    ...     w=dict(kind=PK),</span>
<span class="sd">    ...     # change annotation of x from float to int and remove default</span>
<span class="sd">    ...     x=dict(annotation=int, default=empty),</span>
<span class="sd">    ...     # rename y to you and add annotation int:</span>
<span class="sd">    ...     y=dict(name=&#39;you&#39;, annotation=int),</span>
<span class="sd">    ...     # change kind to PK, default to 10, and remove annotation:</span>
<span class="sd">    ...     z=dict(kind=PK, default=10, annotation=empty),</span>
<span class="sd">    ... )</span>

<span class="sd">    Note:</span>

<span class="sd">    - Only the changes we wish to make to the parameters are mentioned.</span>
<span class="sd">        You could also define the parameters explicitly by simply listing all three</span>
<span class="sd">        of the dimensions (kind, annotation, and default)</span>

<span class="sd">    - Three? But a ``Parameter`` object has four; what about the name?</span>
<span class="sd">        Indeed, you can use name as well, more on that later.</span>

<span class="sd">    - Note that in order to specify that you want no default, or no annotation,</span>
<span class="sd">        you cannot use ``None`` since ``None`` is both a valid default and a valid</span>
<span class="sd">        annotation; So instead you need to use ``Parameter.empty`` (conveniently</span>
<span class="sd">        assigned to a constant named ``empty`` in the ``wrapping`` module.</span>

<span class="sd">    Now see that all arguments are ``POSITIONAL_OR_KEYWORD``, ``x`` and ``y`` are</span>
<span class="sd">    ``int``, and default of ``z`` is 10:</span>

<span class="sd">    &gt;&gt;&gt; assert (</span>
<span class="sd">    ...     str(signature(ingress))</span>
<span class="sd">    ...     == str(signature(directly_defined_ingress))</span>
<span class="sd">    ...     == &#39;(w, x: int, you: int = 2, z=10)&#39;</span>
<span class="sd">    ... )</span>

<span class="sd">    Additionally, ``ingress`` function does it&#39;s job of dispatching the right args</span>
<span class="sd">    and kwargs to the target function:</span>

<span class="sd">    &gt;&gt;&gt; assert (</span>
<span class="sd">    ...     ingress(0,1,2,3)</span>
<span class="sd">    ...     == directly_defined_ingress(0,1,2,3)</span>
<span class="sd">    ...     == ((0,), {&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;z&#39;: 3})</span>
<span class="sd">    ... )</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inner_sig</span><span class="p">,</span>
        <span class="n">kwargs_trans</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">KwargsTrans</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">_allow_reordering</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">changes_for_name</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inner_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">inner_sig</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">outer_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner_sig</span><span class="o">.</span><span class="n">modified</span><span class="p">(</span>
            <span class="n">_allow_reordering</span><span class="o">=</span><span class="n">_allow_reordering</span><span class="p">,</span> <span class="o">**</span><span class="n">changes_for_name</span>
        <span class="p">)</span>

        <span class="c1"># kwargs_trans should be callable and have one required arg: a dict</span>
        <span class="c1"># if it&#39;s None, we&#39;ll just make it be the identity function</span>
        <span class="k">if</span> <span class="n">kwargs_trans</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwargs_trans</span> <span class="o">=</span> <span class="n">identity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kwargs_trans</span> <span class="o">=</span> <span class="n">kwargs_trans</span>

        <span class="n">outer_name_for_inner_name</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">inner_name</span><span class="p">:</span> <span class="n">change</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">inner_name</span><span class="p">,</span> <span class="n">change</span> <span class="ow">in</span> <span class="n">changes_for_name</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="s1">&#39;name&#39;</span> <span class="ow">in</span> <span class="n">change</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inner_name_for_outer_name</span> <span class="o">=</span> <span class="n">invert_map</span><span class="p">(</span><span class="n">outer_name_for_inner_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outer_sig</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">ingress_args</span><span class="p">,</span> <span class="o">**</span><span class="n">ingress_kwargs</span><span class="p">):</span>
        <span class="c1"># Get the all-keywords version of the arguments (args,kwargs-&gt;kwargs)</span>
        <span class="n">func_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outer_sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
            <span class="n">ingress_args</span><span class="p">,</span> <span class="n">ingress_kwargs</span><span class="p">,</span> <span class="n">apply_defaults</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># Modify the keys of func_kwargs so they reflect the inner signature&#39;s names</span>
        <span class="c1"># That is, map outer names to inner names.</span>
        <span class="n">func_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">items_with_mapped_keys</span><span class="p">(</span><span class="n">func_kwargs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner_name_for_outer_name</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">func_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">func_kwargs</span><span class="p">,</span>  <span class="c1"># by default, keep the func_kwargs, but</span>
            <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs_trans</span><span class="p">(</span><span class="n">func_kwargs</span><span class="p">),</span>  <span class="c1"># change those that kwargs_trans desires</span>
        <span class="p">)</span>

        <span class="c1"># Return an (args, kwargs) pair the respects the inner function&#39;s</span>
        <span class="c1"># argument kind restrictions.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner_sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="n">func_kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="InnerMapIngress.from_signature"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.InnerMapIngress.from_signature">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_signature</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">inner_sig</span><span class="p">,</span> <span class="n">outer_sig</span><span class="p">,</span> <span class="n">_allow_reordering</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param inner_sig:</span>
<span class="sd">        :param outer_sig:</span>
<span class="sd">        :param _allow_reordering:</span>
<span class="sd">        :return:</span>

<span class="sd">        Say we wanted to get a version of the function:</span>

<span class="sd">        &gt;&gt;&gt; def f(w, /, x: float = 1, y=2, *, z: int = 3):</span>
<span class="sd">        ...     return w + x * y ** z</span>

<span class="sd">        That was equivalent to (note the kind, default and annotation differences):</span>

<span class="sd">        &gt;&gt;&gt; def g(w, x=1, y=2, z=10):</span>
<span class="sd">        ...     return w + x * y ** z</span>


<span class="sd">        &gt;&gt;&gt; ingress = InnerMapIngress.from_signature(</span>
<span class="sd">        ... f, outer_sig=lambda w, x=1, y=2, z=10: None</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; Sig(ingress)</span>
<span class="sd">        &lt;Sig (w, x=1, y=2, z=10)&gt;</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; h = wrap(f, ingress=InnerMapIngress.from_signature(f, g))</span>
<span class="sd">        &gt;&gt;&gt; assert h(0) == g(0) == 1024 == 0 + 1 * 2 ** 10</span>
<span class="sd">        &gt;&gt;&gt; assert h(1,2) == g(1,2) == 2049 == 1 + 2 * 2 ** 10</span>
<span class="sd">        &gt;&gt;&gt; assert h(1,2,3,4) == g(1,2,3,4) == 1 + 2 * 3 ** 4</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; assert h(w=1,x=2,y=3,z=4) == g(1,2,3,4) == 1 + 2 * 3 ** 4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">outer_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">outer_sig</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">inner_sig</span><span class="p">,</span>
            <span class="n">_allow_reordering</span><span class="o">=</span><span class="n">_allow_reordering</span><span class="p">,</span>
            <span class="o">**</span><span class="n">parameters_to_dict</span><span class="p">(</span><span class="n">outer_sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">),</span>
        <span class="p">)</span></div></div>


<span class="c1"># TODO: Fits global pattern -- merge</span>
<span class="k">class</span> <span class="nc">ArgNameMappingIngress</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inner_sig</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">conserve_kind</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">outer_name_for_inner_name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inner_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">inner_sig</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outer_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner_sig</span><span class="o">.</span><span class="n">ch_names</span><span class="p">(</span><span class="o">**</span><span class="n">outer_name_for_inner_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">conserve_kind</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outer_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outer_sig</span><span class="o">.</span><span class="n">ch_kinds_to_position_or_keyword</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inner_name_for_outer_name</span> <span class="o">=</span> <span class="n">invert_map</span><span class="p">(</span><span class="n">outer_name_for_inner_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outer_sig</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">ingress_args</span><span class="p">,</span> <span class="o">**</span><span class="n">ingress_kwargs</span><span class="p">):</span>
        <span class="c1"># Get the all-keywords version of the arguments (args,kwargs-&gt;kwargs)</span>
        <span class="n">func_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outer_sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
            <span class="n">ingress_args</span><span class="p">,</span> <span class="n">ingress_kwargs</span>
        <span class="p">)</span>
        <span class="c1"># Modify the keys of func_kwargs so they reflect the inner signature&#39;s names</span>
        <span class="c1"># That is, map outer names to inner names.</span>
        <span class="n">func_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">items_with_mapped_keys</span><span class="p">(</span><span class="n">func_kwargs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner_name_for_outer_name</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Return an (args,kwargs) pair the respects the inner function&#39;s</span>
        <span class="c1"># argument kind restrictions.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner_sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="n">func_kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">mk_ingress_from_name_mapper</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">name_mapper</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">conserve_kind</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ArgNameMappingIngress</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">conserve_kind</span><span class="o">=</span><span class="n">conserve_kind</span><span class="p">,</span> <span class="o">**</span><span class="n">name_mapper</span><span class="p">)</span>


<span class="c1"># TODO: Replace with i2.wrapper instead</span>
<span class="c1"># TODO: Make sure VARIADICs are handled properly, or error raised if present</span>


<span class="k">def</span> <span class="nf">apply_func_on_cond</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">cond</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">v</span>


<span class="k">def</span> <span class="nf">modify_dict_on_cond</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">apply_func_on_cond</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>


<span class="k">def</span> <span class="nf">convert_to_PK</span><span class="p">(</span><span class="n">kinds</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">PK</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kinds</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">convert_VK_to_KO</span><span class="p">(</span><span class="n">kinds</span><span class="p">):</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span> <span class="o">==</span> <span class="n">VK</span>
    <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">KO</span>

    <span class="k">return</span> <span class="n">modify_dict_on_cond</span><span class="p">(</span><span class="n">kinds</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>


<div class="viewcode-block" id="nice_kinds"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.nice_kinds">[docs]</a><span class="k">def</span> <span class="nf">nice_kinds</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">kinds_modifier</span><span class="o">=</span><span class="n">convert_to_PK</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wraps the func, changing the argument kinds according to kinds_modifier.</span>
<span class="sd">    The default behaviour is to change all kinds to POSITIONAL_OR_KEYWORD kinds.</span>
<span class="sd">    The original purpose of this function is to remove argument-kind restriction</span>
<span class="sd">    annoyances when doing functional manipulations such as:</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; isinstance_of_str = partial(isinstance, class_or_tuple=str)</span>
<span class="sd">    &gt;&gt;&gt; isinstance_of_str(&#39;I am a string&#39;)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    TypeError: isinstance() takes no keyword arguments</span>

<span class="sd">    Here, instead, we can just get a kinder version of the function and do what we</span>
<span class="sd">    want to do:</span>

<span class="sd">    &gt;&gt;&gt; _isinstance = nice_kinds(isinstance)</span>
<span class="sd">    &gt;&gt;&gt; isinstance_of_str = partial(_isinstance, class_or_tuple=str)</span>
<span class="sd">    &gt;&gt;&gt; isinstance_of_str(&#39;I am a string&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; isinstance_of_str(42)</span>
<span class="sd">    False</span>

<span class="sd">    See also: ``i2.signatures.all_pk_signature``</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">i2</span> <span class="kn">import</span> <span class="n">Sig</span><span class="p">,</span> <span class="n">call_somewhat_forgivingly</span>

    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">kinds_modif</span> <span class="o">=</span> <span class="n">kinds_modifier</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">kinds</span><span class="p">)</span>

    <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">ch_kinds</span><span class="p">(</span><span class="o">**</span><span class="n">kinds_modif</span><span class="p">)</span>

    <span class="c1"># sig = sig.ch_kinds(**{name: Sig.POSITIONAL_OR_KEYWORD for name in sig.names})</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">call_somewhat_forgivingly</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">enforce_sig</span><span class="o">=</span><span class="n">sig</span><span class="p">)</span>

    <span class="n">_func</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">sig</span>
    <span class="k">return</span> <span class="n">_func</span></div>


<span class="k">def</span> <span class="nf">wrap_from_sig</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">new_sig</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">i2</span> <span class="kn">import</span> <span class="n">call_somewhat_forgivingly</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">call_somewhat_forgivingly</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">enforce_sig</span><span class="o">=</span><span class="n">new_sig</span><span class="p">)</span>

    <span class="n">_func</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">new_sig</span>

    <span class="k">return</span> <span class="n">_func</span>


<span class="c1"># ---------------------------------------------------------------------------------------</span>
<span class="c1"># wrap tools</span>


<span class="nd">@double_up_as_factory</span>
<span class="k">def</span> <span class="nf">ch_names</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">old_to_new_name</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Change the argument names of a function.</span>

<span class="sd">    &gt;&gt;&gt; def f(w, /, x: float, y=2, *, z: int = 3):</span>
<span class="sd">    ...     return f&quot;(w:={w}) + (x:={x}) * (y:={y}) ** (z:={z}) == {w + x * y ** z}&quot;</span>
<span class="sd">    &gt;&gt;&gt; wrapped_f = ch_names(f, w=&#39;DoubleYou&#39;, z=&#39;Zee&#39;)</span>
<span class="sd">    &gt;&gt;&gt; wrapped_f</span>
<span class="sd">    &lt;i2.Wrap f(DoubleYou, /, x: float, y=2, *, Zee: int = 3)&gt;</span>
<span class="sd">    &gt;&gt;&gt; wrapped_f(1, 2, y=3, Zee=4)</span>
<span class="sd">    &#39;(w:=1) + (x:=2) * (y:=3) ** (z:=4) == 163&#39;</span>

<span class="sd">    Can also be used as a factory:</span>
<span class="sd">    &gt;&gt;&gt; @ch_names(a=&#39;alpha&#39;, g=&#39;gamma&#39;)</span>
<span class="sd">    ... def foo(a, b, g=1):</span>
<span class="sd">    ...     return a + b * g</span>
<span class="sd">    &gt;&gt;&gt; foo(alpha=1, b=2, gamma=3)</span>
<span class="sd">    7</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Ingress</span><span class="o">.</span><span class="n">name_map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">old_to_new_name</span><span class="p">)</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>


<span class="n">map_names</span> <span class="o">=</span> <span class="n">ch_names</span>  <span class="c1"># back-compatibility alias</span>


<div class="viewcode-block" id="include_exclude_ingress_factory"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.include_exclude_ingress_factory">[docs]</a><span class="k">def</span> <span class="nf">include_exclude_ingress_factory</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A pattern underlying any ingress that takes a subset of parameters (possibly</span>
<span class="sd">    reordering them).</span>

<span class="sd">    For example: Keep only required arguments, or reorder params to be able to</span>
<span class="sd">    partialize #3 (without having to partialize #1 and #2)</span>

<span class="sd">    Note: A more general version would allow include and exclude to be expressed as</span>
<span class="sd">    functions that apply to one or several properties of the params (name, kind, default,</span>
<span class="sd">    annotation).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">include</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">include</span> <span class="o">=</span> <span class="n">include</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">exclude</span> <span class="o">=</span> <span class="n">exclude</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">exclude</span> <span class="o">=</span> <span class="n">exclude</span> <span class="ow">or</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">include</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">include</span> <span class="ow">or</span> <span class="n">sig</span><span class="o">.</span><span class="n">names</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">Ingress</span><span class="p">(</span><span class="n">inner_sig</span><span class="o">=</span><span class="n">sig</span><span class="p">,</span> <span class="n">outer_sig</span><span class="o">=</span><span class="n">sig</span><span class="p">[</span><span class="n">include</span><span class="p">])</span></div>


<span class="nd">@double_up_as_factory</span>
<span class="k">def</span> <span class="nf">include_exclude</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Reorder and/or remove parameters.</span>

<span class="sd">    &gt;&gt;&gt; def foo(a, b, c=&#39;C&#39;, d=&#39;D&#39;):</span>
<span class="sd">    ...     print(f&quot;{a=},{b=},{c=},{d=}&quot;)</span>
<span class="sd">    &gt;&gt;&gt; bar = include_exclude(foo, include=&#39;b a&#39;, exclude=&#39;c d&#39;)</span>

<span class="sd">    The signature of ``bar`` has only ``b`` and ``a``, in that order:</span>

<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; str(signature(bar))</span>
<span class="sd">    &#39;(b, a)&#39;</span>

<span class="sd">    But the function still works and does the same thing:</span>

<span class="sd">    &gt;&gt;&gt; bar(&#39;B&#39;, &#39;A&#39;)</span>
<span class="sd">    a=&#39;A&#39;,b=&#39;B&#39;,c=&#39;C&#39;,d=&#39;D&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">ingress</span><span class="o">=</span><span class="n">include_exclude_ingress_factory</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">include</span><span class="p">,</span> <span class="n">exclude</span><span class="p">))</span>


<span class="nd">@double_up_as_factory</span>
<span class="k">def</span> <span class="nf">rm_params</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">params_to_remove</span><span class="o">=</span><span class="p">()):</span>
    <span class="sd">&quot;&quot;&quot;Get a function with some parameters removed.</span>

<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; def func(x, y=1, z=2):</span>
<span class="sd">    ...     return x + y * z</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; f = rm_params(func, params_to_remove=&#39;z&#39;)</span>
<span class="sd">    &gt;&gt;&gt; assert f(3) == func(3) == 5</span>
<span class="sd">    &gt;&gt;&gt; assert f(3, 4) == func(3, 4) == 11</span>
<span class="sd">    &gt;&gt;&gt; str(signature(f))</span>
<span class="sd">    &#39;(x, y=1)&#39;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; f = rm_params(func, params_to_remove=&#39;y z&#39;)</span>
<span class="sd">    &gt;&gt;&gt; assert f(3) == func(3) == 5</span>
<span class="sd">    &gt;&gt;&gt; str(signature(f))</span>
<span class="sd">    &#39;(x)&#39;</span>

<span class="sd">    But ``rm_params`` won&#39;t let you remove params that don&#39;t have defaults.</span>

<span class="sd">    &gt;&gt;&gt; f = rm_params(func, params_to_remove=&#39;x z&#39;)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    AssertionError: Some of the params you want to remove don&#39;t have defaults: {&#39;x&#39;}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params_to_remove</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">params_to_remove</span> <span class="o">=</span> <span class="n">params_to_remove</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">params_to_remove_that_do_not_have_defaults</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">params_to_remove</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span>
        <span class="n">sig</span><span class="o">.</span><span class="n">without_defaults</span><span class="o">.</span><span class="n">names</span>
    <span class="p">)</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">params_to_remove_that_do_not_have_defaults</span><span class="p">,</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Some of the params you want to remove don&#39;t have defaults: &quot;</span>
        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">params_to_remove_that_do_not_have_defaults</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span>
        <span class="n">func</span><span class="p">,</span> <span class="n">ingress</span><span class="o">=</span><span class="n">include_exclude_ingress_factory</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">params_to_remove</span><span class="p">)</span>
    <span class="p">)</span>


<span class="c1">#     new_sig = sig - params_to_remove</span>
<span class="c1">#     return new_sig(func)</span>


<span class="k">def</span> <span class="nf">arg_val_converter</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">conversion_for_arg</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Wrap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">ingress</span><span class="o">=</span><span class="n">ArgValConverterIngress</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">conversion_for_arg</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">arg_val_converter_ingress</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">__strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">conversion_for_arg</span><span class="p">):</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">__strict</span><span class="p">:</span>
        <span class="n">conversion_names_that_are_not_func_args</span> <span class="o">=</span> <span class="n">conversion_for_arg</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="n">sig</span><span class="o">.</span><span class="n">names</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">conversion_names_that_are_not_func_args</span><span class="p">,</span> <span class="p">(</span>
            <span class="s1">&#39;Some of the arguments you want to convert are not argument names &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;for the function: </span><span class="si">{</span><span class="n">conversion_names_that_are_not_func_args</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">)</span>

    <span class="nd">@sig</span>
    <span class="k">def</span> <span class="nf">ingress</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># TODO: Make a helper function for this ak -&gt; k -&gt; proc -&gt; ak pattern</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">convert_dict_values</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">conversion_for_arg</span><span class="p">))</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span>

    <span class="k">return</span> <span class="n">ingress</span>


<span class="c1"># TODO: Fits global pattern -- merge</span>
<span class="k">class</span> <span class="nc">ArgValConverterIngress</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">__strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">conversion_for_arg</span><span class="p">):</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">__strict</span><span class="p">:</span>
            <span class="n">conversion_names_that_are_not_func_args</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">conversion_for_arg</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="n">sig</span><span class="o">.</span><span class="n">names</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">conversion_names_that_are_not_func_args</span><span class="p">,</span> <span class="p">(</span>
                <span class="s1">&#39;Some of the arguments you want to convert are not argument names &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;for the function: </span><span class="si">{</span><span class="n">conversion_names_that_are_not_func_args</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conversion_for_arg</span> <span class="o">=</span> <span class="n">conversion_for_arg</span>
        <span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># TODO: Make a helper function for this ak -&gt; k -&gt; proc -&gt; ak pattern</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">convert_dict_values</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">conversion_for_arg</span><span class="p">))</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span>


<span class="c1"># ---------------------------------------------------------------------------------------</span>
<span class="c1"># Utils to help define value conversions in ingress functions</span>


<span class="k">def</span> <span class="nf">convert_dict_values</span><span class="p">(</span><span class="n">to_convert</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">key_to_conversion_function</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">to_convert</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">key_to_conversion_function</span><span class="p">:</span>
            <span class="n">conversion_func</span> <span class="o">=</span> <span class="n">key_to_conversion_function</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">conversion_func</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  <span class="c1"># converted kv pair</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>  <span class="c1"># unconverted kv pair</span>


<span class="c1"># TODO: Test for performance and ask about readability</span>
<span class="k">def</span> <span class="nf">_alt_convert_dict_values</span><span class="p">(</span><span class="n">to_convert</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">key_to_conversion_function</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">to_convert</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">conversion_func</span> <span class="o">=</span> <span class="n">key_to_conversion_function</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">conversion_func</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">params_used_in_funcs</span><span class="p">(</span><span class="n">funcs</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">name</span> <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">funcs</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">names</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">required_params_used_in_funcs</span><span class="p">(</span><span class="n">funcs</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">name</span> <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">funcs</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">required_names</span><span class="p">}</span>


<span class="kn">from</span> <span class="nn">i2.signatures</span> <span class="kn">import</span> <span class="n">_call_forgivingly</span>


<span class="c1"># TODO: Should we add some explicit/validation/strict options?</span>
<div class="viewcode-block" id="kwargs_trans"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.kwargs_trans">[docs]</a><span class="k">def</span> <span class="nf">kwargs_trans</span><span class="p">(</span>
    <span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">_recursive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">_inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">key_and_val_func</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transform a kwargs dict or build a transformer.</span>

<span class="sd">    :param kwargs: The dict containing the input kwargs that we will transform</span>
<span class="sd">    :param _recursive: Whether the transformations listed in ``key_and_val_func`` should</span>
<span class="sd">        be applied &quot;recursively&quot;. When set to ``False`` (default), each transformation</span>
<span class="sd">        function applies to the original ``kwargs``, not the one that was transformed,</span>
<span class="sd">        so far.</span>
<span class="sd">    :param _inplace: If set to ``False`` will make a shallow copy of the ``kwargs``</span>
<span class="sd">        before transforming it (only relevant if ``_recursive=True``</span>
<span class="sd">    :param key_and_val_func: The ``key=val_func`` pairs that indicate that a</span>
<span class="sd">        ``val_func`` should be applied to the ``kwargs``, maching the argument names of</span>
<span class="sd">        the ``val_func`` to the keys of ``kwargs`` and extracting the values found</span>
<span class="sd">        therein to use for the corresponding inputs of that ``val_func``.</span>
<span class="sd">    :return: The transformed kwargs.</span>

<span class="sd">    &gt;&gt;&gt; d = dict(a=1, b=2, c=3)</span>
<span class="sd">    &gt;&gt;&gt; kwargs_trans(</span>
<span class="sd">    ...     d,</span>
<span class="sd">    ...     a=lambda a: a * 10,</span>
<span class="sd">    ...     b=lambda a, b: a + b</span>
<span class="sd">    ... )</span>
<span class="sd">    {&#39;a&#39;: 10, &#39;b&#39;: 3, &#39;c&#39;: 3}</span>

<span class="sd">    See that ``d`` is unchanged here (transformation is not in place).</span>

<span class="sd">    &gt;&gt;&gt; d</span>
<span class="sd">    {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}</span>

<span class="sd">    Typically you&#39;ll use ``kwargs_trans`` as a factory:</span>

<span class="sd">    &gt;&gt;&gt; trans = kwargs_trans(a=lambda a: a * 10, b=lambda a, b: a + b)</span>
<span class="sd">    &gt;&gt;&gt; trans(d)</span>
<span class="sd">    {&#39;a&#39;: 10, &#39;b&#39;: 3, &#39;c&#39;: 3}</span>

<span class="sd">    Here we&#39;ll demo what the ``_recursive`` and ``_inplace`` arguments do.</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; re_kwargs_trans = partial(kwargs_trans, _recursive=True, _inplace=True)</span>
<span class="sd">    &gt;&gt;&gt; d = dict(a=1, b=2, c=3)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; re_kwargs_trans(</span>
<span class="sd">    ...     d,</span>
<span class="sd">    ...     a=lambda a: a * 10,</span>
<span class="sd">    ...     b=lambda a, b: a + b</span>
<span class="sd">    ...     # since _recursive=True, the a that is used is the new a = 10, not a = 1:</span>
<span class="sd">    ... )</span>
<span class="sd">    {&#39;a&#39;: 10, &#39;b&#39;: 12, &#39;c&#39;: 3}</span>

<span class="sd">    Since ``_inplace=True``, ``d`` itself has changed:</span>

<span class="sd">    &gt;&gt;&gt; d</span>
<span class="sd">    {&#39;a&#39;: 10, &#39;b&#39;: 12, &#39;c&#39;: 3}</span>

<span class="sd">    Sometimes you&#39;ll pipe several transformers together:</span>

<span class="sd">    &gt;&gt;&gt; from i2 import Pipe</span>
<span class="sd">    &gt;&gt;&gt; trans = Pipe(</span>
<span class="sd">    ...     re_kwargs_trans(a=lambda a: a / 10),</span>
<span class="sd">    ...     re_kwargs_trans(c=lambda a,b,c: a * b * c),</span>
<span class="sd">    ...     # and then compute a new value of a using a and c:</span>
<span class="sd">    ...     re_kwargs_trans(a=lambda a, c: c - 1),</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; trans(d)</span>
<span class="sd">    {&#39;a&#39;: 35.0, &#39;b&#39;: 12, &#39;c&#39;: 36.0}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span>
            <span class="n">kwargs_trans</span><span class="p">,</span> <span class="n">_recursive</span><span class="o">=</span><span class="n">_recursive</span><span class="p">,</span> <span class="n">_inplace</span><span class="o">=</span><span class="n">_inplace</span><span class="p">,</span> <span class="o">**</span><span class="n">key_and_val_func</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_recursive</span><span class="p">:</span>
        <span class="n">new_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val_func</span> <span class="ow">in</span> <span class="n">key_and_val_func</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">_call_forgivingly</span><span class="p">(</span><span class="n">val_func</span><span class="p">,</span> <span class="p">(),</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">new_kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">_inplace</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val_func</span> <span class="ow">in</span> <span class="n">key_and_val_func</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">_call_forgivingly</span><span class="p">(</span><span class="n">val_func</span><span class="p">,</span> <span class="p">(),</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">kwargs</span></div>


<span class="c1"># ---------------------------------------------------------------------------------------</span>

<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Parameter</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">make_dataclass</span>

<span class="n">empty</span> <span class="o">=</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span>


<div class="viewcode-block" id="camelize"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.camelize">[docs]</a><span class="k">def</span> <span class="nf">camelize</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; camelize(&#39;camel_case&#39;)</span>
<span class="sd">    &#39;CamelCase&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ele</span><span class="o">.</span><span class="n">title</span><span class="p">()</span> <span class="k">for</span> <span class="n">ele</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">))</span></div>


<span class="k">def</span> <span class="nf">kwargs_trans_to_extract_args_from_attrs</span><span class="p">(</span>
    <span class="n">outer_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">attr_names</span><span class="o">=</span><span class="p">(),</span> <span class="n">obj_param</span><span class="o">=</span><span class="s1">&#39;self&#39;</span>
<span class="p">):</span>
    <span class="bp">self</span> <span class="o">=</span> <span class="n">outer_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">obj_param</span><span class="p">)</span>
    <span class="n">arguments_extracted_from_obj</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">attr_names</span><span class="p">}</span>
    <span class="c1"># The kwargs we need are the union of the extracted arguments with the remaining outer_kwargs</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">arguments_extracted_from_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">outer_kwargs</span><span class="p">)</span>


<span class="c1"># TODO: kind lost here, only 3.10 offers dataclasses with some control over kind:</span>
<span class="c1">#   See: https://stackoverflow.com/questions/49908182/how-to-make-keyword-only-fields-with-dataclasses</span>
<span class="k">def</span> <span class="nf">param_to_dataclass_field_tuple</span><span class="p">(</span><span class="n">param</span><span class="p">:</span> <span class="n">Parameter</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">annotation</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="n">empty</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">empty</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;typing.Any&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">t</span>


<span class="n">MethodFunc</span> <span class="o">=</span> <span class="n">Callable</span>


<div class="viewcode-block" id="func_to_method_func"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.func_to_method_func">[docs]</a><span class="k">def</span> <span class="nf">func_to_method_func</span><span class="p">(</span>
    <span class="n">func</span><span class="p">,</span>
    <span class="n">instance_params</span><span class="o">=</span><span class="p">(),</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">method_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">method_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">instance_arg_name</span><span class="o">=</span><span class="s1">&#39;self&#39;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MethodFunc</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Get a &#39;method function&#39; from a &#39;normal function&#39;. Also known as &quot;methodize&quot;.</span>

<span class="sd">    That is, get a function that gives the same outputs as the &#39;normal function&#39;,</span>
<span class="sd">    except that some of the arguments are sourced from the attributes of the first</span>
<span class="sd">    argument.</span>

<span class="sd">    The intended use case is when you want to inject one or several methods in a class</span>
<span class="sd">    or instance, sourcing some of the arguments of the underlying function from a</span>
<span class="sd">    common pool: The attributes of the instance.</span>

<span class="sd">    Consider the following function involving four parameters: ``a, b, c`` and ``d``.</span>

<span class="sd">    &gt;&gt;&gt; def func(a, b: int, c=2, *, d=&#39;bar&#39;):</span>
<span class="sd">    ...     return f&quot;{d}: {(a + b) * c}&quot;</span>
<span class="sd">    &gt;&gt;&gt; func(1, 2, c=3, d=&#39;hello&#39;)</span>
<span class="sd">    &#39;hello: 9&#39;</span>

<span class="sd">    If we wanted to make an equivalent &quot;method function&quot; that would source it&#39;s ``a``</span>
<span class="sd">    and it&#39;s ``c`` from the first argument&#39;s (in practice this first argument will be</span>
<span class="sd">    and instance of the class the method will be bound to), we can do so like so:</span>

<span class="sd">    &gt;&gt;&gt; method_func = func_to_method_func(func, &#39;a c&#39;)</span>
<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; str(signature(method_func))</span>
<span class="sd">    &quot;(self, b: int, *, d=&#39;bar&#39;)&quot;</span>

<span class="sd">    Note that the first argument is ``self`` (default name for an &quot;instance&quot;),</span>
<span class="sd">    that ``a`` and ``c`` are not there, but that the two remaining parameters,</span>
<span class="sd">    ``b`` and ``d`` are present, in the same order, and with the same annotations and</span>
<span class="sd">    parameter kind (the ``d`` is still keyword-only).</span>

<span class="sd">    Now let&#39;s make a dummy object that has attributes ``a`` and a ``c``, and use it to</span>
<span class="sd">    call ``method_func``:</span>

<span class="sd">    &gt;&gt;&gt; from collections import namedtuple</span>
<span class="sd">    &gt;&gt;&gt; instance = namedtuple(&#39;FakeInstance&#39;, &#39;a c&#39;)(1, 3)</span>
<span class="sd">    &gt;&gt;&gt; method_func(instance, 2, d=&#39;hello&#39;)</span>
<span class="sd">    &#39;hello: 9&#39;</span>

<span class="sd">    Which is:</span>

<span class="sd">    &gt;&gt;&gt; assert method_func(instance, 2, d=&#39;hello&#39;) == func(1, 2, c=3, d=&#39;hello&#39;)</span>

<span class="sd">    Often, though, what you&#39;ll want is to include this method function directly in</span>
<span class="sd">    a class, as you&#39;re making that class &quot;normally&quot;. That works too:</span>

<span class="sd">    &gt;&gt;&gt; from dataclasses import dataclass</span>
<span class="sd">    &gt;&gt;&gt; @dataclass</span>
<span class="sd">    ... class Klass:</span>
<span class="sd">    ...     a : int = 1</span>
<span class="sd">    ...     c : int = 3</span>
<span class="sd">    ...     method_func = func_to_method_func(func, &#39;a c&#39;)</span>
<span class="sd">    &gt;&gt;&gt; instance = Klass(1, 3)</span>
<span class="sd">    &gt;&gt;&gt; instance.method_func(2, d=&#39;hello&#39;)</span>
<span class="sd">    &#39;hello: 9&#39;</span>

<span class="sd">    What if your function has argument names that don&#39;t correspond to the names you</span>
<span class="sd">    have, or want, as attributes of the class? Or even, you have several functions that</span>
<span class="sd">    share an argument name that need to be bound to a different attribute?</span>

<span class="sd">    For that, just use ``map_names`` to wrap the function, giving it the names that</span>
<span class="sd">    you need to give it to have the effect you want (the binding of those arguments</span>
<span class="sd">    to attributes of the instance):</span>

<span class="sd">    &gt;&gt;&gt; from i2.wrapper import ch_names</span>
<span class="sd">    &gt;&gt;&gt; def func(x, y: int, z=2, *, d=&#39;bar&#39;):</span>
<span class="sd">    ...     return f&quot;{d}: {(x + y) * z}&quot;</span>
<span class="sd">    &gt;&gt;&gt; from dataclasses import dataclass</span>
<span class="sd">    &gt;&gt;&gt; @dataclass</span>
<span class="sd">    ... class Klass:</span>
<span class="sd">    ...     a : int = 1</span>
<span class="sd">    ...     c : int = 3</span>
<span class="sd">    ...     method_func = func_to_method_func(ch_names(func, x=&#39;a&#39;, z=&#39;c&#39;), &#39;a c&#39;)</span>
<span class="sd">    &gt;&gt;&gt; instance = Klass(1, 3)</span>
<span class="sd">    &gt;&gt;&gt; instance.method_func(2, d=&#39;hello&#39;)</span>
<span class="sd">    &#39;hello: 9&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get a signature object for func</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="c1"># if method_name not give, use the function&#39;s name</span>
    <span class="n">method_name</span> <span class="o">=</span> <span class="n">method_name</span> <span class="ow">or</span> <span class="n">sig</span><span class="o">.</span><span class="n">name</span>
    <span class="c1"># if params expressed as string, split it into a list of parameter (names)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instance_params</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">instance_params</span> <span class="o">=</span> <span class="n">instance_params</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method_params</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">method_params</span> <span class="o">=</span> <span class="n">method_params</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="c1"># if method_params is not given, take those parameters that aren&#39;t in instance_params</span>
    <span class="n">method_params</span> <span class="o">=</span> <span class="n">method_params</span> <span class="ow">or</span> <span class="nb">tuple</span><span class="p">(</span>
        <span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">names</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">instance_params</span>
    <span class="p">)</span>
    <span class="c1"># the Sig object of the method: instance name followed with method_params</span>
    <span class="n">method_sig</span> <span class="o">=</span> <span class="n">instance_arg_name</span> <span class="o">+</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)[</span><span class="n">method_params</span><span class="p">]</span>
    <span class="c1"># make the ingress function that will map method_sig&#39;s interface to sig&#39;s.</span>
    <span class="n">ingress</span> <span class="o">=</span> <span class="n">Ingress</span><span class="p">(</span>
        <span class="n">inner_sig</span><span class="o">=</span><span class="n">sig</span><span class="p">,</span>
        <span class="c1"># inside, foo will be doing the work, so need to map to its signature</span>
        <span class="n">kwargs_trans</span><span class="o">=</span><span class="n">partial</span><span class="p">(</span>
            <span class="c1"># this is how to transform outer (args, kwargs) to inner ones</span>
            <span class="n">kwargs_trans_to_extract_args_from_attrs</span><span class="p">,</span>
            <span class="n">attr_names</span><span class="o">=</span><span class="n">instance_params</span><span class="p">,</span>
            <span class="n">obj_param</span><span class="o">=</span><span class="n">instance_arg_name</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">outer_sig</span><span class="o">=</span><span class="n">method_sig</span><span class="p">,</span>  <span class="c1"># this is the signature we want at the interface</span>
    <span class="p">)</span>
    <span class="c1"># wrap the function, name it and return it</span>
    <span class="n">method_func</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">ingress</span><span class="o">=</span><span class="n">ingress</span><span class="p">)</span>
    <span class="n">method_func</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">method_name</span>
    <span class="k">return</span> <span class="n">method_func</span></div>


<div class="viewcode-block" id="bind_funcs_object_attrs"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.bind_funcs_object_attrs">[docs]</a><span class="k">def</span> <span class="nf">bind_funcs_object_attrs</span><span class="p">(</span>
    <span class="n">funcs</span><span class="p">,</span> <span class="n">init_params</span><span class="o">=</span><span class="p">(),</span> <span class="o">*</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transform one or several functions into a class that contains them as methods</span>
<span class="sd">    sourcing specific arguments from the instance&#39;s attributes.</span>

<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; from dataclasses import dataclass</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; def foo(a, b, c=2, *, d=&#39;bar&#39;):</span>
<span class="sd">    ...     return f&quot;{d}: {(a + b) * c}&quot;</span>
<span class="sd">    &gt;&gt;&gt; foo(1, 2)</span>
<span class="sd">    &#39;bar: 6&#39;</span>
<span class="sd">    &gt;&gt;&gt; Klass = bind_funcs_object_attrs(foo, init_params=&#39;a c&#39;)</span>
<span class="sd">    &gt;&gt;&gt; Klass.__name__</span>
<span class="sd">    &#39;Foo&#39;</span>
<span class="sd">    &gt;&gt;&gt; instance = Klass(a=1, c=3)</span>
<span class="sd">    &gt;&gt;&gt; assert instance.foo(2, d=&#39;hello&#39;) == &#39;hello: 9&#39; == foo(</span>
<span class="sd">    ...     a=1, b=2, c=3, d=&#39;hello&#39;)</span>
<span class="sd">    &gt;&gt;&gt; str(signature(Klass))</span>
<span class="sd">    &quot;(a: &#39;typing.Any&#39;, c: &#39;typing.Any&#39; = 2) -&gt; None&quot;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; instance = Klass(a=1, c=3)</span>
<span class="sd">    &gt;&gt;&gt; str(instance)</span>
<span class="sd">    &#39;Foo(a=1, c=3)&#39;</span>
<span class="sd">    &gt;&gt;&gt; str(signature(instance.foo))</span>
<span class="sd">    &quot;(b, *, d=&#39;bar&#39;)&quot;</span>
<span class="sd">    &gt;&gt;&gt; instance.foo(2, d=&#39;hello&#39;)</span>
<span class="sd">    &#39;hello: 9&#39;</span>
<span class="sd">    &gt;&gt;&gt; instance.foo(10, d=&#39;goodbye&#39;)</span>
<span class="sd">    &#39;goodbye: 33&#39;</span>

<span class="sd">    &gt;&gt;&gt; def foo(a, b, c):</span>
<span class="sd">    ...     return a + b * c</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; def bar(d, e):</span>
<span class="sd">    ...     return f&quot;{d=}, {e=}&quot;</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; @dataclass</span>
<span class="sd">    ... class K:</span>
<span class="sd">    ...     a: int</span>
<span class="sd">    ...     e: int</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; C = bind_funcs_object_attrs([foo, bar], &#39;a e&#39;, cls=K)</span>
<span class="sd">    &gt;&gt;&gt; str(signature(C))</span>
<span class="sd">    &#39;(a: int, e: int) -&gt; None&#39;</span>
<span class="sd">    &gt;&gt;&gt; c = C(1,2)</span>
<span class="sd">    &gt;&gt;&gt; assert str(signature(c.foo)) == &#39;(b, c)&#39;</span>
<span class="sd">    &gt;&gt;&gt; c.foo(3,4)</span>
<span class="sd">    13</span>
<span class="sd">    &gt;&gt;&gt; assert str(signature(c.bar)) == &#39;(d)&#39;</span>
<span class="sd">    &gt;&gt;&gt; c.bar(5)</span>
<span class="sd">    &#39;d=5, e=2&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init_params</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">init_params</span> <span class="o">=</span> <span class="n">init_params</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

    <span class="n">dflt_cls_name</span> <span class="o">=</span> <span class="s1">&#39;FuncsUnion&#39;</span>
    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">funcs</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="n">single_func</span> <span class="o">=</span> <span class="n">funcs</span>
        <span class="n">dflt_cls_name</span> <span class="o">=</span> <span class="n">camelize</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">single_func</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="n">dflt_cls_name</span><span class="p">))</span>
        <span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">single_func</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="c1"># if the class is not given, we need to make one</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">cls_name</span> <span class="o">=</span> <span class="bp">cls</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cls_name</span> <span class="o">=</span> <span class="n">dflt_cls_name</span>

        <span class="c1"># init_parameter_objects = Sig(func)[init_params].params</span>
        <span class="c1"># Make the signature for the init</span>
        <span class="n">class_init_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
            <span class="n">class_init_sig</span> <span class="o">=</span> <span class="n">class_init_sig</span><span class="o">.</span><span class="n">merge_with_sig</span><span class="p">(</span><span class="n">func</span><span class="p">)[</span><span class="n">init_params</span><span class="p">]</span>

        <span class="n">dataclass_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="n">param_to_dataclass_field_tuple</span><span class="p">,</span> <span class="n">class_init_sig</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">make_dataclass</span><span class="p">(</span><span class="n">cls_name</span><span class="p">,</span> <span class="n">dataclass_fields</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
        <span class="n">method_func</span> <span class="o">=</span> <span class="n">func_to_method_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">init_params</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">method_func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">method_func</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">cls</span></div>


<span class="k">def</span> <span class="nf">_items_filt</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>


<span class="k">def</span> <span class="nf">_mk_sig_from_params_and_funcs</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">funcs</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="k">pass</span>


<span class="c1">## An attempt to redo a func_to_method_func because I forgot func_to_method_func existed</span>
<span class="c1">## Has some different ideas, so keeping around until I decide it&#39;s time to let go.</span>
<span class="c1"># NoSuchKey = type(&#39;NoSuchKey&#39;, (), {})</span>
<span class="c1"># _instance_extractor: KwargsTrans</span>
<span class="c1">#</span>
<span class="c1"># # TODO: Add more (possibly optional) bind validation to fail early.</span>
<span class="c1"># def _instance_extractor(</span>
<span class="c1">#     outer_kwargs, bind: IdentifierMapping = (), instance_param: Identifier = &#39;self&#39;</span>
<span class="c1"># ):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#     :param outer_kwargs: The input/outer keyword arguments</span>
<span class="c1">#     :param bind: The inner-&gt;outer param mapping that defines what we want to extract</span>
<span class="c1">#     :param instance_param: The name of the outer_kwargs key that contains the &#39;instance&#39;</span>
<span class="c1">#         from which we&#39;ll extract the bound</span>
<span class="c1">#     :return:</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     &quot;&quot;&quot;A KwargsTrans that extracts need arguments from one of the &#39;instance&#39;</span>
<span class="c1">#     outer_kwargs values.</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     # Compute the inverse {outer:inner,...} of {inner:outer,...} bind</span>
<span class="c1">#     inv_bind = invert_map(bind)</span>
<span class="c1">#     outer_kwargs = outer_kwargs.copy()</span>
<span class="c1">#     instance = outer_kwargs.pop(instance_param)  # TODO: Better error handing</span>
<span class="c1">#</span>
<span class="c1">#     def gen():</span>
<span class="c1">#         for outer_param, outer_val in outer_kwargs.items():</span>
<span class="c1">#             if inner_param := inv_bind.get(outer_param, NoSuchKey) is not NoSuchKey:</span>
<span class="c1">#                 # if outer_param was bound, the bound inner_param should be tied to</span>
<span class="c1">#                 # the instance&#39;s attribute</span>
<span class="c1">#                 yield inner_param, getattr(instance, outer_val)</span>
<span class="c1">#             else:</span>
<span class="c1">#                 # take the arg name and val as is</span>
<span class="c1">#                 yield outer_param, outer_val</span>
<span class="c1">#</span>
<span class="c1">#     return dict(gen())</span>

<span class="c1">#</span>
<span class="c1"># def methodize(func, bind: Bind = ()):</span>
<span class="c1">#     bind = identifier_mapping(bind)</span>
<span class="c1">#     ingress = Ingress(</span>
<span class="c1">#         outer_sig=Sig(func),</span>
<span class="c1">#         kwargs_trans=partial(_instance_extractor, bind=bind),</span>
<span class="c1">#         inner_sig=Sig(&#39;self&#39;) + Sig(func) - Sig(list(bind)),  # TODO: solve type or lint</span>
<span class="c1">#     )</span>
<span class="c1">#     return wrap(func, ingress=ingress)</span>


<span class="c1"># ---------------------------------------------------------------------------------------</span>
<span class="c1"># Extended Wrapper class</span>

<span class="kn">from</span> <span class="nn">i2</span> <span class="kn">import</span> <span class="n">call_forgivingly</span>


<div class="viewcode-block" id="WrapperValidationError"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.WrapperValidationError">[docs]</a><span class="k">class</span> <span class="nc">WrapperValidationError</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised when wrapper some construction params are not valid&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="EgressValidationError"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.EgressValidationError">[docs]</a><span class="k">class</span> <span class="nc">EgressValidationError</span><span class="p">(</span><span class="n">WrapperValidationError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised when a egress is not valid&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="IngressValidationError"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.IngressValidationError">[docs]</a><span class="k">class</span> <span class="nc">IngressValidationError</span><span class="p">(</span><span class="n">WrapperValidationError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised when a ingress is not valid&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="CallerValidationError"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.CallerValidationError">[docs]</a><span class="k">class</span> <span class="nc">CallerValidationError</span><span class="p">(</span><span class="n">WrapperValidationError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raised when a caller is not valid&quot;&quot;&quot;</span></div>


<span class="k">def</span> <span class="nf">_default_ingress</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span>


<span class="k">def</span> <span class="nf">_default_egress</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="o">**</span><span class="n">egress_params</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">output</span>


<span class="k">def</span> <span class="nf">_default_caller</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="n">_keyword_kinds</span> <span class="o">=</span> <span class="p">{</span><span class="n">Sig</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span><span class="p">,</span> <span class="n">Sig</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">_all_kinds_are_keyword_only_or_variadic_keyword</span><span class="p">(</span><span class="n">sig</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">kind</span> <span class="ow">in</span> <span class="n">_keyword_kinds</span> <span class="k">for</span> <span class="n">kind</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">kinds</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">3</span><span class="p">:])</span>


<span class="c1"># TODO: Factor out more common parts with Wrap and reuse (possibly through _Wrap)</span>
<div class="viewcode-block" id="Wrapx"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.Wrapx">[docs]</a><span class="k">class</span> <span class="nc">Wrapx</span><span class="p">(</span><span class="n">_Wrap</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">ingress</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">egress</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">caller</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;An extended wrapping object that allows more complex wrapping mechanisms.</span>

<span class="sd">        :param func: The wrapped function</span>
<span class="sd">        :param ingress: The incoming data transformer. It determines the argument properties</span>
<span class="sd">            (name, kind, default and annotation) as well as the actual input of the</span>
<span class="sd">            wrapped function.</span>
<span class="sd">        :param egress: The outgoing data transformer. It also takes precedence over the</span>
<span class="sd">            wrapped function to determine the return annotation of the ``Wrap`` instance</span>
<span class="sd">        :param caller: A caller defines what it means to call the ``func`` on the</span>
<span class="sd">            arguments it is given. It should be of the form</span>
<span class="sd">            ``caller(func, args, kwargs, *, ...extra_keyword_only_params)``.</span>
<span class="sd">            By default, the caller will simply return ``func(*args, **kwargs)``.</span>
<span class="sd">        :param name: Name to give the wrapper (will use wrapped func name by default)</span>

<span class="sd">        :return: A callable instance wrapping ``func``</span>

<span class="sd">        &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; def func(x, y):</span>
<span class="sd">        ...     return x + y</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; def save_on_output_egress(v, *, k, s):</span>
<span class="sd">        ...     s[k] = v</span>
<span class="sd">        ...     return v</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; save_on_output = Wrapx(func, egress=save_on_output_egress)</span>
<span class="sd">        &gt;&gt;&gt; # TODO: should be `(x, y, *, k, s)` --&gt; Need to work on the merge for this.</span>
<span class="sd">        &gt;&gt;&gt; str(signature(save_on_output))</span>
<span class="sd">        &#39;(x, y, k, s)&#39;</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; store = dict()</span>
<span class="sd">        &gt;&gt;&gt; save_on_output(1, 2, k=&#39;save_here&#39;, s=store)</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; assert save_on_output(1, 2, k=&#39;save_here&#39;, s=store) == 3 == func(1, 2)</span>
<span class="sd">        &gt;&gt;&gt; store  # see what&#39;s in the store now!</span>
<span class="sd">        {&#39;save_here&#39;: 3}</span>

<span class="sd">        A caller is meant to control the way the function is called.</span>
<span class="sd">        It is given the ``func`` and the ``func_args`` and ``func_kwargs``</span>
<span class="sd">        (whatever the ingress function gives it, if present) and possibly additional</span>
<span class="sd">        params and will return... well, what ever you tell it to.</span>

<span class="sd">        This can be used, for example, to call the function in a subprocess,</span>
<span class="sd">        or on a remote system, differ computation (command pattern, for example, using</span>
<span class="sd">        ``functools.partial``, or do what ever needs to have a view both on the function</span>
<span class="sd">        and its inputs.</span>

<span class="sd">        Here, we will wrap the function so it will apply to an iterable of inputs</span>
<span class="sd">        (of the first argument), returning a list of results</span>

<span class="sd">        &gt;&gt;&gt; def func(x, y=2):</span>
<span class="sd">        ...     return x + y</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; def iterize(func, args, kwargs):</span>
<span class="sd">        ...     first_arg_val = next(iter(kwargs.values()))</span>
<span class="sd">        ...     return list(map(func, first_arg_val))</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; iterized_func = Wrapx(func, caller=iterize)</span>
<span class="sd">        &gt;&gt;&gt; iterized_func([1, 2, 3, 4])</span>
<span class="sd">        [3, 4, 5, 6]</span>

<span class="sd">        Let&#39;s do the same as above, but allow other variables (here ``y``) to be input as</span>
<span class="sd">        well. This takes a bit more work...</span>

<span class="sd">        &gt;&gt;&gt; from functools import partial</span>
<span class="sd">        &gt;&gt;&gt; def _iterize_first_arg(func, args, kwargs):</span>
<span class="sd">        ...     first_arg_name = next(iter(kwargs))</span>
<span class="sd">        ...     remaining_kwargs = {</span>
<span class="sd">        ...         k: v for k, v in kwargs.items() if k != first_arg_name</span>
<span class="sd">        ...     }</span>
<span class="sd">        ...     return list(</span>
<span class="sd">        ...         map(partial(func, **remaining_kwargs), kwargs[first_arg_name])</span>
<span class="sd">        ...     )</span>

<span class="sd">        Let&#39;s demo a different way of using Wrapx: Making a wrapper to apply at</span>
<span class="sd">        function definition time</span>

<span class="sd">        &gt;&gt;&gt; iterize_first_arg = partial(Wrapx, caller=_iterize_first_arg)</span>
<span class="sd">        &gt;&gt;&gt; @iterize_first_arg</span>
<span class="sd">        ... def func(x, y):</span>
<span class="sd">        ...     return x + y</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; func([1, 2, 3, 4], 10)</span>
<span class="sd">        [11, 12, 13, 14]</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">ingress</span><span class="p">,</span> <span class="n">egress</span><span class="p">,</span> <span class="n">caller</span><span class="o">=</span><span class="n">caller</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ingress</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">egress</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">caller</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span> <span class="o">=</span> <span class="n">_process_wrapx_params</span><span class="p">(</span>
            <span class="n">func</span><span class="p">,</span> <span class="n">ingress</span><span class="p">,</span> <span class="n">egress</span><span class="p">,</span> <span class="n">caller</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__wrapped__</span> <span class="o">=</span> <span class="n">func</span>
        <span class="c1"># TODO: Pros and cons analysis of pointing __wrapped__ to func. partial uses</span>
        <span class="c1">#  .func, but wraps looks for __wrapped__</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># TODO: Consider call_forgivingly(self.ingress, *args, **kwargs)</span>
            <span class="c1">#  because call_forgivingly(self.ingress, **_kwargs) doesn&#39;t allow</span>
            <span class="c1">#  same ingress functions to be used for Wrap and Wrapx</span>
            <span class="n">func_args</span><span class="p">,</span> <span class="n">func_kwargs</span> <span class="o">=</span> <span class="n">call_forgivingly</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ingress</span><span class="p">,</span> <span class="o">**</span><span class="n">_kwargs</span><span class="p">)</span>
            <span class="n">inner_output</span> <span class="o">=</span> <span class="n">call_forgivingly</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">caller</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="n">func_args</span><span class="p">,</span> <span class="n">func_kwargs</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">call_forgivingly</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">egress</span><span class="p">,</span> <span class="n">inner_output</span><span class="p">,</span> <span class="o">**</span><span class="n">_kwargs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Try running again, but with more careful validation, to try to give</span>
            <span class="c1"># more specific error messages</span>
            <span class="c1"># We don&#39;t do this in the first run so that we don&#39;t incur the validation</span>
            <span class="c1"># overhead on every call.</span>
            <span class="n">_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
            <span class="n">func_args</span><span class="p">,</span> <span class="n">func_kwargs</span> <span class="o">=</span> <span class="n">_validate_ingress_output</span><span class="p">(</span>
                <span class="n">call_forgivingly</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ingress</span><span class="p">,</span> <span class="o">**</span><span class="n">_kwargs</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">inner_output</span> <span class="o">=</span> <span class="n">call_forgivingly</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">func_args</span><span class="p">,</span> <span class="o">**</span><span class="n">func_kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">call_forgivingly</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">egress</span><span class="p">,</span> <span class="n">inner_output</span><span class="p">,</span> <span class="o">**</span><span class="n">_kwargs</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_validate_ingress_output</span><span class="p">(</span><span class="n">ingress_output</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ingress_output</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
        <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">ingress_output</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ingress_output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">)</span>
        <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ingress_output</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">dict</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="n">IngressValidationError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;An ingress function should return a (tuple, dict) pair. &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;This ingress function returned: </span><span class="si">{</span><span class="n">ingress_output</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">ingress_output</span>


<span class="k">def</span> <span class="nf">_process_wrapx_params</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">ingress</span><span class="p">,</span> <span class="n">egress</span><span class="p">,</span> <span class="n">caller</span><span class="p">):</span>
    <span class="n">func_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

    <span class="n">ingress</span><span class="p">,</span> <span class="n">ingress_sig</span> <span class="o">=</span> <span class="n">_init_ingress</span><span class="p">(</span><span class="n">func_sig</span><span class="p">,</span> <span class="n">ingress</span><span class="p">)</span>
    <span class="n">egress</span><span class="p">,</span> <span class="n">egress_sig</span> <span class="o">=</span> <span class="n">_init_egress</span><span class="p">(</span><span class="n">func_sig</span><span class="p">,</span> <span class="n">egress</span><span class="p">)</span>
    <span class="n">caller</span><span class="p">,</span> <span class="n">caller_sig</span> <span class="o">=</span> <span class="n">_init_caller</span><span class="p">(</span><span class="n">caller</span><span class="p">)</span>

    <span class="n">sig</span> <span class="o">=</span> <span class="n">_mk_composite_sig</span><span class="p">(</span><span class="n">ingress_sig</span><span class="p">,</span> <span class="n">egress_sig</span><span class="p">,</span> <span class="n">caller_sig</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ingress</span><span class="p">,</span> <span class="n">egress</span><span class="p">,</span> <span class="n">caller</span><span class="p">,</span> <span class="n">sig</span>


<span class="k">def</span> <span class="nf">_mk_composite_sig</span><span class="p">(</span><span class="n">ingress_sig</span><span class="p">,</span> <span class="n">egress_sig</span><span class="p">,</span> <span class="n">caller_sig</span><span class="p">):</span>
    <span class="n">egress_sig_minus_first_arg</span> <span class="o">=</span> <span class="n">egress_sig</span> <span class="o">-</span> <span class="n">egress_sig</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">caller_sig_minus_three_first_args</span> <span class="o">=</span> <span class="n">caller_sig</span> <span class="o">-</span> <span class="n">caller_sig</span><span class="o">.</span><span class="n">names</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span>
        <span class="n">ingress_sig</span> <span class="o">+</span> <span class="n">egress_sig_minus_first_arg</span> <span class="o">+</span> <span class="n">caller_sig_minus_three_first_args</span><span class="p">,</span>
        <span class="n">return_annotation</span><span class="o">=</span><span class="n">egress_sig</span><span class="o">.</span><span class="n">return_annotation</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">sig</span>


<span class="k">def</span> <span class="nf">_init_caller</span><span class="p">(</span><span class="n">caller</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">caller</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">caller</span> <span class="o">=</span> <span class="n">_default_caller</span>
        <span class="n">caller_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;func args kwargs&#39;</span><span class="p">)</span>  <span class="c1"># sig with three inputs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">caller_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">caller</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">caller_sig</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CallerValidationError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;A caller must have at least three arguments: &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">caller</span><span class="si">}</span><span class="s1"> signature was </span><span class="si">{</span><span class="n">caller_sig</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_all_kinds_are_keyword_only_or_variadic_keyword</span><span class="p">(</span><span class="n">caller_sig</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">CallerValidationError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;A caller must have at least three arguments&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">caller</span><span class="si">}</span><span class="s1"> signature was </span><span class="si">{</span><span class="n">caller_sig</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">caller</span><span class="p">,</span> <span class="n">caller_sig</span>


<span class="k">def</span> <span class="nf">_init_egress</span><span class="p">(</span><span class="n">func_sig</span><span class="p">,</span> <span class="n">egress</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">egress</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">egress</span> <span class="o">=</span> <span class="n">_default_egress</span>
        <span class="c1"># signature with a single &#39;output&#39; arg and func_sig&#39;s return_annotation</span>
        <span class="n">egress_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">func_sig</span><span class="o">.</span><span class="n">return_annotation</span><span class="p">)</span>
        <span class="n">return_annotation</span> <span class="o">=</span> <span class="n">func_sig</span><span class="o">.</span><span class="n">return_annotation</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">egress_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span>
            <span class="n">egress</span><span class="p">,</span>
            <span class="c1"># if egress has no return_annotation, use the func_sig&#39;s one.</span>
            <span class="c1"># TODO: Is this really correct/safe? What if egress changes the type?</span>
            <span class="n">return_annotation</span><span class="o">=</span><span class="n">Sig</span><span class="p">(</span><span class="n">egress</span><span class="p">)</span><span class="o">.</span><span class="n">return_annotation</span>
            <span class="ow">or</span> <span class="n">func_sig</span><span class="o">.</span><span class="n">return_annotation</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">egress</span><span class="p">,</span> <span class="n">egress_sig</span>


<span class="k">def</span> <span class="nf">_init_ingress</span><span class="p">(</span><span class="n">func_sig</span><span class="p">,</span> <span class="n">ingress</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">ingress</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ingress</span> <span class="o">=</span> <span class="n">_default_ingress</span>
        <span class="n">ingress_sig</span> <span class="o">=</span> <span class="n">func_sig</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ingress_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">ingress</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ingress</span><span class="p">,</span> <span class="n">ingress_sig</span>


<span class="c1"># ---------------------------------------------------------------------------------------</span>
<span class="c1"># partialx</span>


<div class="viewcode-block" id="partialx"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.partialx">[docs]</a><span class="k">def</span> <span class="nf">partialx</span><span class="p">(</span>
    <span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="vm">__name__</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_rm_partialize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">_allow_reordering</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extends the functionality of builtin ``functools.partial`` with the ability to</span>

<span class="sd">    - set ``__name__ ``</span>

<span class="sd">    - remove partialized arguments from signature</span>

<span class="sd">    - reorder params (so that defaults are at the end)</span>

<span class="sd">    &gt;&gt;&gt; def f(a, b=2, c=3):</span>
<span class="sd">    ...     return a + b * c</span>
<span class="sd">    &gt;&gt;&gt; curried_f = partialx(f, c=10, _rm_partialize=True)</span>
<span class="sd">    &gt;&gt;&gt; curried_f.__name__</span>
<span class="sd">    &#39;f&#39;</span>
<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; str(signature(curried_f))</span>
<span class="sd">    &#39;(a, b=2)&#39;</span>

<span class="sd">    &gt;&gt;&gt; def f(a, b, c=3):</span>
<span class="sd">    ...     return a + b * c</span>

<span class="sd">    Note that ``a`` gets a default, but ``b`` does not, yet is after ``a``.</span>
<span class="sd">    This is allowed because these parameters all became KEYWORD_ONLY.</span>

<span class="sd">    &gt;&gt;&gt; g = partialx(f, a=1)</span>
<span class="sd">    &gt;&gt;&gt; str(Sig(g))</span>
<span class="sd">    &#39;(*, a=1, b, c=3)&#39;</span>

<span class="sd">    If you wanted to reorder the parameters to have all defaulted kinds be at the end,</span>
<span class="sd">    as usual, you can do so using ``_allow_reordering=True``</span>

<span class="sd">    &gt;&gt;&gt; g = partialx(f, a=1, _allow_reordering=True)</span>
<span class="sd">    &gt;&gt;&gt; str(Sig(g))</span>
<span class="sd">    &#39;(*, b, a=1, c=3)&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_rm_partialize</span><span class="p">:</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="n">partialized</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">allow_partial</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">-</span> <span class="n">partialized</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">sig</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">_allow_reordering</span><span class="p">:</span>
        <span class="c1"># TODO: Instead of Sig(f).defaults, move only params that need to move</span>
        <span class="c1"># TODO: + Change signature so that the number of params that become keyword-only</span>
        <span class="c1">#   is minimize.</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">move_params_to_the_end</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">Sig</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">defaults</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="vm">__name__</span> <span class="ow">or</span> <span class="n">name_of_obj</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f</span></div>


<div class="viewcode-block" id="move_params_to_the_end"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.move_params_to_the_end">[docs]</a><span class="k">def</span> <span class="nf">move_params_to_the_end</span><span class="p">(</span>
    <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">names_to_move</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Choose args from func, according to choice_args_func and move them</span>
<span class="sd">    to the right</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; from i2 import Sig</span>
<span class="sd">    &gt;&gt;&gt; def foo(a, b, c):</span>
<span class="sd">    ...     return a + b + c</span>
<span class="sd">    &gt;&gt;&gt; g = partial(foo, b=4)  # fixing a, which is before b</span>
<span class="sd">    &gt;&gt;&gt; h = move_params_to_the_end(g, Sig(g).defaults)</span>
<span class="sd">    &gt;&gt;&gt; assert str(Sig(g)) == &#39;(a, *, b=4, c)&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert str(Sig(h)) == &#39;(a, *, c, b=4)&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">names_to_move</span><span class="p">):</span>
        <span class="n">names_to_move</span> <span class="o">=</span> <span class="n">names_to_move</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names_to_move</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">),</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s1">&#39;names_to_move must be an iterable of names &#39;</span>
        <span class="sa">f</span><span class="s1">&#39;or a callable producing one from a function. Was </span><span class="si">{</span><span class="n">names_to_move</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="p">)</span>

    <span class="n">names</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">names</span>
    <span class="n">reordered</span> <span class="o">=</span> <span class="n">move_names_to_the_end</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">names_to_move</span><span class="p">)</span>
    <span class="n">wrapped_func</span> <span class="o">=</span> <span class="n">include_exclude</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="n">reordered</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapped_func</span></div>


<div class="viewcode-block" id="move_names_to_the_end"><a class="viewcode-back" href="../../module_docs/i2/wrapper.html#i2.wrapper.move_names_to_the_end">[docs]</a><span class="k">def</span> <span class="nf">move_names_to_the_end</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">names_to_move_to_the_end</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove the items of ``names_to_move_to_the_end`` from ``names``</span>
<span class="sd">    and append to the right of names</span>

<span class="sd">    &gt;&gt;&gt; names = [&#39;a&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]</span>
<span class="sd">    &gt;&gt;&gt; names_to_move_to_the_end = [&#39;c&#39;,&#39;e&#39;]</span>
<span class="sd">    &gt;&gt;&gt; move_names_to_the_end(names, names_to_move_to_the_end)</span>
<span class="sd">    [&#39;a&#39;, &#39;d&#39;, &#39;c&#39;, &#39;e&#39;]</span>
<span class="sd">    &gt;&gt;&gt; names_to_move_to_the_end = &#39;c e&#39;</span>
<span class="sd">    &gt;&gt;&gt; move_names_to_the_end(names, names_to_move_to_the_end)</span>
<span class="sd">    [&#39;a&#39;, &#39;d&#39;, &#39;c&#39;, &#39;e&#39;]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names_to_move_to_the_end</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">names_to_move_to_the_end</span> <span class="o">=</span> <span class="n">names_to_move_to_the_end</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">names_to_move_to_the_end</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">names_to_move_to_the_end</span><span class="p">)</span>
    <span class="n">removed</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">names</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names_to_move_to_the_end</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">removed</span><span class="p">)</span> <span class="o">+</span> <span class="n">names_to_move_to_the_end</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright OtoSense 2020.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
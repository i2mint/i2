<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>i2.deco &mdash; i2 0.0.152 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/toggleprompt.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> i2
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2.html">i2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/_deprecated.html">i2._deprecated</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/base.html">i2.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/chain_map.html">i2.chain_map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/deco.html">i2.deco</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/doc_mint.html">i2.doc_mint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/errors.html">i2.errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/examples.html">i2.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/examples/signature_calculus.html">i2.examples.signature_calculus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/footprints.html">i2.footprints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/io_trans.html">i2.io_trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/itypes.html">i2.itypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/key_path.html">i2.key_path</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/multi_object.html">i2.multi_object</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/routing_forest.html">i2.routing_forest</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/scrap.html">i2.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/scrap/scrap.html">i2.scrap.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/scrap/scrap_ch_variadics.html">i2.scrap.scrap_ch_variadics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/scrap/scrap_kwargs.html">i2.scrap.scrap_kwargs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/scrap/simple_pymint.html">i2.scrap.simple_pymint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/signatures.html">i2.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/switch_case_tree.html">i2.switch_case_tree</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests.html">i2.tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/footprints_test.html">i2.tests.footprints_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/objects_for_testing.html">i2.tests.objects_for_testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/signatures_test.html">i2.tests.signatures_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/test_util.html">i2.tests.test_util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/util.html">i2.tests.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/wrapper_test.html">i2.tests.wrapper_test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/util.html">i2.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/wrapper.html">i2.wrapper</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">i2</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>i2.deco</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for i2.deco</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Decorator tools&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">suppress</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span><span class="p">,</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Signature</span><span class="p">,</span> <span class="n">signature</span><span class="p">,</span> <span class="n">Parameter</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">TypeVar</span>

<span class="kn">from</span> <span class="nn">i2.signatures</span> <span class="kn">import</span> <span class="n">Sig</span><span class="p">,</span> <span class="n">kind_forgiving_func</span><span class="p">,</span> <span class="n">name_of_obj</span>

<span class="c1"># keep the imports below here because might be referenced (or take care of refs)</span>
<span class="c1"># from i2.signatures import ch_signature_to_all_pk, params_of, copy_func</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>  <span class="c1"># Can be anything</span>


<span class="k">def</span> <span class="nf">identity</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">obj</span>


<span class="c1"># ---------------------------------------------------------------------------------------</span>
<span class="c1"># The following is an exact copy of the `functools.wraps`, but for some reason, it</span>
<span class="c1"># solves an issue of double_up_as_factory on jypyter.</span>
<span class="c1"># See description of problem here:</span>
<span class="c1"># https://stackoverflow.com/questions/73243479/mysterious-effect-a-decorator-that-breaks-juypyters-ability-to-tab-complete-a</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">WRAPPER_ASSIGNMENTS</span><span class="p">,</span> <span class="n">WRAPPER_UPDATES</span><span class="p">,</span> <span class="n">update_wrapper</span>


<span class="k">def</span> <span class="nf">wraps</span><span class="p">(</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">assigned</span><span class="o">=</span><span class="n">WRAPPER_ASSIGNMENTS</span><span class="p">,</span> <span class="n">updated</span><span class="o">=</span><span class="n">WRAPPER_UPDATES</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">update_wrapper</span><span class="p">,</span> <span class="n">wrapped</span><span class="o">=</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">assigned</span><span class="o">=</span><span class="n">assigned</span><span class="p">,</span> <span class="n">updated</span><span class="o">=</span><span class="n">updated</span><span class="p">)</span>


<span class="c1"># ---------------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="FuncFactory"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.FuncFactory">[docs]</a><span class="k">class</span> <span class="nc">FuncFactory</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Make a function factory.</span>

<span class="sd">    but more convenient and helpful (e.g. is picklable, produces functions with</span>
<span class="sd">    signatures, etc.)</span>

<span class="sd">    One can use ``functools.partials`` to fix, or change, the defaults of</span>
<span class="sd">    arguments of a function ``func`` thereby creating a different function.</span>

<span class="sd">    &gt;&gt;&gt; def foo(a, b, *, c=2) -&gt; float:</span>
<span class="sd">    ...     return a * b + c</span>
<span class="sd">    &gt;&gt;&gt; foo(10, 2)</span>
<span class="sd">    22</span>
<span class="sd">    &gt;&gt;&gt; foo(10, b=2, c=3)</span>
<span class="sd">    23</span>
<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; new_foo = partial(foo, b=2, c=3)  # change default c=3 and add one: b=2</span>
<span class="sd">    &gt;&gt;&gt; new_foo(10)  # now the function can be called with one argument (couldn&#39;t before)</span>
<span class="sd">    23</span>

<span class="sd">    In essence, ``FuncFactory`` is equivalent to:</span>

<span class="sd">    ```</span>
<span class="sd">    FuncFactory = lambda func: lambda *args, **kwargs: partial(func, *args, **kwargs)</span>
<span class="sd">    ```</span>

<span class="sd">    but more convenient and helpful. For one, it doesn&#39;t use ``lambda``, so is picklable.</span>
<span class="sd">    It also has a more helpful signature:</span>

<span class="sd">    &gt;&gt;&gt; factory = FuncFactory(foo)</span>
<span class="sd">    &gt;&gt;&gt; factory</span>
<span class="sd">    &lt;FuncFactory(foo)&gt;(b, *, c=2) -&gt; Callable[..., float]</span>

<span class="sd">    (Note that the repr even reuses ``foo``&#39;s return annotation to tell us that our</span>
<span class="sd">    factory will return a callable that returns that type (if the annotation is a type).</span>

<span class="sd">    An instance of ``FuncFactory`` is a factory of functions, that is, it can make</span>
<span class="sd">    functions for you based on the instance&#39;s underlying ``func``:</span>

<span class="sd">    &gt;&gt;&gt; f = factory(b=2, c=3)</span>
<span class="sd">    &gt;&gt;&gt; f(10)</span>
<span class="sd">    23</span>

<span class="sd">    Recipe: Say you&#39;re normalizing some data accessor into callback functions and you</span>
<span class="sd">    want to create functions that provide a specific object when called (with no args).</span>
<span class="sd">    Sure, you can do this by specifying ``lambda: obj`` every time, but lambdas can be</span>
<span class="sd">    problematic (e.g. their not picklable).</span>

<span class="sd">    Here&#39;s another solution:</span>

<span class="sd">    &gt;&gt;&gt; def identity(obj):</span>
<span class="sd">    ...     return obj</span>
<span class="sd">    &gt;&gt;&gt; func_returning_obj = FuncFactory(identity)</span>
<span class="sd">    &gt;&gt;&gt; get_42 = func_returning_obj(42)</span>
<span class="sd">    &gt;&gt;&gt; get_42()</span>
<span class="sd">    42</span>

<span class="sd">    Note: A convenience property has been added to implement this recipe:</span>

<span class="sd">    &gt;&gt;&gt; get_42, get_hello = map(FuncFactory.func_returning_obj, (42, &#39;hello&#39;))</span>
<span class="sd">    &gt;&gt;&gt; get_42()</span>
<span class="sd">    42</span>
<span class="sd">    &gt;&gt;&gt; get_hello()</span>
<span class="sd">    &#39;hello&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>

        <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="n">factory_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-</span> <span class="n">sig</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sig</span><span class="o">.</span><span class="n">return_annotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">sig</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">factory_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span>
                    <span class="n">factory_sig</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">sig</span><span class="o">.</span><span class="n">return_annotation</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">factory_sig</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&lt;FuncFactory(</span><span class="si">{</span><span class="n">name_of_obj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">)</span><span class="si">}</span><span class="s1">)&gt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__signature__</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">func_returning_obj</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">identity</span><span class="p">)(</span><span class="n">obj</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_double_up_as_factory</span><span class="p">(</span><span class="n">wrapped</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">__decorator_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Util for double_up_as_factory, ``__decorator_func`` to be partialized&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;You need to specify decorator arguments as keyword-only.&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;You specified positional arguments: </span><span class="si">{</span><span class="n">args</span><span class="si">=}</span><span class="s1">&#39;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># then we want a factory</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">__decorator_func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">__decorator_func</span><span class="p">(</span><span class="n">wrapped</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<div class="viewcode-block" id="double_up_as_factory"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.double_up_as_factory">[docs]</a><span class="k">def</span> <span class="nf">double_up_as_factory</span><span class="p">(</span><span class="n">decorator_func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Repurpose a decorator both as it&#39;s original form, and as a decorator factory.</span>
<span class="sd">    That is, from a decorator that is defined do ``wrapped_func = decorator(func, **params)``,</span>
<span class="sd">    make it also be able to do ``wrapped_func = decorator(**params)(func)``.</span>

<span class="sd">    Note: You&#39;ll only be able to do this if all but the first argument are keyword-only,</span>
<span class="sd">    and the first argument (the function to decorate) has a default of ``None`` (this is for your own good).</span>
<span class="sd">    This is validated before making the &quot;double up as factory&quot; decorator.</span>

<span class="sd">    &gt;&gt;&gt; @double_up_as_factory</span>
<span class="sd">    ... def decorator(func=None, *, multiplier=2):</span>
<span class="sd">    ...     def _func(x):</span>
<span class="sd">    ...         return func(x) * multiplier</span>
<span class="sd">    ...     return _func</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; def foo(x):</span>
<span class="sd">    ...     return x + 1</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; foo(2)</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; wrapped_foo = decorator(foo, multiplier=10)</span>
<span class="sd">    &gt;&gt;&gt; wrapped_foo(2)</span>
<span class="sd">    30</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; multiply_by_3 = decorator(multiplier=3)</span>
<span class="sd">    &gt;&gt;&gt; wrapped_foo = multiply_by_3(foo)</span>
<span class="sd">    &gt;&gt;&gt; wrapped_foo(2)</span>
<span class="sd">    9</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; @decorator(multiplier=3)</span>
<span class="sd">    ... def foo(x):</span>
<span class="sd">    ...     return x + 1</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; foo(2)</span>
<span class="sd">    9</span>

<span class="sd">    Note that to be able to use double_up_as_factory, your first argument (the object to be wrapped) needs to default</span>
<span class="sd">    to None and be the only argument that is not keyword-only (i.e. all other arguments need to be keyword only).</span>

<span class="sd">    &gt;&gt;&gt; @double_up_as_factory</span>
<span class="sd">    ... def decorator_2(func, *, multiplier=2):</span>
<span class="sd">    ...     &#39;&#39;&#39;Should not be able to be transformed with double_up_as_factory&#39;&#39;&#39;</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    AssertionError: First argument of the decorator function needs to default to None. Was &lt;class &#39;inspect._empty&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; @double_up_as_factory</span>
<span class="sd">    ... def decorator_3(func=None, multiplier=2):</span>
<span class="sd">    ...     &#39;&#39;&#39;Should not be able to be transformed with double_up_as_factory&#39;&#39;&#39;</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    AssertionError: All arguments (besides the first) need to be keyword-only</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">validate_decorator_func</span><span class="p">(</span><span class="n">decorator_func</span><span class="p">):</span>
        <span class="n">first_param</span><span class="p">,</span> <span class="o">*</span><span class="n">other_params</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">decorator_func</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">first_param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;First argument of the decorator function needs to default to None. &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;Was </span><span class="si">{</span><span class="n">first_param</span><span class="o">.</span><span class="n">default</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">}</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">other_params</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;All arguments (besides the first) need to be keyword-only&#39;</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="n">validate_decorator_func</span><span class="p">(</span><span class="n">decorator_func</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wraps</span><span class="p">(</span><span class="n">decorator_func</span><span class="p">)(</span>
        <span class="n">partial</span><span class="p">(</span><span class="n">_double_up_as_factory</span><span class="p">,</span> <span class="n">__decorator_func</span><span class="o">=</span><span class="n">decorator_func</span><span class="p">)</span>
    <span class="p">)</span></div>


<span class="c1"># TODO: Review, doc, and make public.</span>
<span class="c1">#   Namely, it may be cleaner to have the `argname=argtrans, ...` interface</span>
<span class="c1">#   and offer utils to make an argtrans be the combination of a condition and a trans!</span>
<span class="nd">@double_up_as_factory</span>
<span class="k">def</span> <span class="nf">_conditional_arg_trans</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">condition_and_trans_of_argname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    See also: ensure_iterable_args, for a more complex example of how to use it.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">argname</span><span class="p">,</span> <span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span> <span class="ow">in</span> <span class="n">condition_and_trans_of_argname</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">argname</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">condition</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">argname</span><span class="p">]):</span>
                <span class="c1"># Note: Using tuple instead of list because quicker &amp; safer (non-mutable)</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">argname</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">argname</span><span class="p">])</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_func</span>


<span class="k">def</span> <span class="nf">_tuplize</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span>


<span class="k">def</span> <span class="nf">_mk_type_condition</span><span class="p">(</span><span class="n">condition</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;If condition is a type, make an isinstance function to check for that type&quot;&quot;&quot;</span>
    <span class="n">curryable_isinstance</span> <span class="o">=</span> <span class="n">kind_forgiving_func</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">type_condition</span> <span class="o">=</span> <span class="n">condition</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">curryable_isinstance</span><span class="p">,</span> <span class="n">class_or_tuple</span><span class="o">=</span><span class="n">type_condition</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">condition</span>


<div class="viewcode-block" id="ensure_iterable_args"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.ensure_iterable_args">[docs]</a><span class="k">def</span> <span class="nf">ensure_iterable_args</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">condition_of_argname</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrap a function so that specific arguments are assured to be iterable if</span>
<span class="sd">    they meet specific conditions.</span>

<span class="sd">    The condition, in the example below, is being a string.</span>
<span class="sd">    Note that in general, the condition needs to be a boolean function.</span>
<span class="sd">    The explicit form of our example would say `names=lambda x: isinstance(x, str)`,</span>
<span class="sd">    but `ensure_iterable_args` allows the convenience of just specifying the type,</span>
<span class="sd">    or a tuple of types, and the actually boolean function will be made for you.</span>

<span class="sd">    &gt;&gt;&gt; @ensure_iterable_args(names=str)</span>
<span class="sd">    ... def greet_people(names, greeting=&#39;Hello&#39;):</span>
<span class="sd">    ...     for name in names:</span>
<span class="sd">    ...         yield f&quot;{greeting} {name}!&quot;</span>
<span class="sd">    &gt;&gt;&gt; assert list(greet_people([&#39;Alice&#39;, &#39;Bob&#39;])) == [&#39;Hello Alice!&#39;, &#39;Hello Bob!&#39;]</span>
<span class="sd">    &gt;&gt;&gt; assert list(greet_people(&#39;Alice&#39;)) == [&#39;Hello Alice!&#39;]</span>

<span class="sd">    Note that to decorate a function, you can also use the form:</span>

<span class="sd">    &gt;&gt;&gt; greet_people = ensure_iterable_args(greet_people, names=str)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">condition_and_trans_of_argname</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">argname</span><span class="p">:</span> <span class="p">(</span><span class="n">_mk_type_condition</span><span class="p">(</span><span class="n">condition</span><span class="p">),</span> <span class="n">_tuplize</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">argname</span><span class="p">,</span> <span class="n">condition</span> <span class="ow">in</span> <span class="n">condition_of_argname</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">_conditional_arg_trans</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">condition_and_trans_of_argname</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">transparently_wrapped</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">transparently_wrapped_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">transparently_wrapped_func</span>


<div class="viewcode-block" id="mk_args_kwargs_merger"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.mk_args_kwargs_merger">[docs]</a><span class="k">def</span> <span class="nf">mk_args_kwargs_merger</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a function that will return a dict containing all {argname: argval} pairs from a function&#39;s call.</span>
<span class="sd">    That is, it merges all non-keyword arguments with the keyword-arguments, with the right name, so that</span>
<span class="sd">    the arguments can be handled more uniformly.</span>
<span class="sd">    :param func: The function that will be called, whose signature should be looked at to make the</span>
<span class="sd">        merging function</span>
<span class="sd">    :return: A function merge_args_and_kwargs(args, kwargs) that can be used to merge arguments</span>

<span class="sd">    &gt;&gt;&gt; def func(a, b, c=3):</span>
<span class="sd">    ...     return a * (b + c)</span>
<span class="sd">    &gt;&gt;&gt; merger = mk_args_kwargs_merger(func)</span>
<span class="sd">    &gt;&gt;&gt; dict(merger([1], {&#39;b&#39;: 10}))</span>
<span class="sd">    {&#39;a&#39;: 1, &#39;b&#39;: 10}</span>
<span class="sd">    &gt;&gt;&gt; dict(merger([], {&#39;a&#39;: 1, &#39;b&#39;: 10}))</span>
<span class="sd">    {&#39;a&#39;: 1, &#39;b&#39;: 10}</span>
<span class="sd">    &gt;&gt;&gt; dict(merger([1, 10], {}))</span>
<span class="sd">    {&#39;a&#39;: 1, &#39;b&#39;: 10}</span>
<span class="sd">    &gt;&gt;&gt; dict(merger([], {}))</span>
<span class="sd">    {}</span>
<span class="sd">    &gt;&gt;&gt; # Usage demo:</span>
<span class="sd">    &gt;&gt;&gt; assert func(*[1], **{&#39;b&#39;: 10}) == func(**merger([1], {&#39;b&#39;: 10}))</span>
<span class="sd">    &gt;&gt;&gt; assert func(*[], **{&#39;a&#39;: 1, &#39;b&#39;: 10}) == func(**merger([], {&#39;a&#39;: 1, &#39;b&#39;: 10}))</span>
<span class="sd">    &gt;&gt;&gt; assert func(**{&#39;a&#39;: 1, &#39;b&#39;: 10}) == func(**merger([], {&#39;a&#39;: 1, &#39;b&#39;: 10}))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">merge_args_and_kwargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">bind_partial</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">arguments</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">kwargs</span>

    <span class="k">return</span> <span class="n">merge_args_and_kwargs</span></div>


<div class="viewcode-block" id="kwargs_for_func"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.kwargs_for_func">[docs]</a><span class="k">def</span> <span class="nf">kwargs_for_func</span><span class="p">(</span><span class="o">*</span><span class="n">funcs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param funcs:</span>
<span class="sd">    :param kwargs:</span>
<span class="sd">    :return:</span>

<span class="sd">    &gt;&gt;&gt; from i2.tests.objects_for_testing import formula1, sum_of_args, mult, add</span>
<span class="sd">    &gt;&gt;&gt; def print_dict(d):  # just a util for this doctest</span>
<span class="sd">    ...     from pprint import pprint</span>
<span class="sd">    ...     pprint({k.__name__: d[k] for k in sorted(d, key=lambda x: x.__name__)})</span>
<span class="sd">    &gt;&gt;&gt; print_dict(kwargs_for_func(formula1, mult, add,</span>
<span class="sd">    ...                           w=1, x=2, z=3, a=4, b=5)) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    {&#39;add&#39;: {&#39;a&#39;: 4, &#39;b&#39;: 5},</span>
<span class="sd">     &#39;formula1&#39;: {&#39;w&#39;: 1, &#39;x&#39;: 2, &#39;z&#39;: 3},</span>
<span class="sd">     &#39;mult&#39;: {&#39;x&#39;: 2}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">func</span><span class="p">,</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">source_kwargs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span> <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">)</span></div>


<div class="viewcode-block" id="assert_attrs"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.assert_attrs">[docs]</a><span class="k">def</span> <span class="nf">assert_attrs</span><span class="p">(</span><span class="n">attrs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Asserts, at construction time, that the class contains a specific set of attributes</span>
<span class="sd">    :param attrs: An attribute name (string) or a list of attribute names whose existence needs to be enforced.</span>
<span class="sd">    :return: A class decorator that will enforce the existence of the attrs when an instance is made</span>

<span class="sd">    &gt;&gt;&gt; @assert_attrs(&#39;foo&#39;)</span>
<span class="sd">    ... class A:</span>
<span class="sd">    ...     bar = 10</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; try:</span>
<span class="sd">    ...     a = A()</span>
<span class="sd">    ... except AttributeError:</span>
<span class="sd">    ...     print(&quot;AttributeError, as expected, because missing the foo attribute&quot;)</span>
<span class="sd">    AttributeError, as expected, because missing the foo attribute</span>
<span class="sd">    &gt;&gt;&gt; @assert_attrs(&#39;foo&#39;)</span>
<span class="sd">    ... class B:</span>
<span class="sd">    ...     def foo(self): pass</span>
<span class="sd">    &gt;&gt;&gt; b = B()</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; class A:</span>
<span class="sd">    ...     bar = 10</span>
<span class="sd">    &gt;&gt;&gt; class B:</span>
<span class="sd">    ...     def foo(self): pass</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; @assert_attrs([&#39;foo&#39;, &#39;bar&#39;])</span>
<span class="sd">    ... class C(A, B):</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; c = C()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">attrs</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_assert_attrs</span><span class="p">(</span><span class="n">klass</span><span class="p">):</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">klass</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">get_instance</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                        <span class="s1">&#39;class </span><span class="si">{}</span><span class="s1"> needs to have a </span><span class="si">{}</span><span class="s1"> attribute:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">klass</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attr</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">return</span> <span class="n">klass</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">get_instance</span>

    <span class="k">return</span> <span class="n">_assert_attrs</span></div>


<div class="viewcode-block" id="preprocess_arguments"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.preprocess_arguments">[docs]</a><span class="k">def</span> <span class="nf">preprocess_arguments</span><span class="p">(</span><span class="n">pre</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply a function to args, kwargs and use the transformed in the decorated function&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">pre</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)(</span><span class="n">wrapper</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">decorator</span></div>


<span class="k">def</span> <span class="nf">preprocess</span><span class="p">(</span><span class="n">pre</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pre</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">pre</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)(</span><span class="n">wrapper</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">decorator</span>


<span class="k">def</span> <span class="nf">_return_annotation_of</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return annotation of callable (if type, will return type systematically)</span>

<span class="sd">    &gt;&gt;&gt; def foo() -&gt; bool: ...</span>
<span class="sd">    &gt;&gt;&gt; assert _return_annotation_of(foo) == bool</span>
<span class="sd">    &gt;&gt;&gt; assert _return_annotation_of(zip) == zip</span>
<span class="sd">    &gt;&gt;&gt; assert _return_annotation_of(print) == Parameter.empty</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
        <span class="n">func</span><span class="p">,</span> <span class="nb">type</span>
    <span class="p">):</span>  <span class="c1"># TODO: Verify rule (are there commmon enough meta tricks that need to be handled?)</span>
        <span class="k">return</span> <span class="n">func</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">return_annotation</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># some builtins don&#39;t have signatures</span>
            <span class="k">return</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span>


<div class="viewcode-block" id="OutputPostProcessingError"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.OutputPostProcessingError">[docs]</a><span class="k">class</span> <span class="nc">OutputPostProcessingError</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">):</span>
    <span class="o">...</span></div>


<div class="viewcode-block" id="postprocess"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.postprocess">[docs]</a><span class="k">def</span> <span class="nf">postprocess</span><span class="p">(</span><span class="n">post</span><span class="p">,</span> <span class="n">caught_post_errors</span><span class="o">=</span><span class="p">(</span><span class="ne">Exception</span><span class="p">,),</span> <span class="n">verbose_error_message</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add some post-processing after a function</span>

<span class="sd">    :param post: The function to apply to the output</span>

<span class="sd">    &gt;&gt;&gt; list_range = postprocess(list)(range)</span>
<span class="sd">    &gt;&gt;&gt; list_range(4)</span>
<span class="sd">    [0, 1, 2, 3]</span>
<span class="sd">    &gt;&gt;&gt; sum_range = postprocess(sum)(range)</span>
<span class="sd">    &gt;&gt;&gt; sum_range(4)</span>
<span class="sd">    6</span>

<span class="sd">    Note: The decorator also sticks the return annotation of the post function on the wrapped one.</span>

<span class="sd">    Use cases:</span>

<span class="sd">    - Changing a generator into a container returning function</span>
<span class="sd">        In many situations, writing a generator is simpler than writing a function</span>
<span class="sd">        that accumulates a list or a dict etc.</span>
<span class="sd">        So here, you just write the generator and tag this decorator on top, to get the same effect.</span>

<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; @postprocess(dict)</span>
<span class="sd">    ... def bar(x):</span>
<span class="sd">    ...     for i in range(x):</span>
<span class="sd">    ...         yield str(i), i</span>
<span class="sd">    &gt;&gt;&gt; bar(3)</span>
<span class="sd">    {&#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2}</span>
<span class="sd">    &gt;&gt;&gt; signature(bar)</span>
<span class="sd">    &lt;Signature (x) -&gt; dict&gt;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; @postprocess(list)</span>
<span class="sd">    ... def foo(x):</span>
<span class="sd">    ...     for i in range(x):</span>
<span class="sd">    ...         yield i</span>
<span class="sd">    &gt;&gt;&gt; foo(3)</span>
<span class="sd">    [0, 1, 2]</span>
<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; signature(foo)</span>
<span class="sd">    &lt;Signature (x) -&gt; list&gt;</span>

<span class="sd">    - Triggering something (like logging, or forwarding) when a function returns</span>

<span class="sd">    &gt;&gt;&gt; def log_this(x):</span>
<span class="sd">    ...     print(f&quot;Logging {x}&quot;)</span>
<span class="sd">    ...     return x</span>
<span class="sd">    &gt;&gt;&gt; logged_foo = postprocess(log_this)(foo)</span>
<span class="sd">    &gt;&gt;&gt; t = logged_foo(2)</span>
<span class="sd">    Logging [0, 1]</span>
<span class="sd">    &gt;&gt;&gt; assert t == [0, 1]</span>

<span class="sd">    - Using a function that does a lot to make several functions that do less.</span>
<span class="sd">        (e.g. Extracting/making a python object from a function returning a raw http response_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">post</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">caught_post_errors</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Error when postprocessing output with post func: </span><span class="si">{</span><span class="n">func</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="k">if</span> <span class="n">verbose_error_message</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;  output=</span><span class="si">{</span><span class="n">output</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="nb">isinstance</span><span class="p">(</span><span class="n">verbose_error_message</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="n">verbose_error_message</span> <span class="o">&gt;</span> <span class="mi">1</span>
                    <span class="p">):</span>
                        <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                            <span class="o">+</span> <span class="s1">&#39;  which was obtained by func(*args, **kwargs) where:&#39;</span>
                        <span class="p">)</span>
                        <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;    args: </span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;    kwargs: </span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s1">&#39;</span>
                        <span class="p">)</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;Error is: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="k">raise</span> <span class="n">OutputPostProcessingError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">return_annot</span> <span class="o">=</span> <span class="n">_return_annotation_of</span><span class="p">(</span><span class="n">post</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">suppress</span><span class="p">(</span>
            <span class="ne">ValueError</span>
        <span class="p">):</span>  <span class="c1"># intended to catch cases where wrapper doesn&#39;t have a signature</span>
            <span class="n">wrapper_signature</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">wrapper</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span>
                <span class="n">wrapper_signature</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">return_annot</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">wrapper</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">sig</span>

        <span class="k">return</span> <span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)(</span><span class="n">wrapper</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">decorator</span></div>


<div class="viewcode-block" id="input_output_decorator"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.input_output_decorator">[docs]</a><span class="k">def</span> <span class="nf">input_output_decorator</span><span class="p">(</span><span class="n">preprocess</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">postprocess</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Makes a decorator that preprocesses inputs and postprocesses outputs.</span>
<span class="sd">    Use it if you want to transform the input of a function or method before calling it, or if you want</span>
<span class="sd">    to transform the returned value before returning it.</span>
<span class="sd">    :param preprocess: Function to be applied to input</span>
<span class="sd">    :param postprocess: Function to be applied to output</span>
<span class="sd">    :return: a decorator that preprocesses inputs and postprocesses outputs</span>
<span class="sd">    See also: preprocess and postprocess decorators if you need only to pre or post process!</span>

<span class="sd">    &gt;&gt;&gt; # Examples with &quot;normal functions&quot;</span>
<span class="sd">    &gt;&gt;&gt; def f(x=3):</span>
<span class="sd">    ...     &#39;&#39;&#39;Some doc...&#39;&#39;&#39;</span>
<span class="sd">    ...     return x + 10</span>
<span class="sd">    &gt;&gt;&gt; ff = input_output_decorator()(f)</span>
<span class="sd">    &gt;&gt;&gt; print((ff(5.0)))</span>
<span class="sd">    15.0</span>
<span class="sd">    &gt;&gt;&gt; ff = input_output_decorator(preprocess=int)(f)</span>
<span class="sd">    &gt;&gt;&gt; print((ff(5.0)))</span>
<span class="sd">    15</span>
<span class="sd">    &gt;&gt;&gt; ff = input_output_decorator(preprocess=int, postprocess=lambda x: &quot;Hello {}!&quot;.format(x))(f)</span>
<span class="sd">    &gt;&gt;&gt; print((ff(&#39;5&#39;)))</span>
<span class="sd">    Hello 15!</span>
<span class="sd">    &gt;&gt;&gt; ff = input_output_decorator(postprocess=lambda x: &quot;Hello {}!&quot;.format(x))(f)</span>
<span class="sd">    &gt;&gt;&gt; print((ff(5.0)))</span>
<span class="sd">    Hello 15.0!</span>
<span class="sd">    &gt;&gt;&gt; print((ff.__doc__))</span>
<span class="sd">    Some doc...</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # examples with methods (bounded, class methods, static methods</span>
<span class="sd">    &gt;&gt;&gt; class F:</span>
<span class="sd">    ...     &#39;&#39;&#39;This is not what you&#39;d expect: The doc of the class, not the function&#39;&#39;&#39;</span>
<span class="sd">    ...     def __init__(self, y=10):</span>
<span class="sd">    ...         &#39;&#39;&#39;Initialize&#39;&#39;&#39;</span>
<span class="sd">    ...         self.y = y</span>
<span class="sd">    ...     def __call__(self, x=3):</span>
<span class="sd">    ...         &#39;&#39;&#39;Some doc...&#39;&#39;&#39;</span>
<span class="sd">    ...         return self.y + x</span>
<span class="sd">    ...     @staticmethod</span>
<span class="sd">    ...     def static_method(x, y):</span>
<span class="sd">    ...         return &quot;What {} {} you have&quot;.format(x, y)</span>
<span class="sd">    ...     @classmethod</span>
<span class="sd">    ...     def class_method(cls, x):</span>
<span class="sd">    ...         return &quot;{} likes {}&quot;.format(cls.__name__, x)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; f = F()</span>
<span class="sd">    &gt;&gt;&gt; ff = input_output_decorator()(f)</span>
<span class="sd">    &gt;&gt;&gt; print((ff(5.0)))</span>
<span class="sd">    15.0</span>
<span class="sd">    &gt;&gt;&gt; ff = input_output_decorator(preprocess=int)(f)</span>
<span class="sd">    &gt;&gt;&gt; print((ff(5.0)))</span>
<span class="sd">    15</span>
<span class="sd">    &gt;&gt;&gt; ff = input_output_decorator(preprocess=int, postprocess=lambda x: &quot;Hello {}!&quot;.format(x))(f)</span>
<span class="sd">    &gt;&gt;&gt; print((ff(&#39;5&#39;)))</span>
<span class="sd">    Hello 15!</span>
<span class="sd">    &gt;&gt;&gt; ff = input_output_decorator(postprocess=lambda x: &quot;Hello {}!&quot;.format(x))(f)</span>
<span class="sd">    &gt;&gt;&gt; print((ff(5.0)))</span>
<span class="sd">    Hello 15.0!</span>
<span class="sd">    &gt;&gt;&gt; print((ff.__doc__))</span>
<span class="sd">    This is not what you&#39;d expect: The doc of the class, not the function</span>

<span class="sd">    # &gt;&gt;&gt;</span>
<span class="sd">    # &gt;&gt;&gt; f.static_method = input_output_decorator(preprocess=lambda x: &#39;&quot;&#39; + x + &#39;&quot;&#39;,</span>
<span class="sd">    # ...                                          postprocess=lambda x: x + &#39;!!!&#39;)(f.static_method)</span>
<span class="sd">    # &gt;&gt;&gt; print(ff.static_method(&#39;big&#39;, &#39;eyes&#39;))</span>
<span class="sd">    # What big &quot;eyes&quot; you have!!!</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">preprocess</span> <span class="ow">and</span> <span class="n">postprocess</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">func_wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">postprocess</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">preprocess</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)))</span>

        <span class="k">elif</span> <span class="n">preprocess</span><span class="p">:</span>  <span class="c1"># a preprocess but no postprocess</span>

            <span class="k">def</span> <span class="nf">func_wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">preprocess</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">postprocess</span><span class="p">:</span>  <span class="c1"># a postprocess but no preprocess</span>

            <span class="k">def</span> <span class="nf">func_wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">postprocess</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># neither pre nor post processing, so leave func as is</span>
            <span class="k">return</span> <span class="n">func</span>

        <span class="k">return</span> <span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)(</span><span class="n">func_wrapper</span><span class="p">)</span>

    <span class="n">decorator</span><span class="o">.</span><span class="n">preprocess</span> <span class="o">=</span> <span class="n">preprocess</span>
    <span class="n">decorator</span><span class="o">.</span><span class="n">postprocess</span> <span class="o">=</span> <span class="n">postprocess</span>

    <span class="k">return</span> <span class="n">decorator</span></div>


<div class="viewcode-block" id="transform_args"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.transform_args">[docs]</a><span class="k">def</span> <span class="nf">transform_args</span><span class="p">(</span><span class="n">dflt_trans_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">**</span><span class="n">trans_func_for_arg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a decorator that transforms function arguments before calling the function.</span>
<span class="sd">    Works with plain functions and bounded methods.</span>
<span class="sd">    For example:</span>
<span class="sd">        * original argument: a relative path --&gt; used argument: a full path</span>
<span class="sd">        * original argument: a pickle filepath --&gt; used argument: the loaded object</span>
<span class="sd">    :param rootdir: rootdir to be used for all name arguments of target function</span>
<span class="sd">    :param name_arg: the position (int) or argument name of the argument containing the name</span>
<span class="sd">    :return: a decorator</span>

<span class="sd">    &gt;&gt;&gt; # Example with a plain function</span>
<span class="sd">    &gt;&gt;&gt; def f(a, b, c=&#39;default_c&#39;):</span>
<span class="sd">    ...     return &quot;a={a}, b={b}, c={c}&quot;.format(a=a, b=b, c=c)</span>
<span class="sd">    &gt;&gt;&gt; def prepend_root(x):</span>
<span class="sd">    ...     return &#39;ROOT/&#39; + x</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; def test(f):</span>
<span class="sd">    ...     assert f(&#39;foo&#39;, &#39;bar&#39;, 3) == &#39;a=foo, b=bar, c=3&#39;</span>
<span class="sd">    ...     ff = transform_args()(f)  # no transformation specification, so function is unchanged</span>
<span class="sd">    ...     assert ff(&#39;foo&#39;, &#39;bar&#39;, c=3) == &#39;a=foo, b=bar, c=3&#39;</span>
<span class="sd">    ...     ff = transform_args(a=prepend_root)(f)  # prepend root to a</span>
<span class="sd">    ...     assert ff(&#39;foo&#39;, c=3, b=&#39;bar&#39;) == &#39;a=ROOT/foo, b=bar, c=3&#39;  # note: testing different order of args</span>
<span class="sd">    ...     ff = transform_args(b=prepend_root)(f)  # prepend root to b</span>
<span class="sd">    ...     assert ff(c=3, b=&#39;bar&#39;, a=&#39;foo&#39;) == &#39;a=foo, b=ROOT/bar, c=3&#39;  # note: testing different order of args</span>
<span class="sd">    ...     ff = transform_args(a=prepend_root, b=prepend_root)(f)  # prepend root to a and b</span>
<span class="sd">    ...     assert ff(&#39;foo&#39;, &#39;bar&#39;, 3) == &#39;a=ROOT/foo, b=ROOT/bar, c=3&#39;</span>
<span class="sd">    ...     assert ff(&#39;foo&#39;, &#39;bar&#39;) == &#39;a=ROOT/foo, b=ROOT/bar, c=default_c&#39;  # defaults still work</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; test(f)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Example with bounded method, wrapping from instance</span>
<span class="sd">    &gt;&gt;&gt; class A:</span>
<span class="sd">    ...     def __init__(self, sep=&#39;&#39;):</span>
<span class="sd">    ...         self.sep = sep</span>
<span class="sd">    ...     def f(self, a, b, c=&#39;default_c&#39;):</span>
<span class="sd">    ...         return f&quot;a={a}{self.sep} b={b}{self.sep} c={c}&quot;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; a = A(sep=&#39;,&#39;)</span>
<span class="sd">    &gt;&gt;&gt; test(a.f)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Example with bounded method, wrapping from class</span>
<span class="sd">    &gt;&gt;&gt; A.f = transform_args(a=prepend_root, b=prepend_root)(A.f)</span>
<span class="sd">    &gt;&gt;&gt; a = A(sep=&#39;,&#39;)</span>
<span class="sd">    &gt;&gt;&gt; assert a.f(&#39;foo&#39;, &#39;bar&#39;, 3) == &#39;a=ROOT/foo, b=ROOT/bar, c=3&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert a.f(&#39;foo&#39;, &#39;bar&#39;) == &#39;a=ROOT/foo, b=ROOT/bar, c=default_c&#39;  # defaults still work</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">transform_args_decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">get_kwargs</span> <span class="o">=</span> <span class="n">mk_args_kwargs_merger</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">trans_func_for_arg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dflt_trans_func</span>
        <span class="p">):</span>  <span class="c1"># if no transformations were specified...</span>
            <span class="k">return</span> <span class="n">func</span>  <span class="c1"># just return the function itself</span>
        <span class="k">elif</span> <span class="n">dflt_trans_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span>
                <span class="n">dflt_trans_func</span>
            <span class="p">),</span> <span class="s1">&#39;The dflt_trans_func needs to be a callable&#39;</span>

            <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">transform_args_wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">val_of_argname</span> <span class="o">=</span> <span class="n">get_kwargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
                <span class="n">val_of_argname</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">argname</span><span class="p">:</span> <span class="n">dflt_trans_func</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">argname</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">val_of_argname</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>

                <span class="c1"># apply transform functions to argument values</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">**</span><span class="n">val_of_argname</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">transform_args_wrapper</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">transform_args_wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="c1"># get a {argname: argval, ...} dict from *args and **kwargs</span>
                <span class="c1"># Note: Didn&#39;t really need an if/else here but I am assuming that...</span>
                <span class="c1"># Note: ... getcallargs gives us an overhead that can be avoided if there&#39;s only keyword args.</span>

                <span class="n">val_of_argname</span> <span class="o">=</span> <span class="n">get_kwargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">argname</span><span class="p">,</span> <span class="n">trans_func</span> <span class="ow">in</span> <span class="n">trans_func_for_arg</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">argname</span> <span class="ow">in</span> <span class="n">val_of_argname</span><span class="p">:</span>
                        <span class="n">val_of_argname</span><span class="p">[</span><span class="n">argname</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans_func</span><span class="p">(</span><span class="n">val_of_argname</span><span class="p">[</span><span class="n">argname</span><span class="p">])</span>
                <span class="c1"># apply transform functions to argument values</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">**</span><span class="n">val_of_argname</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">transform_args_wrapper</span>

    <span class="n">transform_args_decorator</span><span class="o">.</span><span class="n">dflt_trans_func</span> <span class="o">=</span> <span class="n">dflt_trans_func</span>
    <span class="n">transform_args_decorator</span><span class="o">.</span><span class="n">trans_func_for_arg</span> <span class="o">=</span> <span class="n">trans_func_for_arg</span>

    <span class="k">return</span> <span class="n">transform_args_decorator</span></div>


<span class="k">def</span> <span class="nf">wrap_method_output</span><span class="p">(</span><span class="n">wrapper_func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_wrap_output</span><span class="p">(</span><span class="n">wrapped</span><span class="p">):</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">wrapped</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">_wrapped</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">wrapper_func</span><span class="p">(</span><span class="n">wrapped</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">_wrapped</span>

    <span class="k">return</span> <span class="n">_wrap_output</span>


<div class="viewcode-block" id="wrap_class_methods"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.wrap_class_methods">[docs]</a><span class="k">def</span> <span class="nf">wrap_class_methods</span><span class="p">(</span>
    <span class="n">_return_a_copy_of_the_class</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">_raise_error_if_non_existent_method</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">wrapper_for_method</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a decorator that wraps specific methods.</span>

<span class="sd">    IMPORTANT: The decorator will by default return a copy of the class. This might incur some run time overhead.</span>
<span class="sd">    If this is desirable, for example, when you want to create several decorations of a same class.</span>
<span class="sd">    If you want to change the class itself (e.g. you&#39;re only loading it once in a module, and decorating it), then</span>
<span class="sd">    specify _return_a_copy_of_the_class=False</span>

<span class="sd">    Note that _return_a_copy_of_the_class=True has a side effect of building russian dolls of essentially subclasses</span>
<span class="sd">    of the class, which may have some undesirable results if repeated too many times.</span>

<span class="sd">    :param _return_a_copy_of_the_class: Specifies whether to</span>
<span class="sd">        return a copy of the class (_return_a_copy_of_the_class=True, the default),</span>
<span class="sd">        or change the actual loaded class itself (_return_a_copy_of_the_class=False)</span>
<span class="sd">    :param wrapper_for_method: method_name=wrapper_function pairs.</span>
<span class="sd">    :return: A class wrapper. That is, a decorator that takes a class and returns a decorated version of it</span>
<span class="sd">        (or decaorates &quot;in-place&quot; if _return_a_copy_of_the_class=False</span>

<span class="sd">    SEE ALSO:</span>
<span class="sd">        * wrap_method_output: The function that is called for every method we wrap.</span>
<span class="sd">        * transform_class_method_input_and_output: A wrap_class_methods that is specialized for input arg and output</span>
<span class="sd">            transformation.</span>

<span class="sd">    &gt;&gt;&gt; from functools import wraps</span>
<span class="sd">    &gt;&gt;&gt; class A:</span>
<span class="sd">    ...     def __init__(self, a=10):</span>
<span class="sd">    ...         self.a = a</span>
<span class="sd">    ...     def add(self, x):</span>
<span class="sd">    ...         return self.a + x</span>
<span class="sd">    ...     def multiply(self, x):</span>
<span class="sd">    ...         return self.a * x</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; a = A()</span>
<span class="sd">    &gt;&gt;&gt; a.add(2)</span>
<span class="sd">    12</span>
<span class="sd">    &gt;&gt;&gt; a.multiply(2)</span>
<span class="sd">    20</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; def log_calls(func):</span>
<span class="sd">    ...     name = func.__name__</span>
<span class="sd">    ...     @wraps(func)</span>
<span class="sd">    ...     def _func(self, *args, **kwargs):</span>
<span class="sd">    ...         print(&quot;Calling {} with\\n  args={}\\n  kwargs={}&quot;.format(name, args, kwargs))</span>
<span class="sd">    ...         return func(self, *args, **kwargs)</span>
<span class="sd">    ...     return _func</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; AA = wrap_class_methods(**{k: log_calls for k in [&#39;add&#39;, &#39;multiply&#39;]})(A)</span>
<span class="sd">    &gt;&gt;&gt; a = AA()</span>
<span class="sd">    &gt;&gt;&gt; a.add(x=3)</span>
<span class="sd">    Calling add with</span>
<span class="sd">      args=()</span>
<span class="sd">      kwargs={&#39;x&#39;: 3}</span>
<span class="sd">    13</span>
<span class="sd">    &gt;&gt;&gt; a.multiply(3)</span>
<span class="sd">    Calling multiply with</span>
<span class="sd">      args=(3,)</span>
<span class="sd">      kwargs={}</span>
<span class="sd">    30</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">class_wrapper</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_return_a_copy_of_the_class</span><span class="p">:</span>
            <span class="n">_cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">))</span>
            <span class="c1"># class _cls(cls):</span>
            <span class="c1">#     pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_cls</span> <span class="o">=</span> <span class="bp">cls</span>
        <span class="k">for</span> <span class="n">method</span><span class="p">,</span> <span class="n">wrapper</span> <span class="ow">in</span> <span class="n">wrapper_for_method</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">_cls</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">_cls</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">wrapper</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_cls</span><span class="p">,</span> <span class="n">method</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="n">_raise_error_if_non_existent_method</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_cls</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">cls</span><span class="p">))</span><span class="si">}</span><span class="s2"> has no &#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39; method!&quot;</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">_cls</span>

    <span class="k">return</span> <span class="n">class_wrapper</span></div>


<span class="k">def</span> <span class="nf">mk_input_and_output_method_wrapper</span><span class="p">(</span><span class="n">method_output_trans</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">arg_trans</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrap_method</span><span class="p">(</span><span class="n">method_func</span><span class="p">):</span>
        <span class="n">wrapped_method</span> <span class="o">=</span> <span class="n">transform_args</span><span class="p">(</span><span class="o">**</span><span class="n">arg_trans</span><span class="p">)(</span><span class="n">method_func</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method_output_trans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">wrap_method_output</span><span class="p">(</span><span class="n">method_output_trans</span><span class="p">)(</span><span class="n">wrapped_method</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">wrapped_method</span>

    <span class="k">return</span> <span class="n">wrap_method</span>


<span class="k">def</span> <span class="nf">transform_class_method_input_and_output</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">method_output_trans</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">arg_trans</span>
<span class="p">):</span>
    <span class="n">wrapped_method</span> <span class="o">=</span> <span class="n">transform_args</span><span class="p">(</span><span class="o">**</span><span class="n">arg_trans</span><span class="p">)(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">method</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">method_output_trans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">wrap_method_output</span><span class="p">(</span><span class="n">method_output_trans</span><span class="p">)(</span><span class="n">wrapped_method</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">wrapped_method</span><span class="p">)</span>


<div class="viewcode-block" id="wrap_class_methods_input_and_output"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.wrap_class_methods_input_and_output">[docs]</a><span class="k">def</span> <span class="nf">wrap_class_methods_input_and_output</span><span class="p">(</span>
    <span class="n">_return_a_copy_of_the_class</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">_raise_error_if_non_existent_method</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">method_trans_spec</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a decorator that wraps specific methods, transforming specific argument values a nd output values.</span>

<span class="sd">    IMPORTANT: The decorator will by default return a copy of the class. This might incur some run time overhead.</span>
<span class="sd">    If this is desirable, for example, when you want to create several decorations of a same class.</span>
<span class="sd">    If you want to change the class itself (e.g. you&#39;re only loading it once in a module, and decorating it), then</span>
<span class="sd">    specify _return_a_copy_of_the_class=False</span>

<span class="sd">    :param _return_a_copy_of_the_class: Specifies whether to</span>
<span class="sd">        return a copy of the class (_return_a_copy_of_the_class=True, the default),</span>
<span class="sd">        or change the actual loaded class itself (_return_a_copy_of_the_class=False)</span>
<span class="sd">    :param method_trans_spec: method_name=trans_specs_for_method pairs.</span>
<span class="sd">        The trans_specs_for_method is a dict that is understood by transform_class_method_input_and_output.</span>
<span class="sd">        Except for one special case, it&#39;s keys are argument names and values are callables to call on those</span>
<span class="sd">        arguments&#39; values.</span>
<span class="sd">        The special case is method_output_trans. This specifies that the callable it points to should be called</span>
<span class="sd">        on output of method. Here&#39;s one recipe for outputs: If the output of a function is an iterable and you want</span>
<span class="sd">        to apply a function trans to each element of the output, specify method_output_trans=lambda x: map(trans, x).</span>
<span class="sd">    :return: A wrapped class</span>

<span class="sd">    SEE ALSO:</span>
<span class="sd">        * mk_method_trans_spec_from_methods_specs_dict: a utility to make method_trans_spec more easily</span>
<span class="sd">        * transform_class_method_input_and_output: The function that is called for every method we wrap.</span>

<span class="sd">    In the following, we will show two examples.</span>
<span class="sd">    - The first is a toy example to demonstrate the basic functionality.</span>
<span class="sd">    - The second demonstrates a more involved case, but is still a silly example.</span>
<span class="sd">    - The third demonstrates more the type of application we&#39;d use wrap_class_methods_input_and_output for in real life.</span>

<span class="sd">    # FIRST EXAMPLE</span>
<span class="sd">    We make an Ops class that wraps Counter, allowing one to add items and show the counts of items added.</span>

<span class="sd">    &gt;&gt;&gt; from collections import UserDict</span>
<span class="sd">    &gt;&gt;&gt; import re</span>
<span class="sd">    &gt;&gt;&gt; from collections import Counter</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; class Ops:</span>
<span class="sd">    ...     def __init__(self):</span>
<span class="sd">    ...         self.counter = Counter()</span>
<span class="sd">    ...     def add_item(self, item):</span>
<span class="sd">    ...         self.counter.update({item: 1})</span>
<span class="sd">    ...     def show(self):</span>
<span class="sd">    ...         return self.counter</span>
<span class="sd">    &gt;&gt;&gt; # Here&#39;s an example of what Ops does</span>
<span class="sd">    &gt;&gt;&gt; ops = Ops()</span>
<span class="sd">    &gt;&gt;&gt; for item in [&#39;this&#39;, &#39;is&#39;, &#39;that&#39;, &#39;and&#39;, &#39;that&#39;, &#39;is&#39;, &#39;this&#39;]:</span>
<span class="sd">    ...     ops.add_item(item)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; ops.show()</span>
<span class="sd">    Counter({&#39;this&#39;: 2, &#39;is&#39;: 2, &#39;that&#39;: 2, &#39;and&#39;: 1})</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # But say we don&#39;t want to count actual words added, but just the first two letters of these words,</span>
<span class="sd">    &gt;&gt;&gt; # and say we want to show() to return the dict, not the Counter.</span>
<span class="sd">    &gt;&gt;&gt; NewOps = wrap_class_methods_input_and_output(</span>
<span class="sd">    ...     _return_a_copy_of_the_class=False,</span>
<span class="sd">    ...     add_item=dict(item=lambda x: x[:2]),  # intercept items fed to add_item and keep only 2 first letters</span>
<span class="sd">    ...     show=dict(method_output_trans=dict)  # intercept output of show method, converting to dict</span>
<span class="sd">    ... )(Ops)</span>
<span class="sd">    &gt;&gt;&gt; # let&#39;s try it out!</span>
<span class="sd">    &gt;&gt;&gt; ops = NewOps()</span>
<span class="sd">    &gt;&gt;&gt; for item in [&#39;this&#39;, &#39;is&#39;, &#39;that&#39;, &#39;and&#39;, &#39;that&#39;, &#39;is&#39;, &#39;this&#39;]:</span>
<span class="sd">    ...     ops.add_item(item)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; ops.show()</span>
<span class="sd">    {&#39;th&#39;: 4, &#39;is&#39;: 2, &#39;an&#39;: 1}</span>
<span class="sd">    &gt;&gt;&gt; # See that we specified _return_a_copy_of_the_class=False?</span>
<span class="sd">    &gt;&gt;&gt; # Now look at what happens if we try to use Ops, the original class, again. It behaves like NewOps.</span>
<span class="sd">    &gt;&gt;&gt; # That&#39;s usually not the behavior we want, so be careful!</span>
<span class="sd">    &gt;&gt;&gt; ops = Ops()</span>
<span class="sd">    &gt;&gt;&gt; for item in [&#39;this&#39;, &#39;is&#39;, &#39;that&#39;, &#39;and&#39;, &#39;that&#39;, &#39;is&#39;, &#39;this&#39;]:</span>
<span class="sd">    ...     ops.add_item(item)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; ops.show()</span>
<span class="sd">    {&#39;th&#39;: 4, &#39;is&#39;: 2, &#39;an&#39;: 1}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt;</span>

<span class="sd">    # SECOND EXAMPLE</span>

<span class="sd">    Wrap a dict (or rather, the safer collections.UserDict), doing weird things to the input and output</span>
<span class="sd">    keys and values</span>

<span class="sd">    &gt;&gt;&gt; val_in_trans = lambda x: &#39;hello {}&#39;.format(x)  # prepend &quot;hello &quot; to incoming values</span>
<span class="sd">    &gt;&gt;&gt; val_out_trans = lambda x: re.sub(&#39;hello&#39;, &#39;hi&#39;, x)  # replace &quot;hello&quot; by &quot;hi&quot; in output values</span>
<span class="sd">    &gt;&gt;&gt; key_in_trans = lambda x: &#39;__&#39; + x  # prepend incoming keys with double underscore</span>
<span class="sd">    &gt;&gt;&gt; key_out_trans = lambda x: x[2:]  # remove the first two characters (underscores) from keys when output</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; methods_specs_dict = {</span>
<span class="sd">    ...     (&#39;__contains__&#39;, &#39;__getitem__&#39;, &#39;__setitem__&#39;, &#39;__delitem__&#39;): dict(key=key_in_trans),</span>
<span class="sd">    ...     &#39;__setitem__&#39;: dict(item=val_in_trans),</span>
<span class="sd">    ...     &#39;__iter__&#39;: dict(method_output_trans=lambda x: map(key_out_trans, x)),</span>
<span class="sd">    ...     &#39;__getitem__&#39;: dict(method_output_trans=val_out_trans)</span>
<span class="sd">    ... }</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; methods_specs_dict = mk_method_trans_spec_from_methods_specs_dict(methods_specs_dict)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; @wrap_class_methods_input_and_output(**methods_specs_dict)</span>
<span class="sd">    ... class AA(UserDict):</span>
<span class="sd">    ...     pass</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; aa = AA()</span>
<span class="sd">    &gt;&gt;&gt; aa[&#39;foo&#39;] = &#39;shoo&#39;  # store &#39;shoo&#39; under &#39;foo&#39;</span>
<span class="sd">    &gt;&gt;&gt; # the __str__ method isn&#39;t wrapped, so we see the actual STORED keys and values</span>
<span class="sd">    &gt;&gt;&gt; # we see that __foo, not foo is the actual key, and &quot;hello shoo&quot; the value:</span>
<span class="sd">    &gt;&gt;&gt; assert str(aa) == &quot;{&#39;__foo&#39;: &#39;hello shoo&#39;}&quot;</span>
<span class="sd">    &gt;&gt;&gt; assert &#39;foo&#39; in aa  # yet from the interface, it looks like &#39;foo&#39; is a key of aa...</span>
<span class="sd">    &gt;&gt;&gt; assert &#39;__foo&#39; not in aa  # ... and &#39;__foo&#39; is not a key.</span>
<span class="sd">    &gt;&gt;&gt; aa[&#39;foo&#39;] = &#39;bar&#39;  # let&#39;s replace the value of &#39;foo&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert str(aa) == &quot;{&#39;__foo&#39;: &#39;hello bar&#39;}&quot;  # see what&#39;s stored</span>
<span class="sd">    &gt;&gt;&gt; aa[&#39;star&#39;] = &#39;wars&#39;  # let&#39;s add another</span>
<span class="sd">    &gt;&gt;&gt; assert list(aa) == [&#39;foo&#39;, &#39;star&#39;]  # what are the keys? (this uses __iter__ under the hood)</span>
<span class="sd">    &gt;&gt;&gt; # In the following, we&#39;ll use methods keys(), values(), and items(), none of which we wrapped.</span>
<span class="sd">    &gt;&gt;&gt; # And yet, they work as expected, since they pass on their work to methods we wrapped.</span>
<span class="sd">    &gt;&gt;&gt; assert list(aa.keys()) == [&#39;foo&#39;, &#39;star&#39;]  # another way to get keys</span>
<span class="sd">    &gt;&gt;&gt; # see here that when we ask for values, we don&#39;t get what we asked to store, ...</span>
<span class="sd">    &gt;&gt;&gt; # ... nor what is actually stored, but something else</span>
<span class="sd">    &gt;&gt;&gt; assert list(aa.values()) == [&#39;hi bar&#39;, &#39;hi wars&#39;]</span>
<span class="sd">    &gt;&gt;&gt; assert str(list(aa.items())) == &quot;[(&#39;foo&#39;, &#39;hi bar&#39;), (&#39;star&#39;, &#39;hi wars&#39;)]&quot;  # the keys and values we get from items()</span>
<span class="sd">    &gt;&gt;&gt; assert str(aa) == &quot;{&#39;__foo&#39;: &#39;hello bar&#39;, &#39;__star&#39;: &#39;hello wars&#39;}&quot;  # what is actually stored</span>
<span class="sd">    &gt;&gt;&gt; del aa[&#39;foo&#39;]  # testing deletion of a key</span>
<span class="sd">    &gt;&gt;&gt; assert str(aa) == &quot;{&#39;__star&#39;: &#39;hello wars&#39;}&quot;  # it worked!</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt;</span>

<span class="sd">    # THIRD EXAMPLE</span>

<span class="sd">    Here again, we&#39;ll wrap UserDict. But instead of being silly, we&#39;ll pretend we need to store waveforms</span>
<span class="sd">    in binary format (so input values will have to be wrapped), but still retrieving these waveforms as lists</span>
<span class="sd">    (so output values will have to be wrapped).</span>
<span class="sd">    Additionally, we&#39;ll pretend we&#39;re working with wav files within some root directory, but don&#39;t</span>
<span class="sd">    want the root dir or the &#39;.wav&#39; extension to appear in our keys. So we&#39;ll have to wrap input and output keys.</span>
<span class="sd">    Of course, this is just pretend. Don&#39;t use this with real waveforms. It won&#39;t work.</span>

<span class="sd">    &gt;&gt;&gt; root = &#39;/ROOT/DIR/&#39;</span>
<span class="sd">    &gt;&gt;&gt; abs_path_of_rel_path = lambda rel_path: root + rel_path + &#39;.wav&#39;  # transform a relative path to an absolute one</span>
<span class="sd">    &gt;&gt;&gt; rel_path_of_abs_path = lambda x: x.replace(root, &#39;&#39;).replace(&#39;.wav&#39;, &#39;&#39;)  # transform an absolute path to a relative one</span>
<span class="sd">    &gt;&gt;&gt; list_to_bytes = bytes</span>
<span class="sd">    &gt;&gt;&gt; bytes_to_list = list</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; methods_specs_dict = {</span>
<span class="sd">    ...     (&#39;__contains__&#39;, &#39;__getitem__&#39;, &#39;__setitem__&#39;, &#39;__delitem__&#39;): dict(key=abs_path_of_rel_path),</span>
<span class="sd">    ...     &#39;__setitem__&#39;: dict(item=list_to_bytes),</span>
<span class="sd">    ...     &#39;__iter__&#39;: dict(method_output_trans=lambda x: map(rel_path_of_abs_path, x)),</span>
<span class="sd">    ...     &#39;__getitem__&#39;: dict(method_output_trans=bytes_to_list)</span>
<span class="sd">    ... }</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; methods_specs_dict = mk_method_trans_spec_from_methods_specs_dict(methods_specs_dict)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; @wrap_class_methods_input_and_output(**methods_specs_dict)</span>
<span class="sd">    ... class Wf(UserDict):</span>
<span class="sd">    ...     pass</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; year = [2, 0, 1, 9]</span>
<span class="sd">    &gt;&gt;&gt; down = [5, 4, 3, 2, 1]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; wf = Wf()</span>
<span class="sd">    &gt;&gt;&gt; wf[&#39;year&#39;] = year</span>
<span class="sd">    &gt;&gt;&gt; print(str(wf).replace(&quot;b&#39;&quot;, &quot;&#39;&quot;))</span>
<span class="sd">    {&#39;/ROOT/DIR/year.wav&#39;: &#39;\\x02\\x00\\x01\\t&#39;}</span>
<span class="sd">    &gt;&gt;&gt; &#39;year&#39; in wf</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; wf[&#39;down&#39;] = down</span>
<span class="sd">    &gt;&gt;&gt; print(str(wf).replace(&quot;b&#39;&quot;, &quot;&#39;&quot;))</span>
<span class="sd">    {&#39;/ROOT/DIR/year.wav&#39;: &#39;\\x02\\x00\\x01\\t&#39;, &#39;/ROOT/DIR/down.wav&#39;: &#39;\\x05\\x04\\x03\\x02\\x01&#39;}</span>
<span class="sd">    &gt;&gt;&gt; list(wf.keys())</span>
<span class="sd">    [&#39;year&#39;, &#39;down&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(wf.values())</span>
<span class="sd">    [[2, 0, 1, 9], [5, 4, 3, 2, 1]]</span>
<span class="sd">    &gt;&gt;&gt; list(wf.items())</span>
<span class="sd">    [(&#39;year&#39;, [2, 0, 1, 9]), (&#39;down&#39;, [5, 4, 3, 2, 1])]</span>
<span class="sd">    &gt;&gt;&gt; len(wf)</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; del wf[&#39;year&#39;]</span>
<span class="sd">    &gt;&gt;&gt; len(wf)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; list(wf.items())</span>
<span class="sd">    [(&#39;down&#39;, [5, 4, 3, 2, 1])]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">wrapper_for_method</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">mk_input_and_output_method_wrapper</span><span class="p">(</span><span class="o">**</span><span class="n">method_trans</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">method</span><span class="p">,</span> <span class="n">method_trans</span> <span class="ow">in</span> <span class="n">method_trans_spec</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">wrap_class_methods</span><span class="p">(</span>
        <span class="n">_return_a_copy_of_the_class</span><span class="o">=</span><span class="n">_return_a_copy_of_the_class</span><span class="p">,</span>
        <span class="n">_raise_error_if_non_existent_method</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">wrapper_for_method</span><span class="p">,</span>
    <span class="p">)</span></div>

    <span class="c1"># def class_wrapper(cls):</span>
    <span class="c1">#     if _return_a_copy_of_the_class:</span>
    <span class="c1">#         class _cls(cls):</span>
    <span class="c1">#             pass</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         _cls = cls</span>
    <span class="c1">#     for method, method_trans in method_trans_spec.items():</span>
    <span class="c1">#         if hasattr(_cls, method):</span>
    <span class="c1">#             transform_class_method_input_and_output(_cls, method, **method_trans)</span>
    <span class="c1">#         elif _raise_error_if_non_existent_method:</span>
    <span class="c1">#             if hasattr(cls, &#39;__name__&#39;):</span>
    <span class="c1">#                 class_name = cls.__name__</span>
    <span class="c1">#             else:</span>
    <span class="c1">#                 class_name = str(cls)</span>
    <span class="c1">#             raise ValueError(&quot;{} has no &#39;{}&#39; method!&quot;.format(class_name, method))</span>
    <span class="c1">#     return _cls</span>
    <span class="c1">#</span>
    <span class="c1"># return class_wrapper</span>


<div class="viewcode-block" id="add_method"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.add_method">[docs]</a><span class="k">def</span> <span class="nf">add_method</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">method_func</span><span class="p">,</span> <span class="n">method_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">class_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dynamically add a method to an object.</span>

<span class="sd">    :param obj: The object to add a method to</span>
<span class="sd">    :param method_func: The function to use as a method. The first argument must be the object itself</span>
<span class="sd">        (usually called self)</span>
<span class="sd">    :param method_name: The desired function name. If None, will take method_func.__name__</span>
<span class="sd">    :param class_name:  The desired class name. If None, will take type(obj).__name__</span>
<span class="sd">    :return: the object, but with the additional method (or a different function for it)</span>

<span class="sd">    &gt;&gt;&gt; class A:</span>
<span class="sd">    ...     def __init__(self, x=10):</span>
<span class="sd">    ...         self.x = x</span>
<span class="sd">    &gt;&gt;&gt; def times(self, y):</span>
<span class="sd">    ...     return self.x * y</span>
<span class="sd">    &gt;&gt;&gt; def plus(self, y):</span>
<span class="sd">    ...     return self.x + y</span>
<span class="sd">    &gt;&gt;&gt; a = A(x=10)</span>
<span class="sd">    &gt;&gt;&gt; a = add_method(a, plus, &#39;__call__&#39;)  # add a __call__ method, assigning it to plus</span>
<span class="sd">    &gt;&gt;&gt; a(2)</span>
<span class="sd">    12</span>
<span class="sd">    &gt;&gt;&gt; a = add_method(a, times, &#39;__call__&#39;)  # reassign the __call__ method to times instead</span>
<span class="sd">    &gt;&gt;&gt; a(2)</span>
<span class="sd">    20</span>
<span class="sd">    &gt;&gt;&gt; a = add_method(a, plus, &#39;__getitem__&#39;)  # assign the method __getitem__ to plus</span>
<span class="sd">    &gt;&gt;&gt; a[2]  # see that it works</span>
<span class="sd">    12</span>
<span class="sd">    &gt;&gt;&gt; a(2)  # and that we still have our __call__ method</span>
<span class="sd">    20</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method_func</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">method_name</span> <span class="o">=</span> <span class="n">method_func</span>
        <span class="n">method_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">method_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">method_name</span> <span class="o">=</span> <span class="n">method_func</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="n">base</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">class_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="n">bases</span> <span class="o">=</span> <span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">+</span> <span class="p">(</span><span class="n">base</span><span class="p">,)</span>
    <span class="n">bases_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">bases</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">class_name</span> <span class="ow">in</span> <span class="n">bases_names</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
            <span class="n">class_name</span> <span class="o">+=</span> <span class="s1">&#39;_&#39;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">class_name</span> <span class="ow">in</span> <span class="n">bases_names</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;can&#39;t find a name for class that is not taken by bases. Consider using explicit name&quot;</span>
            <span class="p">)</span>

    <span class="n">new_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">dir</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">]))</span>

    <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">new_keys</span><span class="p">}</span>
    <span class="n">d</span><span class="p">[</span><span class="n">method_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">method_func</span>

    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">class_name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">d</span><span class="p">)()</span></div>


<span class="k">def</span> <span class="nf">transform_instance_method_input_and_output</span><span class="p">(</span>
    <span class="n">obj</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">method_output_trans</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">arg_trans</span>
<span class="p">):</span>
    <span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

    <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Not sure transform_instance_method_input_and_output works yet&#39;</span><span class="p">)</span>
    <span class="n">wrapped_method</span> <span class="o">=</span> <span class="n">transform_args</span><span class="p">(</span><span class="o">**</span><span class="n">arg_trans</span><span class="p">)(</span><span class="nb">getattr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">method</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">method_output_trans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">add_method</span><span class="p">(</span>
            <span class="n">obj</span><span class="p">,</span>
            <span class="n">wrap_method_output</span><span class="p">(</span><span class="n">method_output_trans</span><span class="p">)(</span><span class="n">wrapped_method</span><span class="p">),</span>
            <span class="n">method_name</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">add_method</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">wrapped_method</span><span class="p">,</span> <span class="n">method_name</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span>


<span class="k">def</span> <span class="nf">wrap_instance_methods</span><span class="p">(</span>
    <span class="n">_return_a_copy_of_the_class</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">_raise_error_if_non_existent_method</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">method_trans_spec</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">def</span> <span class="nf">obj_wrapper</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">method</span><span class="p">,</span> <span class="n">method_trans</span> <span class="ow">in</span> <span class="n">method_trans_spec</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">transform_instance_method_input_and_output</span><span class="p">(</span>
                    <span class="n">obj</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">method_trans</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">_raise_error_if_non_existent_method</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">):</span>
                    <span class="n">class_name</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">class_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> has no &#39;</span><span class="si">{}</span><span class="s2">&#39; method!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">class_name</span><span class="p">,</span> <span class="n">method</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">return</span> <span class="n">obj_wrapper</span>


<div class="viewcode-block" id="mk_method_trans_spec_from_methods_specs_dict"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.mk_method_trans_spec_from_methods_specs_dict">[docs]</a><span class="k">def</span> <span class="nf">mk_method_trans_spec_from_methods_specs_dict</span><span class="p">(</span><span class="n">methods_specs_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility to make inputs for wrap_class_methods_input_and_output more easily.</span>
<span class="sd">    :param methods_specs_dict: a dict where</span>
<span class="sd">        keys are method names (either a single string, or a tuple of strings)</span>
<span class="sd">        values are the trans_spec dicts that should be associated to those methods</span>
<span class="sd">    :return: A dict in the method_trans_spec (input of wrap_class_method) format.</span>

<span class="sd">    &gt;&gt;&gt; methods_specs_dict = {}</span>
<span class="sd">    &gt;&gt;&gt; methods_specs_dict[&#39;foo&#39;] = {&#39;x&#39;: str, &#39;y&#39;: int}</span>
<span class="sd">    &gt;&gt;&gt; methods_specs_dict[(&#39;foo&#39;, &#39;bar&#39;)] = {&#39;z&#39;: list, &#39;method_output_trans&#39;: float}</span>
<span class="sd">    &gt;&gt;&gt; methods_specs_dict[(&#39;bar&#39;, )] = {&#39;zz&#39;: int}</span>
<span class="sd">    &gt;&gt;&gt; method_trans_spec = mk_method_trans_spec_from_methods_specs_dict(methods_specs_dict)</span>
<span class="sd">    &gt;&gt;&gt; list(method_trans_spec.keys())</span>
<span class="sd">    [&#39;foo&#39;, &#39;bar&#39;]</span>
<span class="sd">    &gt;&gt;&gt; method_trans_spec[&#39;foo&#39;]</span>
<span class="sd">    {&#39;x&#39;: &lt;class &#39;str&#39;&gt;, &#39;y&#39;: &lt;class &#39;int&#39;&gt;, &#39;z&#39;: &lt;class &#39;list&#39;&gt;, &#39;method_output_trans&#39;: &lt;class &#39;float&#39;&gt;}</span>
<span class="sd">    &gt;&gt;&gt; method_trans_spec[&#39;bar&#39;]</span>
<span class="sd">    {&#39;z&#39;: &lt;class &#39;list&#39;&gt;, &#39;method_output_trans&#39;: &lt;class &#39;float&#39;&gt;, &#39;zz&#39;: &lt;class &#39;int&#39;&gt;}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">method_trans_spec</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">methods</span><span class="p">,</span> <span class="n">specs</span> <span class="ow">in</span> <span class="n">methods_specs_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">methods</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">methods</span> <span class="o">=</span> <span class="p">(</span><span class="n">methods</span><span class="p">,)</span>
        <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">methods</span><span class="p">:</span>
            <span class="n">method_trans_spec</span><span class="p">[</span><span class="n">method</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">method_trans_spec</span><span class="p">)</span></div>


<span class="n">Args</span> <span class="o">=</span> <span class="n">Tuple</span>
<span class="n">Kwargs</span> <span class="o">=</span> <span class="n">Dict</span>
<span class="n">WhatToLog</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Callable</span><span class="p">,</span> <span class="n">Args</span><span class="p">,</span> <span class="n">Kwargs</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_special_str</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">max_len</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A util function for _call_signature&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&#39;&quot;</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_str</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_len</span><span class="p">:</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;__repr__&#39;</span><span class="p">):</span>
                <span class="n">value_str</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value_str</span> <span class="o">=</span> <span class="n">x_str</span>
            <span class="n">x_str</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{}</span><span class="s1">...)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">value_str</span><span class="p">[:</span><span class="mi">20</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">x_str</span>


<span class="k">def</span> <span class="nf">_call_signature</span><span class="p">(</span><span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">:</span> <span class="n">Kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A util to make a string representation of a call of a function func with given args and kwargs.</span>
<span class="sd">    Meant to be the default mk_log_str of mk_call_logger.</span>
<span class="sd">    :param func: A callable</span>
<span class="sd">    :param args: A tuple of positional arguments</span>
<span class="sd">    :param kwargs: A dict of key=val arguments</span>
<span class="sd">    :return: A string to represent all of that.</span>

<span class="sd">    &gt;&gt;&gt; args = (2, &#39;sdf&#39;, list(range(1000)))</span>
<span class="sd">    &gt;&gt;&gt; kwargs = {&#39;z&#39;: &#39;boo&#39;, &#39;zzz&#39;: 10}</span>
<span class="sd">    &gt;&gt;&gt; print(_call_signature(_call_signature, args, kwargs))</span>
<span class="sd">    _call_signature(2, &#39;sdf&#39;, list([0, 1, 2, 3, 4, 5, 6...), z=&#39;boo&#39;, zzz=10)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args_signature</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_special_str</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
    <span class="n">kwargs_signature</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">_special_str</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{func_name}</span><span class="s1">(</span><span class="si">{signature}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">func_name</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
        <span class="n">signature</span><span class="o">=</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">args_signature</span><span class="p">,</span> <span class="n">kwargs_signature</span><span class="p">]),</span>
    <span class="p">)</span>


<div class="viewcode-block" id="mk_call_logger"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.mk_call_logger">[docs]</a><span class="k">def</span> <span class="nf">mk_call_logger</span><span class="p">(</span>
    <span class="n">logger</span><span class="o">=</span><span class="nb">print</span><span class="p">,</span>
    <span class="n">what_to_log</span><span class="p">:</span> <span class="n">WhatToLog</span> <span class="o">=</span> <span class="n">_call_signature</span><span class="p">,</span>
    <span class="n">log_output</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">func_is_bounded</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Makes a decorator that logs each call to the wrapped function.</span>
<span class="sd">    :param logger: The actual function that logs stuff. Default is print. The &quot;stuff&quot; it logs is given by</span>
<span class="sd">        the what_to_log argument (a function).</span>
<span class="sd">    :param what_to_log: A function taking inputs (func, args, kwargs) of the call, and returning something to log</span>
<span class="sd">        (usually, and by default, a string)</span>
<span class="sd">    :param func_is_bounded: Whether the function is bounded (like a method) or not</span>
<span class="sd">    :return: A decorator</span>

<span class="sd">    &gt;&gt;&gt; # Example of use on (unbounded) function, with default args</span>
<span class="sd">    &gt;&gt;&gt; @mk_call_logger()</span>
<span class="sd">    ... def useless_computation(x, y=2, z=&#39;foo&#39;):</span>
<span class="sd">    ...     return z * (x + y)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; _ = useless_computation(3, y=1, z=&#39;ha&#39;)</span>
<span class="sd">    useless_computation(3, y=1, z=&#39;ha&#39;)</span>

<span class="sd">    The same example, but with output logging too</span>

<span class="sd">    &gt;&gt;&gt; @mk_call_logger(log_output=True)</span>
<span class="sd">    ... def useless_computation(x, y=2, z=&#39;foo&#39;):</span>
<span class="sd">    ...     return z * (x + y)</span>
<span class="sd">    &gt;&gt;&gt; _ = useless_computation(3, y=1, z=&#39;ha&#39;)</span>
<span class="sd">    useless_computation(3, y=1, z=&#39;ha&#39;)</span>
<span class="sd">    -&gt; hahahaha</span>

<span class="sd">    And now a bit more involved...</span>

<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Example of use on class method, with a different what_to_log function.</span>
<span class="sd">    &gt;&gt;&gt; class A:</span>
<span class="sd">    ...     def __init__(self, a=10):</span>
<span class="sd">    ...         self.a = a</span>
<span class="sd">    ...     def add(self, x):</span>
<span class="sd">    ...         return self.a + x</span>
<span class="sd">    ...     def multiply(self, x):</span>
<span class="sd">    ...         return self.a * x</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; def _name_args_kwargs(func, args, kwargs) -&gt; str:</span>
<span class="sd">    ...     return &quot;Calling {} with\\n  args={}\\n  kwargs={}&quot;.format(func.__name__, args, kwargs)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; log_calls = mk_call_logger(what_to_log=_name_args_kwargs, func_is_bounded=True)</span>
<span class="sd">    &gt;&gt;&gt; for method in [&#39;add&#39;, &#39;multiply&#39;]:</span>
<span class="sd">    ...     A_method = getattr(A, method)</span>
<span class="sd">    ...     setattr(A, method, mk_call_logger(what_to_log=_name_args_kwargs, func_is_bounded=True)(A_method))</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; a = A()</span>
<span class="sd">    &gt;&gt;&gt; a.add(x=2)</span>
<span class="sd">    Calling add with</span>
<span class="sd">      args=()</span>
<span class="sd">      kwargs={&#39;x&#39;: 2}</span>
<span class="sd">    12</span>
<span class="sd">    &gt;&gt;&gt; a.multiply(2)</span>
<span class="sd">    Calling multiply with</span>
<span class="sd">      args=(2,)</span>
<span class="sd">      kwargs={}</span>
<span class="sd">    20</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">log_output</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">log_output</span> <span class="o">=</span> <span class="s1">&#39;-&gt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span>
    <span class="k">assert</span> <span class="n">log_output</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span> <span class="n">callable</span><span class="p">(</span><span class="n">log_output</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">func_is_bounded</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">log_calls</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">logger</span><span class="p">(</span><span class="n">what_to_log</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">log_output</span> <span class="ow">and</span> <span class="n">logger</span><span class="p">(</span><span class="n">log_output</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">out</span>

            <span class="n">_func</span><span class="o">.</span><span class="n">_logged_with</span> <span class="o">=</span> <span class="n">logger</span>

            <span class="k">return</span> <span class="n">_func</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">log_calls</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">logger</span><span class="p">(</span><span class="n">what_to_log</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">log_output</span> <span class="ow">and</span> <span class="n">logger</span><span class="p">(</span><span class="n">log_output</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">out</span>

            <span class="n">_func</span><span class="o">.</span><span class="n">_logged_with</span> <span class="o">=</span> <span class="n">logger</span>

            <span class="k">return</span> <span class="n">_func</span>

    <span class="k">return</span> <span class="n">log_calls</span></div>


<div class="viewcode-block" id="get_callable_from_factory_if_no_arguments"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.get_callable_from_factory_if_no_arguments">[docs]</a><span class="k">def</span> <span class="nf">get_callable_from_factory_if_no_arguments</span><span class="p">(</span><span class="n">func_or_factory_thereof</span><span class="p">:</span> <span class="n">Callable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Will return the input itself if it&#39;s a callable with at least one argument.</span>
<span class="sd">    If not, it will consider it to be a factory, call it to get the actual</span>
<span class="sd">    callable object that the user presumably is seeking to get&quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span>
        <span class="n">func_or_factory_thereof</span>
    <span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">func_or_factory_thereof</span><span class="si">}</span><span class="s1"> needs to be callable&#39;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="n">func_or_factory_thereof</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># if func_or_factory_thereof has no arguments, assume it&#39;s a factory</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">func_or_factory_thereof</span><span class="p">()</span>
        <span class="c1"># and make sure that now we have arguments</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">Callable</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Your func_or_factory_thereof had no arguments, so I assumed it &#39;</span>
                <span class="s2">&quot;was a factory, called it, but that didn&#39;t produce a &quot;</span>
                <span class="s2">&quot;callable with at least one argument. So I don&#39;t know what to do.&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">func_or_factory_thereof</span>
    <span class="k">return</span> <span class="n">func</span></div>


<span class="c1">## This one didn&#39;t actually handle position only correctly (just signature)</span>
<span class="c1"># def old_ch_func_to_all_pk(func):</span>
<span class="c1">#     &quot;&quot;&quot;Returns a copy of the function where all arguments are of the PK kind.</span>
<span class="c1">#     (PK: Positional_or_keyword)</span>
<span class="c1">#</span>
<span class="c1">#     :param func: A callable</span>
<span class="c1">#     :return:</span>
<span class="c1">#</span>
<span class="c1">#     &gt;&gt;&gt; from py2http.decorators import signature, ch_func_to_all_pk</span>
<span class="c1">#     &gt;&gt;&gt;</span>
<span class="c1">#     &gt;&gt;&gt; def f(a, /, b, *, c=None, **kwargs): ...</span>
<span class="c1">#     ...</span>
<span class="c1">#     &gt;&gt;&gt; print(signature(f))</span>
<span class="c1">#     (a, /, b, *, c=None, **kwargs)</span>
<span class="c1">#     &gt;&gt;&gt; ff = old_ch_func_to_all_pk(f)</span>
<span class="c1">#     &gt;&gt;&gt; print(signature(ff))</span>
<span class="c1">#     (a, b, c=None, **kwargs)</span>
<span class="c1">#     &gt;&gt;&gt; def g(x, y=1, *args, **kwargs): ...</span>
<span class="c1">#     ...</span>
<span class="c1">#     &gt;&gt;&gt; print(signature(g))</span>
<span class="c1">#     (x, y=1, *args, **kwargs)</span>
<span class="c1">#     &gt;&gt;&gt; gg = old_ch_func_to_all_pk(g)</span>
<span class="c1">#     &gt;&gt;&gt; print(signature(gg))</span>
<span class="c1">#     (x, y=1, args=(), **kwargs)</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     func = tuple_the_args(func)</span>
<span class="c1">#     sig = signature(func)</span>
<span class="c1">#     func.__signature__ = ch_signature_to_all_pk(sig)</span>
<span class="c1">#     return func</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright OtoSense 2020.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
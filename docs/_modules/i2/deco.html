
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>i2.deco &#8212; i2 0.0.19 documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for i2.deco</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">suppress</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span><span class="p">,</span> <span class="n">partial</span><span class="p">,</span> <span class="n">update_wrapper</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Signature</span><span class="p">,</span> <span class="n">signature</span><span class="p">,</span> <span class="n">Parameter</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">FunctionType</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterable</span>

<span class="kn">from</span> <span class="nn">i2.signatures</span> <span class="kn">import</span> <span class="n">ch_signature_to_all_pk</span><span class="p">,</span> <span class="n">HasParams</span><span class="p">,</span> <span class="n">VP</span><span class="p">,</span> <span class="n">PK</span><span class="p">,</span> <span class="n">Sig</span>


<div class="viewcode-block" id="double_up_as_factory"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.double_up_as_factory">[docs]</a><span class="k">def</span> <span class="nf">double_up_as_factory</span><span class="p">(</span><span class="n">decorator_func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Repurpose a decorator both as it&#39;s original form, and as a decorator factory.</span>

<span class="sd">    That is, from a decorator that is defined do ``wrapped_func = decorator(func, **params)``,</span>
<span class="sd">    make it also be able to do ``wrapped_func = decorator(**params)(func)``.</span>

<span class="sd">    Note: You&#39;ll only be able to do this if all but the first argument are keyword-only,</span>
<span class="sd">    and the first argument (the function to decorate) has a default of ``None`` (this is for your own good).</span>
<span class="sd">    This is validated before making the &quot;double up as factory&quot; decorator.</span>

<span class="sd">    &gt;&gt;&gt; @double_up_as_factory</span>
<span class="sd">    ... def decorator(func=None, *, multiplier=2):</span>
<span class="sd">    ...     def _func(x):</span>
<span class="sd">    ...         return func(x) * multiplier</span>
<span class="sd">    ...     return _func</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; def foo(x):</span>
<span class="sd">    ...     return x + 1</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; foo(2)</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; wrapped_foo = decorator(foo, multiplier=10)</span>
<span class="sd">    &gt;&gt;&gt; wrapped_foo(2)</span>
<span class="sd">    30</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; multiply_by_3 = decorator(multiplier=3)</span>
<span class="sd">    &gt;&gt;&gt; wrapped_foo = multiply_by_3(foo)</span>
<span class="sd">    &gt;&gt;&gt; wrapped_foo(2)</span>
<span class="sd">    9</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; @decorator(multiplier=3)</span>
<span class="sd">    ... def foo(x):</span>
<span class="sd">    ...     return x + 1</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; foo(2)</span>
<span class="sd">    9</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">validate_decorator_func</span><span class="p">(</span><span class="n">decorator_func</span><span class="p">):</span>
        <span class="n">first_param</span><span class="p">,</span> <span class="o">*</span><span class="n">other_params</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span>
            <span class="n">decorator_func</span>
        <span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">first_param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;First argument of the decorator function needs to default to None. Was </span><span class="si">{</span><span class="n">first_param</span><span class="o">.</span><span class="n">default</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">other_params</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;All arguments (besides the first) need to be keyword-only&#39;</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="n">validate_decorator_func</span><span class="p">(</span><span class="n">decorator_func</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">decorator_func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_double_up_as_factory</span><span class="p">(</span><span class="n">wrapped</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">wrapped</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># then we want a factory</span>
            <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">decorator_func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">decorator_func</span><span class="p">(</span><span class="n">wrapped</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_double_up_as_factory</span></div>


<div class="viewcode-block" id="copy_func"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.copy_func">[docs]</a><span class="k">def</span> <span class="nf">copy_func</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Copy a function (not sure it works with all types of callables)&quot;&quot;&quot;</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">FunctionType</span><span class="p">(</span>
        <span class="n">f</span><span class="o">.</span><span class="vm">__code__</span><span class="p">,</span>
        <span class="n">f</span><span class="o">.</span><span class="vm">__globals__</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
        <span class="n">argdefs</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="vm">__defaults__</span><span class="p">,</span>
        <span class="n">closure</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="vm">__closure__</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">update_wrapper</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="vm">__kwdefaults__</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="vm">__kwdefaults__</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;__signature__&#39;</span><span class="p">):</span>
        <span class="n">g</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">__signature__</span>
    <span class="k">return</span> <span class="n">g</span></div>


<span class="k">def</span> <span class="nf">transparently_wrapped</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">transparently_wrapped_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">transparently_wrapped_func</span>


<span class="k">def</span> <span class="nf">params_of</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">HasParams</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Signature</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">elif</span> <span class="n">callable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">Parameter</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">obj</span>
    <span class="p">),</span> <span class="s1">&#39;obj needs to be a Iterable[Parameter] at this point&#39;</span>
    <span class="k">return</span> <span class="n">obj</span>  <span class="c1"># as is</span>


<div class="viewcode-block" id="tuple_the_args"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.tuple_the_args">[docs]</a><span class="k">def</span> <span class="nf">tuple_the_args</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A decorator that will change a VAR_POSITIONAL (*args) argument to a tuple (args)</span>
<span class="sd">    argument of the same name.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">params_of</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">is_vp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">VP</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">is_vp</span><span class="p">):</span>
        <span class="n">index_of_vp</span> <span class="o">=</span> <span class="n">is_vp</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># there&#39;s can be only one</span>

        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">vpless_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="c1"># extract the element of args that needs to be unraveled</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">_vp_args_</span><span class="p">,</span> <span class="n">aa</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">args</span><span class="p">[:</span><span class="n">index_of_vp</span><span class="p">],</span>
                <span class="n">args</span><span class="p">[</span><span class="n">index_of_vp</span><span class="p">],</span>
                <span class="n">args</span><span class="p">[(</span><span class="n">index_of_vp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">:],</span>
            <span class="p">)</span>
            <span class="c1"># call the original function with the unravelled args</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">_vp_args_</span><span class="p">,</span> <span class="o">*</span><span class="n">aa</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>  <span class="c1"># TODO: Avoid this try catch. Look in advance for default ordering</span>
            <span class="n">params</span><span class="p">[</span><span class="n">index_of_vp</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">index_of_vp</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                <span class="n">kind</span><span class="o">=</span><span class="n">PK</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="n">vpless_func</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">return_annotation</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="n">index_of_vp</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">index_of_vp</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">PK</span><span class="p">)</span>
            <span class="n">vpless_func</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span>
                <span class="n">params</span><span class="p">,</span> <span class="n">return_annotation</span><span class="o">=</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">return_annotation</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">vpless_func</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">copy_func</span><span class="p">(</span>
            <span class="n">func</span>
        <span class="p">)</span>  <span class="c1"># don&#39;t change anything (or should we wrap anyway, to be consistent?)</span></div>


<div class="viewcode-block" id="mk_args_kwargs_merger"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.mk_args_kwargs_merger">[docs]</a><span class="k">def</span> <span class="nf">mk_args_kwargs_merger</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a function that will return a dict containing all {argname: argval} pairs from a function&#39;s call.</span>
<span class="sd">    That is, it merges all non-keyword arguments with the keyword-arguments, with the right name, so that</span>
<span class="sd">    the arguments can be handled more uniformly.</span>
<span class="sd">    :param func: The function that will be called, whose signature should be looked at to make the</span>
<span class="sd">        merging function</span>
<span class="sd">    :return: A function merge_args_and_kwargs(args, kwargs) that can be used to merge arguments</span>

<span class="sd">    &gt;&gt;&gt; def func(a, b, c=3):</span>
<span class="sd">    ...     return a * (b + c)</span>
<span class="sd">    &gt;&gt;&gt; merger = mk_args_kwargs_merger(func)</span>
<span class="sd">    &gt;&gt;&gt; dict(merger([1], {&#39;b&#39;: 10}))</span>
<span class="sd">    {&#39;a&#39;: 1, &#39;b&#39;: 10}</span>
<span class="sd">    &gt;&gt;&gt; dict(merger([], {&#39;a&#39;: 1, &#39;b&#39;: 10}))</span>
<span class="sd">    {&#39;a&#39;: 1, &#39;b&#39;: 10}</span>
<span class="sd">    &gt;&gt;&gt; dict(merger([1, 10], {}))</span>
<span class="sd">    {&#39;a&#39;: 1, &#39;b&#39;: 10}</span>
<span class="sd">    &gt;&gt;&gt; dict(merger([], {}))</span>
<span class="sd">    {}</span>
<span class="sd">    &gt;&gt;&gt; # Usage demo:</span>
<span class="sd">    &gt;&gt;&gt; assert func(*[1], **{&#39;b&#39;: 10}) == func(**merger([1], {&#39;b&#39;: 10}))</span>
<span class="sd">    &gt;&gt;&gt; assert func(*[], **{&#39;a&#39;: 1, &#39;b&#39;: 10}) == func(**merger([], {&#39;a&#39;: 1, &#39;b&#39;: 10}))</span>
<span class="sd">    &gt;&gt;&gt; assert func(**{&#39;a&#39;: 1, &#39;b&#39;: 10}) == func(**merger([], {&#39;a&#39;: 1, &#39;b&#39;: 10}))</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">merge_args_and_kwargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">bind_partial</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">arguments</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">kwargs</span>

    <span class="k">return</span> <span class="n">merge_args_and_kwargs</span></div>


<span class="k">def</span> <span class="nf">ensure_iterable_of_callables</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="nb">all</span><span class="p">(</span><span class="n">callable</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span>


<div class="viewcode-block" id="kwargs_for_func"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.kwargs_for_func">[docs]</a><span class="k">def</span> <span class="nf">kwargs_for_func</span><span class="p">(</span><span class="o">*</span><span class="n">funcs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param funcs:</span>
<span class="sd">    :param kwargs:</span>
<span class="sd">    :return:</span>

<span class="sd">    &gt;&gt;&gt; from i2.tests.objects_for_testing import formula1, sum_of_args, mult, add</span>
<span class="sd">    &gt;&gt;&gt; def print_dict(d):  # just a util for this doctest</span>
<span class="sd">    ...     from pprint import pprint</span>
<span class="sd">    ...     pprint({k.__name__: d[k] for k in sorted(d, key=lambda x: x.__name__)})</span>
<span class="sd">    &gt;&gt;&gt; print_dict(kwargs_for_func(formula1, mult, add,</span>
<span class="sd">    ...                           w=1, x=2, z=3, a=4, b=5)) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    {&#39;add&#39;: {&#39;a&#39;: 4, &#39;b&#39;: 5},</span>
<span class="sd">     &#39;formula1&#39;: {&#39;w&#39;: 1, &#39;x&#39;: 2, &#39;z&#39;: 3},</span>
<span class="sd">     &#39;mult&#39;: {&#39;x&#39;: 2}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">func</span><span class="p">,</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">source_kwargs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span> <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">)</span></div>


<span class="c1"># TODO: Finish this!</span>
<span class="c1"># TODO: Test the handling var positional and var keyword</span>
<div class="viewcode-block" id="MultiFunc"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.MultiFunc">[docs]</a><span class="k">class</span> <span class="nc">MultiFunc</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Call multiple functions, using a pool of arguments that they will draw from.</span>

<span class="sd">    &gt;&gt;&gt; from i2.tests.objects_for_testing import formula1, sum_of_args, mult, add</span>
<span class="sd">    &gt;&gt;&gt; mf1 = MultiFunc(funcs=(formula1, mult, add))</span>
<span class="sd">    &gt;&gt;&gt; kwargs_for_func = mf1.kwargs_for_func(w=1, x=2, z=3, a=4, b=5)</span>

<span class="sd">    What&#39;s this for? Well, the raison d&#39;etre of `MultiFunc` is to be able to do this:</span>

<span class="sd">    &gt;&gt;&gt; assert add(a=4, b=5) == add(**kwargs_for_func[add])</span>

<span class="sd">    This wouldn&#39;t work on all functions since some functions have position only arguments (e.g. ``formula1``).</span>
<span class="sd">    Therefore ``MultiFunc`` holds a &quot;normalized&quot; form of the functions; namely one that handles such things as</span>
<span class="sd">    postion only and varargs.</span>

<span class="sd">    # TODO: Make this work!</span>
<span class="sd">    #   Right now raises: TypeError: formula1() got some positional-only arguments passed as keyword arguments: &#39;w&#39;</span>
<span class="sd">    # &gt;&gt;&gt; assert formula1(1, x=2, z=3) == mf1.normalized_funcs[formula1](**kwargs_for_func[formula1])</span>

<span class="sd">    Note: In the following, it looks like ``MultiFunc`` instances return dicts whose keys are strings.</span>
<span class="sd">    This is not the case.</span>
<span class="sd">    The keys are functions: The same functions that were input.</span>
<span class="sd">    The reason for not using functions is that when printed, they include their hash, which invalidates the doctests.</span>

<span class="sd">    &gt;&gt;&gt; def print_dict(d):  # just a util for this doctest</span>
<span class="sd">    ...     from pprint import pprint</span>
<span class="sd">    ...     pprint({k.__name__: d[k] for k in sorted(d, key=lambda x: x.__name__)})</span>
<span class="sd">    &gt;&gt;&gt; mf1 = MultiFunc(funcs=(formula1, mult, add))</span>
<span class="sd">    &gt;&gt;&gt; print_dict(mf1.kwargs_for_func(w=1, x=2, z=3, a=4, b=5)) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    {&#39;add&#39;: {&#39;a&#39;: 4, &#39;b&#39;: 5},</span>
<span class="sd">     &#39;formula1&#39;: {&#39;w&#39;: 1, &#39;x&#39;: 2, &#39;z&#39;: 3},</span>
<span class="sd">     &#39;mult&#39;: {&#39;x&#39;: 2}}</span>

<span class="sd">    Oh, and you can actually see the signature of kwargs_for_func:</span>
<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; signature(mf1)</span>
<span class="sd">    &lt;Signature (w, x: float, a, y=1, z: int = 1, b: float = 0.0)&gt;</span>

<span class="sd">    &gt;&gt;&gt; mf2 = MultiFunc(funcs=(formula1, mult, add, sum_of_args))</span>
<span class="sd">    &gt;&gt;&gt; print_dict(mf2.kwargs_for_func(w=1, x=2, z=3, a=4, b=5, args=(7,8), kwargs={&#39;a&#39;: 42}, extra_stuff=&#39;ignore&#39;))</span>
<span class="sd">    {&#39;add&#39;: {&#39;a&#39;: 4, &#39;b&#39;: 5},</span>
<span class="sd">     &#39;formula1&#39;: {&#39;w&#39;: 1, &#39;x&#39;: 2, &#39;z&#39;: 3},</span>
<span class="sd">     &#39;mult&#39;: {&#39;x&#39;: 2},</span>
<span class="sd">     &#39;sum_of_args&#39;: {&#39;kwargs&#39;: {&#39;a&#39;: 4,</span>
<span class="sd">                                &#39;args&#39;: (7, 8),</span>
<span class="sd">                                &#39;b&#39;: 5,</span>
<span class="sd">                                &#39;extra_stuff&#39;: &#39;ignore&#39;,</span>
<span class="sd">                                &#39;kwargs&#39;: {&#39;a&#39;: 42},</span>
<span class="sd">                                &#39;w&#39;: 1,</span>
<span class="sd">                                &#39;x&#39;: 2,</span>
<span class="sd">                                &#39;z&#39;: 3}}}</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># FIXME: TODO: This does indeed change the signature, but not the functionality (position only still raise errors!)</span>
    <span class="k">def</span> <span class="nf">normalize_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ch_func_to_all_pk</span><span class="p">(</span><span class="n">tuple_the_args</span><span class="p">(</span><span class="n">func</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">funcs</span><span class="o">=</span><span class="p">()):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">funcs</span> <span class="o">=</span> <span class="n">ensure_iterable_of_callables</span><span class="p">(</span><span class="n">funcs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigs</span> <span class="o">=</span> <span class="p">{</span><span class="n">func</span><span class="p">:</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">funcs</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalized_funcs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">func</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize_func</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">funcs</span>
        <span class="p">}</span>
        <span class="n">multi_func_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="o">.</span><span class="n">from_objs</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">normalized_funcs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="c1"># TODO: Finish attempt to add **all_other_kwargs_ignored to the signature</span>
        <span class="c1"># multi_func_sig = (Sig.from_objs(</span>
        <span class="c1">#     *self.normalized_funcs.values(),</span>
        <span class="c1">#     Parameter(name=&#39;all_other_kwargs_ignored&#39;, kind=Parameter.VAR_KEYWORD)))</span>
        <span class="n">multi_func_sig</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># multi_func_sig.wrap(self.kwargs_for_func)</span>

    <span class="k">def</span> <span class="nf">kwargs_for_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigs</span><span class="p">[</span><span class="n">func</span><span class="p">]</span><span class="o">.</span><span class="n">source_kwargs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">funcs</span>
        <span class="p">)</span>

    <span class="c1"># TODO: Give it a signature (needs to be done in __init__)</span>
    <span class="c1"># TODO: Validation of inputs</span>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigs</span><span class="p">[</span><span class="n">func</span><span class="p">]</span><span class="o">.</span><span class="n">source_kwargs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">funcs</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="assert_attrs"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.assert_attrs">[docs]</a><span class="k">def</span> <span class="nf">assert_attrs</span><span class="p">(</span><span class="n">attrs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Asserts, at construction time, that the class contains a specific set of attributes</span>
<span class="sd">    :param attrs: An attribute name (string) or a list of attribute names whose existence needs to be enforced.</span>
<span class="sd">    :return: A class decorator that will enforce the existence of the attrs when an instance is made</span>
<span class="sd">    &gt;&gt;&gt; @assert_attrs(&#39;foo&#39;)</span>
<span class="sd">    ... class A:</span>
<span class="sd">    ...     bar = 10</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; try:</span>
<span class="sd">    ...     a = A()</span>
<span class="sd">    ... except AttributeError:</span>
<span class="sd">    ...     print(&quot;AttributeError, as expected, because missing the foo attribute&quot;)</span>
<span class="sd">    AttributeError, as expected, because missing the foo attribute</span>
<span class="sd">    &gt;&gt;&gt; @assert_attrs(&#39;foo&#39;)</span>
<span class="sd">    ... class B:</span>
<span class="sd">    ...     def foo(self): pass</span>
<span class="sd">    &gt;&gt;&gt; b = B()</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; class A:</span>
<span class="sd">    ...     bar = 10</span>
<span class="sd">    &gt;&gt;&gt; class B:</span>
<span class="sd">    ...     def foo(self): pass</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; @assert_attrs([&#39;foo&#39;, &#39;bar&#39;])</span>
<span class="sd">    ... class C(A, B):</span>
<span class="sd">    ...     pass</span>
<span class="sd">    &gt;&gt;&gt; c = C()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">attrs</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_assert_attrs</span><span class="p">(</span><span class="n">klass</span><span class="p">):</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">klass</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">get_instance</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                        <span class="s1">&#39;class </span><span class="si">{}</span><span class="s1"> needs to have a </span><span class="si">{}</span><span class="s1"> attribute:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">klass</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">attr</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">return</span> <span class="n">klass</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">get_instance</span>

    <span class="k">return</span> <span class="n">_assert_attrs</span></div>


<div class="viewcode-block" id="preprocess_arguments"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.preprocess_arguments">[docs]</a><span class="k">def</span> <span class="nf">preprocess_arguments</span><span class="p">(</span><span class="n">pre</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply a function to args, kwargs and use the transformed in the decorated function&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">pre</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)(</span><span class="n">wrapper</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">decorator</span></div>


<span class="k">def</span> <span class="nf">preprocess</span><span class="p">(</span><span class="n">pre</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pre</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">pre</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)(</span><span class="n">wrapper</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">decorator</span>


<span class="k">def</span> <span class="nf">_return_annotation_of</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return annotation of callable (if type, will return type systematically)</span>

<span class="sd">    &gt;&gt;&gt; def foo() -&gt; bool: ...</span>
<span class="sd">    &gt;&gt;&gt; assert _return_annotation_of(foo) == bool</span>
<span class="sd">    &gt;&gt;&gt; assert _return_annotation_of(zip) == zip</span>
<span class="sd">    &gt;&gt;&gt; assert _return_annotation_of(print) == Parameter.empty</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span>
        <span class="n">func</span><span class="p">,</span> <span class="nb">type</span>
    <span class="p">):</span>  <span class="c1"># TODO: Verify rule (are there commmon enough meta tricks that need to be handled?)</span>
        <span class="k">return</span> <span class="n">func</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">return_annotation</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># some builtins don&#39;t have signatures</span>
            <span class="k">return</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">empty</span>


<div class="viewcode-block" id="OutputPostProcessingError"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.OutputPostProcessingError">[docs]</a><span class="k">class</span> <span class="nc">OutputPostProcessingError</span><span class="p">(</span><span class="ne">RuntimeError</span><span class="p">):</span>
    <span class="o">...</span></div>


<div class="viewcode-block" id="postprocess"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.postprocess">[docs]</a><span class="k">def</span> <span class="nf">postprocess</span><span class="p">(</span>
    <span class="n">post</span><span class="p">,</span> <span class="n">caught_post_errors</span><span class="o">=</span><span class="p">(</span><span class="ne">Exception</span><span class="p">,),</span> <span class="n">verbose_error_message</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add some post-processing after a function</span>

<span class="sd">    :param post: The function to apply to the output</span>

<span class="sd">    &gt;&gt;&gt; list_range = postprocess(list)(range)</span>
<span class="sd">    &gt;&gt;&gt; list_range(4)</span>
<span class="sd">    [0, 1, 2, 3]</span>
<span class="sd">    &gt;&gt;&gt; sum_range = postprocess(sum)(range)</span>
<span class="sd">    &gt;&gt;&gt; sum_range(4)</span>
<span class="sd">    6</span>

<span class="sd">    Note: The decorator also sticks the return annotation of the post function on the wrapped one.</span>

<span class="sd">    Use cases:</span>

<span class="sd">    - Changing a generator into a container returning function</span>
<span class="sd">        In many situations, writing a generator is simpler than writing a function</span>
<span class="sd">        that accumulates a list or a dict etc.</span>
<span class="sd">        So here, you just write the generator and tag this decorator on top, to get the same effect.</span>

<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; @postprocess(dict)</span>
<span class="sd">    ... def bar(x):</span>
<span class="sd">    ...     for i in range(x):</span>
<span class="sd">    ...         yield str(i), i</span>
<span class="sd">    &gt;&gt;&gt; bar(3)</span>
<span class="sd">    {&#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2}</span>
<span class="sd">    &gt;&gt;&gt; signature(bar)</span>
<span class="sd">    &lt;Signature (x) -&gt; dict&gt;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; @postprocess(list)</span>
<span class="sd">    ... def foo(x):</span>
<span class="sd">    ...     for i in range(x):</span>
<span class="sd">    ...         yield i</span>
<span class="sd">    &gt;&gt;&gt; foo(3)</span>
<span class="sd">    [0, 1, 2]</span>
<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; signature(foo)</span>
<span class="sd">    &lt;Signature (x) -&gt; list&gt;</span>

<span class="sd">    - Triggering something (like logging, or forwarding) when a function returns</span>

<span class="sd">    &gt;&gt;&gt; def log_this(x):</span>
<span class="sd">    ...     print(f&quot;Logging {x}&quot;)</span>
<span class="sd">    ...     return x</span>
<span class="sd">    &gt;&gt;&gt; logged_foo = postprocess(log_this)(foo)</span>
<span class="sd">    &gt;&gt;&gt; t = logged_foo(2)</span>
<span class="sd">    Logging [0, 1]</span>
<span class="sd">    &gt;&gt;&gt; assert t == [0, 1]</span>

<span class="sd">    - Using a function that does a lot to make several functions that do less.</span>
<span class="sd">        (e.g. Extracting/making a python object from a function returning a raw http response_</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">post</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">caught_post_errors</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Error when postprocessing output with post func: </span><span class="si">{</span><span class="n">func</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose_error_message</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;  output=</span><span class="si">{</span><span class="n">output</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="k">if</span> <span class="p">(</span>
                        <span class="nb">isinstance</span><span class="p">(</span><span class="n">verbose_error_message</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="n">verbose_error_message</span> <span class="o">&gt;</span> <span class="mi">1</span>
                    <span class="p">):</span>
                        <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                            <span class="o">+</span> <span class="s1">&#39;  which was obtained by func(*args, **kwargs) where:&#39;</span>
                        <span class="p">)</span>
                        <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                            <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;    args: </span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s1">&#39;</span>
                            <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                            <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;    kwargs: </span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s1">&#39;</span>
                        <span class="p">)</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;Error is: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="k">raise</span> <span class="n">OutputPostProcessingError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">return_annot</span> <span class="o">=</span> <span class="n">_return_annotation_of</span><span class="p">(</span><span class="n">post</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">suppress</span><span class="p">(</span>
            <span class="ne">ValueError</span>
        <span class="p">):</span>  <span class="c1"># intended to catch cases where wrapper doesn&#39;t have a signature</span>
            <span class="n">wrapper_signature</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">wrapper</span><span class="p">)</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">Signature</span><span class="p">(</span>
                <span class="n">wrapper_signature</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
                <span class="n">return_annotation</span><span class="o">=</span><span class="n">return_annot</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">wrapper</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">sig</span>

        <span class="k">return</span> <span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)(</span><span class="n">wrapper</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">decorator</span></div>


<div class="viewcode-block" id="input_output_decorator"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.input_output_decorator">[docs]</a><span class="k">def</span> <span class="nf">input_output_decorator</span><span class="p">(</span><span class="n">preprocess</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">postprocess</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Makes a decorator that preprocesses inputs and postprocesses outputs.</span>
<span class="sd">    Use it if you want to transform the input of a function or method before calling it, or if you want</span>
<span class="sd">    to transform the returned value before returning it.</span>
<span class="sd">    :param preprocess: Function to be applied to input</span>
<span class="sd">    :param postprocess: Function to be applied to output</span>
<span class="sd">    :return: a decorator that preprocesses inputs and postprocesses outputs</span>
<span class="sd">    See also: preprocess and postprocess decorators if you need only to pre or post process!</span>

<span class="sd">    &gt;&gt;&gt; # Examples with &quot;normal functions&quot;</span>
<span class="sd">    &gt;&gt;&gt; def f(x=3):</span>
<span class="sd">    ...     &#39;&#39;&#39;Some doc...&#39;&#39;&#39;</span>
<span class="sd">    ...     return x + 10</span>
<span class="sd">    &gt;&gt;&gt; ff = input_output_decorator()(f)</span>
<span class="sd">    &gt;&gt;&gt; print((ff(5.0)))</span>
<span class="sd">    15.0</span>
<span class="sd">    &gt;&gt;&gt; ff = input_output_decorator(preprocess=int)(f)</span>
<span class="sd">    &gt;&gt;&gt; print((ff(5.0)))</span>
<span class="sd">    15</span>
<span class="sd">    &gt;&gt;&gt; ff = input_output_decorator(preprocess=int, postprocess=lambda x: &quot;Hello {}!&quot;.format(x))(f)</span>
<span class="sd">    &gt;&gt;&gt; print((ff(&#39;5&#39;)))</span>
<span class="sd">    Hello 15!</span>
<span class="sd">    &gt;&gt;&gt; ff = input_output_decorator(postprocess=lambda x: &quot;Hello {}!&quot;.format(x))(f)</span>
<span class="sd">    &gt;&gt;&gt; print((ff(5.0)))</span>
<span class="sd">    Hello 15.0!</span>
<span class="sd">    &gt;&gt;&gt; print((ff.__doc__))</span>
<span class="sd">    Some doc...</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # examples with methods (bounded, class methods, static methods</span>
<span class="sd">    &gt;&gt;&gt; class F:</span>
<span class="sd">    ...     &#39;&#39;&#39;This is not what you&#39;d expect: The doc of the class, not the function&#39;&#39;&#39;</span>
<span class="sd">    ...     def __init__(self, y=10):</span>
<span class="sd">    ...         &#39;&#39;&#39;Initialize&#39;&#39;&#39;</span>
<span class="sd">    ...         self.y = y</span>
<span class="sd">    ...     def __call__(self, x=3):</span>
<span class="sd">    ...         &#39;&#39;&#39;Some doc...&#39;&#39;&#39;</span>
<span class="sd">    ...         return self.y + x</span>
<span class="sd">    ...     @staticmethod</span>
<span class="sd">    ...     def static_method(x, y):</span>
<span class="sd">    ...         return &quot;What {} {} you have&quot;.format(x, y)</span>
<span class="sd">    ...     @classmethod</span>
<span class="sd">    ...     def class_method(cls, x):</span>
<span class="sd">    ...         return &quot;{} likes {}&quot;.format(cls.__name__, x)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; f = F()</span>
<span class="sd">    &gt;&gt;&gt; ff = input_output_decorator()(f)</span>
<span class="sd">    &gt;&gt;&gt; print((ff(5.0)))</span>
<span class="sd">    15.0</span>
<span class="sd">    &gt;&gt;&gt; ff = input_output_decorator(preprocess=int)(f)</span>
<span class="sd">    &gt;&gt;&gt; print((ff(5.0)))</span>
<span class="sd">    15</span>
<span class="sd">    &gt;&gt;&gt; ff = input_output_decorator(preprocess=int, postprocess=lambda x: &quot;Hello {}!&quot;.format(x))(f)</span>
<span class="sd">    &gt;&gt;&gt; print((ff(&#39;5&#39;)))</span>
<span class="sd">    Hello 15!</span>
<span class="sd">    &gt;&gt;&gt; ff = input_output_decorator(postprocess=lambda x: &quot;Hello {}!&quot;.format(x))(f)</span>
<span class="sd">    &gt;&gt;&gt; print((ff(5.0)))</span>
<span class="sd">    Hello 15.0!</span>
<span class="sd">    &gt;&gt;&gt; print((ff.__doc__))</span>
<span class="sd">    This is not what you&#39;d expect: The doc of the class, not the function</span>

<span class="sd">    # &gt;&gt;&gt;</span>
<span class="sd">    # &gt;&gt;&gt; f.static_method = input_output_decorator(preprocess=lambda x: &#39;&quot;&#39; + x + &#39;&quot;&#39;,</span>
<span class="sd">    # ...                                          postprocess=lambda x: x + &#39;!!!&#39;)(f.static_method)</span>
<span class="sd">    # &gt;&gt;&gt; print(ff.static_method(&#39;big&#39;, &#39;eyes&#39;))</span>
<span class="sd">    # What big &quot;eyes&quot; you have!!!</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">preprocess</span> <span class="ow">and</span> <span class="n">postprocess</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">func_wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">postprocess</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">preprocess</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)))</span>

        <span class="k">elif</span> <span class="n">preprocess</span><span class="p">:</span>  <span class="c1"># a preprocess but no postprocess</span>

            <span class="k">def</span> <span class="nf">func_wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">preprocess</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">postprocess</span><span class="p">:</span>  <span class="c1"># a postprocess but no preprocess</span>

            <span class="k">def</span> <span class="nf">func_wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">postprocess</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># neither pre nor post processing, so leave func as is</span>
            <span class="k">return</span> <span class="n">func</span>

        <span class="k">return</span> <span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)(</span><span class="n">func_wrapper</span><span class="p">)</span>

    <span class="n">decorator</span><span class="o">.</span><span class="n">preprocess</span> <span class="o">=</span> <span class="n">preprocess</span>
    <span class="n">decorator</span><span class="o">.</span><span class="n">postprocess</span> <span class="o">=</span> <span class="n">postprocess</span>

    <span class="k">return</span> <span class="n">decorator</span></div>


<div class="viewcode-block" id="transform_args"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.transform_args">[docs]</a><span class="k">def</span> <span class="nf">transform_args</span><span class="p">(</span><span class="n">dflt_trans_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">**</span><span class="n">trans_func_for_arg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a decorator that transforms function arguments before calling the function.</span>
<span class="sd">    Works with plain functions and bounded methods.</span>
<span class="sd">    For example:</span>
<span class="sd">        * original argument: a relative path --&gt; used argument: a full path</span>
<span class="sd">        * original argument: a pickle filepath --&gt; used argument: the loaded object</span>
<span class="sd">    :param rootdir: rootdir to be used for all name arguments of target function</span>
<span class="sd">    :param name_arg: the position (int) or argument name of the argument containing the name</span>
<span class="sd">    :return: a decorator</span>
<span class="sd">    &gt;&gt;&gt; # Example with a plain function</span>
<span class="sd">    &gt;&gt;&gt; def f(a, b, c=&#39;default_c&#39;):</span>
<span class="sd">    ...     return &quot;a={a}, b={b}, c={c}&quot;.format(a=a, b=b, c=c)</span>
<span class="sd">    &gt;&gt;&gt; def prepend_root(x):</span>
<span class="sd">    ...     return &#39;ROOT/&#39; + x</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; def test(f):</span>
<span class="sd">    ...     assert f(&#39;foo&#39;, &#39;bar&#39;, 3) == &#39;a=foo, b=bar, c=3&#39;</span>
<span class="sd">    ...     ff = transform_args()(f)  # no transformation specification, so function is unchanged</span>
<span class="sd">    ...     assert ff(&#39;foo&#39;, &#39;bar&#39;, c=3) == &#39;a=foo, b=bar, c=3&#39;</span>
<span class="sd">    ...     ff = transform_args(a=prepend_root)(f)  # prepend root to a</span>
<span class="sd">    ...     assert ff(&#39;foo&#39;, c=3, b=&#39;bar&#39;) == &#39;a=ROOT/foo, b=bar, c=3&#39;  # note: testing different order of args</span>
<span class="sd">    ...     ff = transform_args(b=prepend_root)(f)  # prepend root to b</span>
<span class="sd">    ...     assert ff(c=3, b=&#39;bar&#39;, a=&#39;foo&#39;) == &#39;a=foo, b=ROOT/bar, c=3&#39;  # note: testing different order of args</span>
<span class="sd">    ...     ff = transform_args(a=prepend_root, b=prepend_root)(f)  # prepend root to a and b</span>
<span class="sd">    ...     assert ff(&#39;foo&#39;, &#39;bar&#39;, 3) == &#39;a=ROOT/foo, b=ROOT/bar, c=3&#39;</span>
<span class="sd">    ...     assert ff(&#39;foo&#39;, &#39;bar&#39;) == &#39;a=ROOT/foo, b=ROOT/bar, c=default_c&#39;  # defaults still work</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; test(f)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Example with bounded method, wrapping from instance</span>
<span class="sd">    &gt;&gt;&gt; class A:</span>
<span class="sd">    ...     def __init__(self, sep=&#39;&#39;):</span>
<span class="sd">    ...         self.sep = sep</span>
<span class="sd">    ...     def f(self, a, b, c=&#39;default_c&#39;):</span>
<span class="sd">    ...         return f&quot;a={a}{self.sep} b={b}{self.sep} c={c}&quot;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; a = A(sep=&#39;,&#39;)</span>
<span class="sd">    &gt;&gt;&gt; test(a.f)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Example with bounded method, wrapping from class</span>
<span class="sd">    &gt;&gt;&gt; A.f = transform_args(a=prepend_root, b=prepend_root)(A.f)</span>
<span class="sd">    &gt;&gt;&gt; a = A(sep=&#39;,&#39;)</span>
<span class="sd">    &gt;&gt;&gt; assert a.f(&#39;foo&#39;, &#39;bar&#39;, 3) == &#39;a=ROOT/foo, b=ROOT/bar, c=3&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert a.f(&#39;foo&#39;, &#39;bar&#39;) == &#39;a=ROOT/foo, b=ROOT/bar, c=default_c&#39;  # defaults still work</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">transform_args_decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">get_kwargs</span> <span class="o">=</span> <span class="n">mk_args_kwargs_merger</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">trans_func_for_arg</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dflt_trans_func</span>
        <span class="p">):</span>  <span class="c1"># if no transformations were specified...</span>
            <span class="k">return</span> <span class="n">func</span>  <span class="c1"># just return the function itself</span>
        <span class="k">elif</span> <span class="n">dflt_trans_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">callable</span><span class="p">(</span>
                <span class="n">dflt_trans_func</span>
            <span class="p">),</span> <span class="s1">&#39;The dflt_trans_func needs to be a callable&#39;</span>

            <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">transform_args_wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">val_of_argname</span> <span class="o">=</span> <span class="n">get_kwargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
                <span class="n">val_of_argname</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">argname</span><span class="p">:</span> <span class="n">dflt_trans_func</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">argname</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">val_of_argname</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>

                <span class="c1"># apply transform functions to argument values</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">**</span><span class="n">val_of_argname</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">transform_args_wrapper</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">transform_args_wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="c1"># get a {argname: argval, ...} dict from *args and **kwargs</span>
                <span class="c1"># Note: Didn&#39;t really need an if/else here but I am assuming that...</span>
                <span class="c1"># Note: ... getcallargs gives us an overhead that can be avoided if there&#39;s only keyword args.</span>

                <span class="n">val_of_argname</span> <span class="o">=</span> <span class="n">get_kwargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">argname</span><span class="p">,</span> <span class="n">trans_func</span> <span class="ow">in</span> <span class="n">trans_func_for_arg</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">argname</span> <span class="ow">in</span> <span class="n">val_of_argname</span><span class="p">:</span>
                        <span class="n">val_of_argname</span><span class="p">[</span><span class="n">argname</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans_func</span><span class="p">(</span>
                            <span class="n">val_of_argname</span><span class="p">[</span><span class="n">argname</span><span class="p">]</span>
                        <span class="p">)</span>
                <span class="c1"># apply transform functions to argument values</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">**</span><span class="n">val_of_argname</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">transform_args_wrapper</span>

    <span class="n">transform_args_decorator</span><span class="o">.</span><span class="n">dflt_trans_func</span> <span class="o">=</span> <span class="n">dflt_trans_func</span>
    <span class="n">transform_args_decorator</span><span class="o">.</span><span class="n">trans_func_for_arg</span> <span class="o">=</span> <span class="n">trans_func_for_arg</span>

    <span class="k">return</span> <span class="n">transform_args_decorator</span></div>


<span class="k">def</span> <span class="nf">wrap_method_output</span><span class="p">(</span><span class="n">wrapper_func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_wrap_output</span><span class="p">(</span><span class="n">wrapped</span><span class="p">):</span>
        <span class="nd">@wraps</span><span class="p">(</span><span class="n">wrapped</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">_wrapped</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">wrapper_func</span><span class="p">(</span><span class="n">wrapped</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">_wrapped</span>

    <span class="k">return</span> <span class="n">_wrap_output</span>


<div class="viewcode-block" id="wrap_class_methods"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.wrap_class_methods">[docs]</a><span class="k">def</span> <span class="nf">wrap_class_methods</span><span class="p">(</span>
    <span class="n">_return_a_copy_of_the_class</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">_raise_error_if_non_existent_method</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">wrapper_for_method</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a decorator that wraps specific methods.</span>

<span class="sd">    IMPORTANT: The decorator will by default return a copy of the class. This might incur some run time overhead.</span>
<span class="sd">    If this is desirable, for example, when you want to create several decorations of a same class.</span>
<span class="sd">    If you want to change the class itself (e.g. you&#39;re only loading it once in a module, and decorating it), then</span>
<span class="sd">    specify _return_a_copy_of_the_class=False</span>

<span class="sd">    Note that _return_a_copy_of_the_class=True has a side effect of building russian dolls of essentially subclasses</span>
<span class="sd">    of the class, which may have some undesirable results if repeated too many times.</span>

<span class="sd">    :param _return_a_copy_of_the_class: Specifies whether to</span>
<span class="sd">        return a copy of the class (_return_a_copy_of_the_class=True, the default),</span>
<span class="sd">        or change the actual loaded class itself (_return_a_copy_of_the_class=False)</span>
<span class="sd">    :param wrapper_for_method: method_name=wrapper_function pairs.</span>
<span class="sd">    :return: A class wrapper. That is, a decorator that takes a class and returns a decorated version of it</span>
<span class="sd">        (or decaorates &quot;in-place&quot; if _return_a_copy_of_the_class=False</span>

<span class="sd">    SEE ALSO:</span>
<span class="sd">        * wrap_method_output: The function that is called for every method we wrap.</span>
<span class="sd">        * transform_class_method_input_and_output: A wrap_class_methods that is specialized for input arg and output</span>
<span class="sd">            transformation.</span>

<span class="sd">    &gt;&gt;&gt; from functools import wraps</span>
<span class="sd">    &gt;&gt;&gt; class A:</span>
<span class="sd">    ...     def __init__(self, a=10):</span>
<span class="sd">    ...         self.a = a</span>
<span class="sd">    ...     def add(self, x):</span>
<span class="sd">    ...         return self.a + x</span>
<span class="sd">    ...     def multiply(self, x):</span>
<span class="sd">    ...         return self.a * x</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; a = A()</span>
<span class="sd">    &gt;&gt;&gt; a.add(2)</span>
<span class="sd">    12</span>
<span class="sd">    &gt;&gt;&gt; a.multiply(2)</span>
<span class="sd">    20</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; def log_calls(func):</span>
<span class="sd">    ...     name = func.__name__</span>
<span class="sd">    ...     @wraps(func)</span>
<span class="sd">    ...     def _func(self, *args, **kwargs):</span>
<span class="sd">    ...         print(&quot;Calling {} with\\n  args={}\\n  kwargs={}&quot;.format(name, args, kwargs))</span>
<span class="sd">    ...         return func(self, *args, **kwargs)</span>
<span class="sd">    ...     return _func</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; AA = wrap_class_methods(**{k: log_calls for k in [&#39;add&#39;, &#39;multiply&#39;]})(A)</span>
<span class="sd">    &gt;&gt;&gt; a = AA()</span>
<span class="sd">    &gt;&gt;&gt; a.add(x=3)</span>
<span class="sd">    Calling add with</span>
<span class="sd">      args=()</span>
<span class="sd">      kwargs={&#39;x&#39;: 3}</span>
<span class="sd">    13</span>
<span class="sd">    &gt;&gt;&gt; a.multiply(3)</span>
<span class="sd">    Calling multiply with</span>
<span class="sd">      args=(3,)</span>
<span class="sd">      kwargs={}</span>
<span class="sd">    30</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">class_wrapper</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_return_a_copy_of_the_class</span><span class="p">:</span>
            <span class="n">_cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">))</span>
            <span class="c1"># class _cls(cls):</span>
            <span class="c1">#     pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_cls</span> <span class="o">=</span> <span class="bp">cls</span>
        <span class="k">for</span> <span class="n">method</span><span class="p">,</span> <span class="n">wrapper</span> <span class="ow">in</span> <span class="n">wrapper_for_method</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">_cls</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">_cls</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">wrapper</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_cls</span><span class="p">,</span> <span class="n">method</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="n">_raise_error_if_non_existent_method</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">getattr</span><span class="p">(</span><span class="n">_cls</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">cls</span><span class="p">))</span><span class="si">}</span><span class="s2"> has no &#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39; method!&quot;</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">_cls</span>

    <span class="k">return</span> <span class="n">class_wrapper</span></div>


<span class="k">def</span> <span class="nf">mk_input_and_output_method_wrapper</span><span class="p">(</span><span class="n">method_output_trans</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">arg_trans</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrap_method</span><span class="p">(</span><span class="n">method_func</span><span class="p">):</span>
        <span class="n">wrapped_method</span> <span class="o">=</span> <span class="n">transform_args</span><span class="p">(</span><span class="o">**</span><span class="n">arg_trans</span><span class="p">)(</span><span class="n">method_func</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method_output_trans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">wrap_method_output</span><span class="p">(</span><span class="n">method_output_trans</span><span class="p">)(</span><span class="n">wrapped_method</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">wrapped_method</span>

    <span class="k">return</span> <span class="n">wrap_method</span>


<span class="k">def</span> <span class="nf">transform_class_method_input_and_output</span><span class="p">(</span>
    <span class="bp">cls</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">method_output_trans</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">arg_trans</span>
<span class="p">):</span>
    <span class="n">wrapped_method</span> <span class="o">=</span> <span class="n">transform_args</span><span class="p">(</span><span class="o">**</span><span class="n">arg_trans</span><span class="p">)(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">method</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">method_output_trans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span>
            <span class="n">method</span><span class="p">,</span>
            <span class="n">wrap_method_output</span><span class="p">(</span><span class="n">method_output_trans</span><span class="p">)(</span><span class="n">wrapped_method</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">wrapped_method</span><span class="p">)</span>


<div class="viewcode-block" id="wrap_class_methods_input_and_output"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.wrap_class_methods_input_and_output">[docs]</a><span class="k">def</span> <span class="nf">wrap_class_methods_input_and_output</span><span class="p">(</span>
    <span class="n">_return_a_copy_of_the_class</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">_raise_error_if_non_existent_method</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">method_trans_spec</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Make a decorator that wraps specific methods, transforming specific argument values a nd output values.</span>

<span class="sd">    IMPORTANT: The decorator will by default return a copy of the class. This might incur some run time overhead.</span>
<span class="sd">    If this is desirable, for example, when you want to create several decorations of a same class.</span>
<span class="sd">    If you want to change the class itself (e.g. you&#39;re only loading it once in a module, and decorating it), then</span>
<span class="sd">    specify _return_a_copy_of_the_class=False</span>

<span class="sd">    :param _return_a_copy_of_the_class: Specifies whether to</span>
<span class="sd">        return a copy of the class (_return_a_copy_of_the_class=True, the default),</span>
<span class="sd">        or change the actual loaded class itself (_return_a_copy_of_the_class=False)</span>
<span class="sd">    :param method_trans_spec: method_name=trans_specs_for_method pairs.</span>
<span class="sd">        The trans_specs_for_method is a dict that is understood by transform_class_method_input_and_output.</span>
<span class="sd">        Except for one special case, it&#39;s keys are argument names and values are callables to call on those</span>
<span class="sd">        arguments&#39; values.</span>
<span class="sd">        The special case is method_output_trans. This specifies that the callable it points to should be called</span>
<span class="sd">        on output of method. Here&#39;s one recipe for outputs: If the output of a function is an iterable and you want</span>
<span class="sd">        to apply a function trans to each element of the output, specify method_output_trans=lambda x: map(trans, x).</span>
<span class="sd">    :return: A wrapped class</span>

<span class="sd">    SEE ALSO:</span>
<span class="sd">        * mk_method_trans_spec_from_methods_specs_dict: a utility to make method_trans_spec more easily</span>
<span class="sd">        * transform_class_method_input_and_output: The function that is called for every method we wrap.</span>

<span class="sd">    In the following, we will show two examples.</span>
<span class="sd">    - The first is a toy example to demonstrate the basic functionality.</span>
<span class="sd">    - The second demonstrates a more involved case, but is still a silly example.</span>
<span class="sd">    - The third demonstrates more the type of application we&#39;d use wrap_class_methods_input_and_output for in real life.</span>

<span class="sd">    # FIRST EXAMPLE</span>
<span class="sd">    We make an Ops class that wraps Counter, allowing one to add items and show the counts of items added.</span>

<span class="sd">    &gt;&gt;&gt; from collections import UserDict</span>
<span class="sd">    &gt;&gt;&gt; import re</span>
<span class="sd">    &gt;&gt;&gt; from collections import Counter</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; class Ops:</span>
<span class="sd">    ...     def __init__(self):</span>
<span class="sd">    ...         self.counter = Counter()</span>
<span class="sd">    ...     def add_item(self, item):</span>
<span class="sd">    ...         self.counter.update({item: 1})</span>
<span class="sd">    ...     def show(self):</span>
<span class="sd">    ...         return self.counter</span>
<span class="sd">    &gt;&gt;&gt; # Here&#39;s an example of what Ops does</span>
<span class="sd">    &gt;&gt;&gt; ops = Ops()</span>
<span class="sd">    &gt;&gt;&gt; for item in [&#39;this&#39;, &#39;is&#39;, &#39;that&#39;, &#39;and&#39;, &#39;that&#39;, &#39;is&#39;, &#39;this&#39;]:</span>
<span class="sd">    ...     ops.add_item(item)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; ops.show()</span>
<span class="sd">    Counter({&#39;this&#39;: 2, &#39;is&#39;: 2, &#39;that&#39;: 2, &#39;and&#39;: 1})</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # But say we don&#39;t want to count actual words added, but just the first two letters of these words,</span>
<span class="sd">    &gt;&gt;&gt; # and say we want to show() to return the dict, not the Counter.</span>
<span class="sd">    &gt;&gt;&gt; NewOps = wrap_class_methods_input_and_output(</span>
<span class="sd">    ...     _return_a_copy_of_the_class=False,</span>
<span class="sd">    ...     add_item=dict(item=lambda x: x[:2]),  # intercept items fed to add_item and keep only 2 first letters</span>
<span class="sd">    ...     show=dict(method_output_trans=dict)  # intercept output of show method, converting to dict</span>
<span class="sd">    ... )(Ops)</span>
<span class="sd">    &gt;&gt;&gt; # let&#39;s try it out!</span>
<span class="sd">    &gt;&gt;&gt; ops = NewOps()</span>
<span class="sd">    &gt;&gt;&gt; for item in [&#39;this&#39;, &#39;is&#39;, &#39;that&#39;, &#39;and&#39;, &#39;that&#39;, &#39;is&#39;, &#39;this&#39;]:</span>
<span class="sd">    ...     ops.add_item(item)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; ops.show()</span>
<span class="sd">    {&#39;th&#39;: 4, &#39;is&#39;: 2, &#39;an&#39;: 1}</span>
<span class="sd">    &gt;&gt;&gt; # See that we specified _return_a_copy_of_the_class=False?</span>
<span class="sd">    &gt;&gt;&gt; # Now look at what happens if we try to use Ops, the original class, again. It behaves like NewOps.</span>
<span class="sd">    &gt;&gt;&gt; # That&#39;s usually not the behavior we want, so be careful!</span>
<span class="sd">    &gt;&gt;&gt; ops = Ops()</span>
<span class="sd">    &gt;&gt;&gt; for item in [&#39;this&#39;, &#39;is&#39;, &#39;that&#39;, &#39;and&#39;, &#39;that&#39;, &#39;is&#39;, &#39;this&#39;]:</span>
<span class="sd">    ...     ops.add_item(item)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; ops.show()</span>
<span class="sd">    {&#39;th&#39;: 4, &#39;is&#39;: 2, &#39;an&#39;: 1}</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt;</span>

<span class="sd">    # SECOND EXAMPLE</span>

<span class="sd">    Wrap a dict (or rather, the safer collections.UserDict), doing weird things to the input and output</span>
<span class="sd">    keys and values</span>

<span class="sd">    &gt;&gt;&gt; val_in_trans = lambda x: &#39;hello {}&#39;.format(x)  # prepend &quot;hello &quot; to incoming values</span>
<span class="sd">    &gt;&gt;&gt; val_out_trans = lambda x: re.sub(&#39;hello&#39;, &#39;hi&#39;, x)  # replace &quot;hello&quot; by &quot;hi&quot; in output values</span>
<span class="sd">    &gt;&gt;&gt; key_in_trans = lambda x: &#39;__&#39; + x  # prepend incoming keys with double underscore</span>
<span class="sd">    &gt;&gt;&gt; key_out_trans = lambda x: x[2:]  # remove the first two characters (underscores) from keys when output</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; methods_specs_dict = {</span>
<span class="sd">    ...     (&#39;__contains__&#39;, &#39;__getitem__&#39;, &#39;__setitem__&#39;, &#39;__delitem__&#39;): dict(key=key_in_trans),</span>
<span class="sd">    ...     &#39;__setitem__&#39;: dict(item=val_in_trans),</span>
<span class="sd">    ...     &#39;__iter__&#39;: dict(method_output_trans=lambda x: map(key_out_trans, x)),</span>
<span class="sd">    ...     &#39;__getitem__&#39;: dict(method_output_trans=val_out_trans)</span>
<span class="sd">    ... }</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; methods_specs_dict = mk_method_trans_spec_from_methods_specs_dict(methods_specs_dict)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; @wrap_class_methods_input_and_output(**methods_specs_dict)</span>
<span class="sd">    ... class AA(UserDict):</span>
<span class="sd">    ...     pass</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; aa = AA()</span>
<span class="sd">    &gt;&gt;&gt; aa[&#39;foo&#39;] = &#39;shoo&#39;  # store &#39;shoo&#39; under &#39;foo&#39;</span>
<span class="sd">    &gt;&gt;&gt; # the __str__ method isn&#39;t wrapped, so we see the actual STORED keys and values</span>
<span class="sd">    &gt;&gt;&gt; # we see that __foo, not foo is the actual key, and &quot;hello shoo&quot; the value:</span>
<span class="sd">    &gt;&gt;&gt; assert str(aa) == &quot;{&#39;__foo&#39;: &#39;hello shoo&#39;}&quot;</span>
<span class="sd">    &gt;&gt;&gt; assert &#39;foo&#39; in aa  # yet from the interface, it looks like &#39;foo&#39; is a key of aa...</span>
<span class="sd">    &gt;&gt;&gt; assert &#39;__foo&#39; not in aa  # ... and &#39;__foo&#39; is not a key.</span>
<span class="sd">    &gt;&gt;&gt; aa[&#39;foo&#39;] = &#39;bar&#39;  # let&#39;s replace the value of &#39;foo&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert str(aa) == &quot;{&#39;__foo&#39;: &#39;hello bar&#39;}&quot;  # see what&#39;s stored</span>
<span class="sd">    &gt;&gt;&gt; aa[&#39;star&#39;] = &#39;wars&#39;  # let&#39;s add another</span>
<span class="sd">    &gt;&gt;&gt; assert list(aa) == [&#39;foo&#39;, &#39;star&#39;]  # what are the keys? (this uses __iter__ under the hood)</span>
<span class="sd">    &gt;&gt;&gt; # In the following, we&#39;ll use methods keys(), values(), and items(), none of which we wrapped.</span>
<span class="sd">    &gt;&gt;&gt; # And yet, they work as expected, since they pass on their work to methods we wrapped.</span>
<span class="sd">    &gt;&gt;&gt; assert list(aa.keys()) == [&#39;foo&#39;, &#39;star&#39;]  # another way to get keys</span>
<span class="sd">    &gt;&gt;&gt; # see here that when we ask for values, we don&#39;t get what we asked to store, ...</span>
<span class="sd">    &gt;&gt;&gt; # ... nor what is actually stored, but something else</span>
<span class="sd">    &gt;&gt;&gt; assert list(aa.values()) == [&#39;hi bar&#39;, &#39;hi wars&#39;]</span>
<span class="sd">    &gt;&gt;&gt; assert str(list(aa.items())) == &quot;[(&#39;foo&#39;, &#39;hi bar&#39;), (&#39;star&#39;, &#39;hi wars&#39;)]&quot;  # the keys and values we get from items()</span>
<span class="sd">    &gt;&gt;&gt; assert str(aa) == &quot;{&#39;__foo&#39;: &#39;hello bar&#39;, &#39;__star&#39;: &#39;hello wars&#39;}&quot;  # what is actually stored</span>
<span class="sd">    &gt;&gt;&gt; del aa[&#39;foo&#39;]  # testing deletion of a key</span>
<span class="sd">    &gt;&gt;&gt; assert str(aa) == &quot;{&#39;__star&#39;: &#39;hello wars&#39;}&quot;  # it worked!</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt;</span>

<span class="sd">    # THIRD EXAMPLE</span>

<span class="sd">    Here again, we&#39;ll wrap UserDict. But instead of being silly, we&#39;ll pretend we need to store waveforms</span>
<span class="sd">    in binary format (so input values will have to be wrapped), but still retrieving these waveforms as lists</span>
<span class="sd">    (so output values will have to be wrapped).</span>
<span class="sd">    Additionally, we&#39;ll pretend we&#39;re working with wav files within some root directory, but don&#39;t</span>
<span class="sd">    want the root dir or the &#39;.wav&#39; extension to appear in our keys. So we&#39;ll have to wrap input and output keys.</span>
<span class="sd">    Of course, this is just pretend. Don&#39;t use this with real waveforms. It won&#39;t work.</span>

<span class="sd">    &gt;&gt;&gt; root = &#39;/ROOT/DIR/&#39;</span>
<span class="sd">    &gt;&gt;&gt; abs_path_of_rel_path = lambda rel_path: root + rel_path + &#39;.wav&#39;  # transform a relative path to an absolute one</span>
<span class="sd">    &gt;&gt;&gt; rel_path_of_abs_path = lambda x: x.replace(root, &#39;&#39;).replace(&#39;.wav&#39;, &#39;&#39;)  # transform an absolute path to a relative one</span>
<span class="sd">    &gt;&gt;&gt; list_to_bytes = bytes</span>
<span class="sd">    &gt;&gt;&gt; bytes_to_list = list</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; methods_specs_dict = {</span>
<span class="sd">    ...     (&#39;__contains__&#39;, &#39;__getitem__&#39;, &#39;__setitem__&#39;, &#39;__delitem__&#39;): dict(key=abs_path_of_rel_path),</span>
<span class="sd">    ...     &#39;__setitem__&#39;: dict(item=list_to_bytes),</span>
<span class="sd">    ...     &#39;__iter__&#39;: dict(method_output_trans=lambda x: map(rel_path_of_abs_path, x)),</span>
<span class="sd">    ...     &#39;__getitem__&#39;: dict(method_output_trans=bytes_to_list)</span>
<span class="sd">    ... }</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; methods_specs_dict = mk_method_trans_spec_from_methods_specs_dict(methods_specs_dict)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; @wrap_class_methods_input_and_output(**methods_specs_dict)</span>
<span class="sd">    ... class Wf(UserDict):</span>
<span class="sd">    ...     pass</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; year = [2, 0, 1, 9]</span>
<span class="sd">    &gt;&gt;&gt; down = [5, 4, 3, 2, 1]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; wf = Wf()</span>
<span class="sd">    &gt;&gt;&gt; wf[&#39;year&#39;] = year</span>
<span class="sd">    &gt;&gt;&gt; print(str(wf).replace(&quot;b&#39;&quot;, &quot;&#39;&quot;))</span>
<span class="sd">    {&#39;/ROOT/DIR/year.wav&#39;: &#39;\\x02\\x00\\x01\\t&#39;}</span>
<span class="sd">    &gt;&gt;&gt; &#39;year&#39; in wf</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; wf[&#39;down&#39;] = down</span>
<span class="sd">    &gt;&gt;&gt; print(str(wf).replace(&quot;b&#39;&quot;, &quot;&#39;&quot;))</span>
<span class="sd">    {&#39;/ROOT/DIR/year.wav&#39;: &#39;\\x02\\x00\\x01\\t&#39;, &#39;/ROOT/DIR/down.wav&#39;: &#39;\\x05\\x04\\x03\\x02\\x01&#39;}</span>
<span class="sd">    &gt;&gt;&gt; list(wf.keys())</span>
<span class="sd">    [&#39;year&#39;, &#39;down&#39;]</span>
<span class="sd">    &gt;&gt;&gt; list(wf.values())</span>
<span class="sd">    [[2, 0, 1, 9], [5, 4, 3, 2, 1]]</span>
<span class="sd">    &gt;&gt;&gt; list(wf.items())</span>
<span class="sd">    [(&#39;year&#39;, [2, 0, 1, 9]), (&#39;down&#39;, [5, 4, 3, 2, 1])]</span>
<span class="sd">    &gt;&gt;&gt; len(wf)</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; del wf[&#39;year&#39;]</span>
<span class="sd">    &gt;&gt;&gt; len(wf)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; list(wf.items())</span>
<span class="sd">    [(&#39;down&#39;, [5, 4, 3, 2, 1])]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">wrapper_for_method</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">mk_input_and_output_method_wrapper</span><span class="p">(</span><span class="o">**</span><span class="n">method_trans</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">method</span><span class="p">,</span> <span class="n">method_trans</span> <span class="ow">in</span> <span class="n">method_trans_spec</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">wrap_class_methods</span><span class="p">(</span>
        <span class="n">_return_a_copy_of_the_class</span><span class="o">=</span><span class="n">_return_a_copy_of_the_class</span><span class="p">,</span>
        <span class="n">_raise_error_if_non_existent_method</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">wrapper_for_method</span><span class="p">,</span>
    <span class="p">)</span></div>

    <span class="c1"># def class_wrapper(cls):</span>
    <span class="c1">#     if _return_a_copy_of_the_class:</span>
    <span class="c1">#         class _cls(cls):</span>
    <span class="c1">#             pass</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         _cls = cls</span>
    <span class="c1">#     for method, method_trans in method_trans_spec.items():</span>
    <span class="c1">#         if hasattr(_cls, method):</span>
    <span class="c1">#             transform_class_method_input_and_output(_cls, method, **method_trans)</span>
    <span class="c1">#         elif _raise_error_if_non_existent_method:</span>
    <span class="c1">#             if hasattr(cls, &#39;__name__&#39;):</span>
    <span class="c1">#                 class_name = cls.__name__</span>
    <span class="c1">#             else:</span>
    <span class="c1">#                 class_name = str(cls)</span>
    <span class="c1">#             raise ValueError(&quot;{} has no &#39;{}&#39; method!&quot;.format(class_name, method))</span>
    <span class="c1">#     return _cls</span>
    <span class="c1">#</span>
    <span class="c1"># return class_wrapper</span>


<div class="viewcode-block" id="add_method"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.add_method">[docs]</a><span class="k">def</span> <span class="nf">add_method</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">method_func</span><span class="p">,</span> <span class="n">method_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">class_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dynamically add a method to an object.</span>

<span class="sd">    :param obj: The object to add a method to</span>
<span class="sd">    :param method_func: The function to use as a method. The first argument must be the object itself</span>
<span class="sd">        (usually called self)</span>
<span class="sd">    :param method_name: The desired function name. If None, will take method_func.__name__</span>
<span class="sd">    :param class_name:  The desired class name. If None, will take type(obj).__name__</span>
<span class="sd">    :return: the object, but with the additional method (or a different function for it)</span>

<span class="sd">    &gt;&gt;&gt; class A:</span>
<span class="sd">    ...     def __init__(self, x=10):</span>
<span class="sd">    ...         self.x = x</span>
<span class="sd">    &gt;&gt;&gt; def times(self, y):</span>
<span class="sd">    ...     return self.x * y</span>
<span class="sd">    &gt;&gt;&gt; def plus(self, y):</span>
<span class="sd">    ...     return self.x + y</span>
<span class="sd">    &gt;&gt;&gt; a = A(x=10)</span>
<span class="sd">    &gt;&gt;&gt; a = add_method(a, plus, &#39;__call__&#39;)  # add a __call__ method, assigning it to plus</span>
<span class="sd">    &gt;&gt;&gt; a(2)</span>
<span class="sd">    12</span>
<span class="sd">    &gt;&gt;&gt; a = add_method(a, times, &#39;__call__&#39;)  # reassign the __call__ method to times instead</span>
<span class="sd">    &gt;&gt;&gt; a(2)</span>
<span class="sd">    20</span>
<span class="sd">    &gt;&gt;&gt; a = add_method(a, plus, &#39;__getitem__&#39;)  # assign the method __getitem__ to plus</span>
<span class="sd">    &gt;&gt;&gt; a[2]  # see that it works</span>
<span class="sd">    12</span>
<span class="sd">    &gt;&gt;&gt; a(2)  # and that we still have our __call__ method</span>
<span class="sd">    20</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method_func</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">method_name</span> <span class="o">=</span> <span class="n">method_func</span>
        <span class="n">method_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">method_name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">method_name</span> <span class="o">=</span> <span class="n">method_func</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="n">base</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">class_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="n">bases</span> <span class="o">=</span> <span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">+</span> <span class="p">(</span><span class="n">base</span><span class="p">,)</span>
    <span class="n">bases_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">bases</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">class_name</span> <span class="ow">in</span> <span class="n">bases_names</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
            <span class="n">class_name</span> <span class="o">+=</span> <span class="s1">&#39;_&#39;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">class_name</span> <span class="ow">in</span> <span class="n">bases_names</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;can&#39;t find a name for class that is not taken by bases. Consider using explicit name&quot;</span>
            <span class="p">)</span>

    <span class="n">new_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">dir</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">]))</span>

    <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">new_keys</span><span class="p">}</span>
    <span class="n">d</span><span class="p">[</span><span class="n">method_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">method_func</span>

    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">class_name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">d</span><span class="p">)()</span></div>


<span class="k">def</span> <span class="nf">transform_instance_method_input_and_output</span><span class="p">(</span>
    <span class="n">obj</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">method_output_trans</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">arg_trans</span>
<span class="p">):</span>
    <span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

    <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Not sure transform_instance_method_input_and_output works yet&#39;</span><span class="p">)</span>
    <span class="n">wrapped_method</span> <span class="o">=</span> <span class="n">transform_args</span><span class="p">(</span><span class="o">**</span><span class="n">arg_trans</span><span class="p">)(</span><span class="nb">getattr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">method</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">method_output_trans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">add_method</span><span class="p">(</span>
            <span class="n">obj</span><span class="p">,</span>
            <span class="n">wrap_method_output</span><span class="p">(</span><span class="n">method_output_trans</span><span class="p">)(</span><span class="n">wrapped_method</span><span class="p">),</span>
            <span class="n">method_name</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">add_method</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">wrapped_method</span><span class="p">,</span> <span class="n">method_name</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span>


<span class="k">def</span> <span class="nf">wrap_instance_methods</span><span class="p">(</span>
    <span class="n">_return_a_copy_of_the_class</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">_raise_error_if_non_existent_method</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">method_trans_spec</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">def</span> <span class="nf">obj_wrapper</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">method</span><span class="p">,</span> <span class="n">method_trans</span> <span class="ow">in</span> <span class="n">method_trans_spec</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">transform_instance_method_input_and_output</span><span class="p">(</span>
                    <span class="n">obj</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">method_trans</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">_raise_error_if_non_existent_method</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">):</span>
                    <span class="n">class_name</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">class_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> has no &#39;</span><span class="si">{}</span><span class="s2">&#39; method!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">class_name</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">return</span> <span class="n">obj_wrapper</span>


<div class="viewcode-block" id="mk_method_trans_spec_from_methods_specs_dict"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.mk_method_trans_spec_from_methods_specs_dict">[docs]</a><span class="k">def</span> <span class="nf">mk_method_trans_spec_from_methods_specs_dict</span><span class="p">(</span><span class="n">methods_specs_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility to make inputs for wrap_class_methods_input_and_output more easily.</span>
<span class="sd">    :param methods_specs_dict: a dict where</span>
<span class="sd">        keys are method names (either a single string, or a tuple of strings)</span>
<span class="sd">        values are the trans_spec dicts that should be associated to those methods</span>
<span class="sd">    :return: A dict in the method_trans_spec (input of wrap_class_method) format.</span>
<span class="sd">    &gt;&gt;&gt; methods_specs_dict = {}</span>
<span class="sd">    &gt;&gt;&gt; methods_specs_dict[&#39;foo&#39;] = {&#39;x&#39;: str, &#39;y&#39;: int}</span>
<span class="sd">    &gt;&gt;&gt; methods_specs_dict[(&#39;foo&#39;, &#39;bar&#39;)] = {&#39;z&#39;: list, &#39;method_output_trans&#39;: float}</span>
<span class="sd">    &gt;&gt;&gt; methods_specs_dict[(&#39;bar&#39;, )] = {&#39;zz&#39;: int}</span>
<span class="sd">    &gt;&gt;&gt; method_trans_spec = mk_method_trans_spec_from_methods_specs_dict(methods_specs_dict)</span>
<span class="sd">    &gt;&gt;&gt; list(method_trans_spec.keys())</span>
<span class="sd">    [&#39;foo&#39;, &#39;bar&#39;]</span>
<span class="sd">    &gt;&gt;&gt; method_trans_spec[&#39;foo&#39;]</span>
<span class="sd">    {&#39;x&#39;: &lt;class &#39;str&#39;&gt;, &#39;y&#39;: &lt;class &#39;int&#39;&gt;, &#39;z&#39;: &lt;class &#39;list&#39;&gt;, &#39;method_output_trans&#39;: &lt;class &#39;float&#39;&gt;}</span>
<span class="sd">    &gt;&gt;&gt; method_trans_spec[&#39;bar&#39;]</span>
<span class="sd">    {&#39;z&#39;: &lt;class &#39;list&#39;&gt;, &#39;method_output_trans&#39;: &lt;class &#39;float&#39;&gt;, &#39;zz&#39;: &lt;class &#39;int&#39;&gt;}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">method_trans_spec</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">methods</span><span class="p">,</span> <span class="n">specs</span> <span class="ow">in</span> <span class="n">methods_specs_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">methods</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">methods</span> <span class="o">=</span> <span class="p">(</span><span class="n">methods</span><span class="p">,)</span>
        <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">methods</span><span class="p">:</span>
            <span class="n">method_trans_spec</span><span class="p">[</span><span class="n">method</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">method_trans_spec</span><span class="p">)</span></div>


<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span>

<span class="n">Args</span> <span class="o">=</span> <span class="n">Tuple</span>
<span class="n">Kwargs</span> <span class="o">=</span> <span class="n">Dict</span>
<span class="n">WhatToLog</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Callable</span><span class="p">,</span> <span class="n">Args</span><span class="p">,</span> <span class="n">Kwargs</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_special_str</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">max_len</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot; A util function for _call_signature&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&#39;&quot;</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_str</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_len</span><span class="p">:</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;__repr__&#39;</span><span class="p">):</span>
                <span class="n">value_str</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value_str</span> <span class="o">=</span> <span class="n">x_str</span>
            <span class="n">x_str</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">(</span><span class="si">{}</span><span class="s1">...)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">type_str</span><span class="p">,</span> <span class="n">value_str</span><span class="p">[:</span><span class="mi">20</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">x_str</span>


<span class="k">def</span> <span class="nf">_call_signature</span><span class="p">(</span><span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">:</span> <span class="n">Kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A util to make a string representation of a call of a function func with given args and kwargs.</span>
<span class="sd">    Meant to be the default mk_log_str of mk_call_logger.</span>
<span class="sd">    :param func: A callable</span>
<span class="sd">    :param args: A tuple of positional arguments</span>
<span class="sd">    :param kwargs: A dict of key=val arguments</span>
<span class="sd">    :return: A string to represent all of that.</span>

<span class="sd">    &gt;&gt;&gt; args = (2, &#39;sdf&#39;, list(range(1000)))</span>
<span class="sd">    &gt;&gt;&gt; kwargs = {&#39;z&#39;: &#39;boo&#39;, &#39;zzz&#39;: 10}</span>
<span class="sd">    &gt;&gt;&gt; print(_call_signature(_call_signature, args, kwargs))</span>
<span class="sd">    _call_signature(2, &#39;sdf&#39;, list([0, 1, 2, 3, 4, 5, 6...), z=&#39;boo&#39;, zzz=10)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">args_signature</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_special_str</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
    <span class="n">kwargs_signature</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">_special_str</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{func_name}</span><span class="s1">(</span><span class="si">{signature}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">func_name</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
        <span class="n">signature</span><span class="o">=</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">args_signature</span><span class="p">,</span> <span class="n">kwargs_signature</span><span class="p">]),</span>
    <span class="p">)</span>


<div class="viewcode-block" id="mk_call_logger"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.mk_call_logger">[docs]</a><span class="k">def</span> <span class="nf">mk_call_logger</span><span class="p">(</span>
    <span class="n">logger</span><span class="o">=</span><span class="nb">print</span><span class="p">,</span>
    <span class="n">what_to_log</span><span class="p">:</span> <span class="n">WhatToLog</span> <span class="o">=</span> <span class="n">_call_signature</span><span class="p">,</span>
    <span class="n">log_output</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">func_is_bounded</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Makes a decorator that logs each call to the wrapped function.</span>
<span class="sd">    :param logger: The actual function that logs stuff. Default is print. The &quot;stuff&quot; it logs is given by</span>
<span class="sd">        the what_to_log argument (a function).</span>
<span class="sd">    :param what_to_log: A function taking inputs (func, args, kwargs) of the call, and returning something to log</span>
<span class="sd">        (usually, and by default, a string)</span>
<span class="sd">    :param func_is_bounded: Whether the function is bounded (like a method) or not</span>
<span class="sd">    :return: A decorator</span>

<span class="sd">    &gt;&gt;&gt; # Example of use on (unbounded) function, with default args</span>
<span class="sd">    &gt;&gt;&gt; @mk_call_logger()</span>
<span class="sd">    ... def useless_computation(x, y=2, z=&#39;foo&#39;):</span>
<span class="sd">    ...     return z * (x + y)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; _ = useless_computation(3, y=1, z=&#39;ha&#39;)</span>
<span class="sd">    useless_computation(3, y=1, z=&#39;ha&#39;)</span>

<span class="sd">    The same example, but with output logging too</span>

<span class="sd">    &gt;&gt;&gt; @mk_call_logger(log_output=True)</span>
<span class="sd">    ... def useless_computation(x, y=2, z=&#39;foo&#39;):</span>
<span class="sd">    ...     return z * (x + y)</span>
<span class="sd">    &gt;&gt;&gt; _ = useless_computation(3, y=1, z=&#39;ha&#39;)</span>
<span class="sd">    useless_computation(3, y=1, z=&#39;ha&#39;)</span>
<span class="sd">    -&gt; hahahaha</span>

<span class="sd">    And now a bit more involved...</span>

<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; # Example of use on class method, with a different what_to_log function.</span>
<span class="sd">    &gt;&gt;&gt; class A:</span>
<span class="sd">    ...     def __init__(self, a=10):</span>
<span class="sd">    ...         self.a = a</span>
<span class="sd">    ...     def add(self, x):</span>
<span class="sd">    ...         return self.a + x</span>
<span class="sd">    ...     def multiply(self, x):</span>
<span class="sd">    ...         return self.a * x</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; def _name_args_kwargs(func, args, kwargs) -&gt; str:</span>
<span class="sd">    ...     return &quot;Calling {} with\\n  args={}\\n  kwargs={}&quot;.format(func.__name__, args, kwargs)</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; log_calls = mk_call_logger(what_to_log=_name_args_kwargs, func_is_bounded=True)</span>
<span class="sd">    &gt;&gt;&gt; for method in [&#39;add&#39;, &#39;multiply&#39;]:</span>
<span class="sd">    ...     A_method = getattr(A, method)</span>
<span class="sd">    ...     setattr(A, method, mk_call_logger(what_to_log=_name_args_kwargs, func_is_bounded=True)(A_method))</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; a = A()</span>
<span class="sd">    &gt;&gt;&gt; a.add(x=2)</span>
<span class="sd">    Calling add with</span>
<span class="sd">      args=()</span>
<span class="sd">      kwargs={&#39;x&#39;: 2}</span>
<span class="sd">    12</span>
<span class="sd">    &gt;&gt;&gt; a.multiply(2)</span>
<span class="sd">    Calling multiply with</span>
<span class="sd">      args=(2,)</span>
<span class="sd">      kwargs={}</span>
<span class="sd">    20</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">log_output</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">log_output</span> <span class="o">=</span> <span class="s1">&#39;-&gt; </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span>
    <span class="k">assert</span> <span class="n">log_output</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span> <span class="n">callable</span><span class="p">(</span><span class="n">log_output</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">func_is_bounded</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">log_calls</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">logger</span><span class="p">(</span><span class="n">what_to_log</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">log_output</span> <span class="ow">and</span> <span class="n">logger</span><span class="p">(</span><span class="n">log_output</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">out</span>

            <span class="k">return</span> <span class="n">_func</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">log_calls</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">logger</span><span class="p">(</span><span class="n">what_to_log</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">))</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">log_output</span> <span class="ow">and</span> <span class="n">logger</span><span class="p">(</span><span class="n">log_output</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">out</span>

            <span class="k">return</span> <span class="n">_func</span>

    <span class="k">return</span> <span class="n">log_calls</span></div>


<div class="viewcode-block" id="ch_func_to_all_pk"><a class="viewcode-back" href="../../module_docs/i2/deco.html#i2.deco.ch_func_to_all_pk">[docs]</a><span class="k">def</span> <span class="nf">ch_func_to_all_pk</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a copy of the function where all arguments are of the PK kind.</span>
<span class="sd">    (PK: Positional_or_keyword)</span>

<span class="sd">    :param func: A callable</span>
<span class="sd">    :return:</span>

<span class="sd">    &gt;&gt;&gt; from py2http.decorators import signature, ch_func_to_all_pk</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; def f(a, /, b, *, c=None, **kwargs): ...</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; print(signature(f))</span>
<span class="sd">    (a, /, b, *, c=None, **kwargs)</span>
<span class="sd">    &gt;&gt;&gt; ff = ch_func_to_all_pk(f)</span>
<span class="sd">    &gt;&gt;&gt; print(signature(ff))</span>
<span class="sd">    (a, b, c=None, **kwargs)</span>
<span class="sd">    &gt;&gt;&gt; def g(x, y=1, *args, **kwargs): ...</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; print(signature(g))</span>
<span class="sd">    (x, y=1, *args, **kwargs)</span>
<span class="sd">    &gt;&gt;&gt; gg = ch_func_to_all_pk(g)</span>
<span class="sd">    &gt;&gt;&gt; print(signature(gg))</span>
<span class="sd">    (x, y=1, args=(), **kwargs)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">tuple_the_args</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">func</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">ch_signature_to_all_pk</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">i2</a></h1>








<h3>Navigation</h3>
<p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2.html">i2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/alternative_approaches.html">i2.alternative_approaches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/base.html">i2.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/chain_map.html">i2.chain_map</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/deco.html">i2.deco</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/doc_mint.html">i2.doc_mint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/errors.html">i2.errors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/footprints.html">i2.footprints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/genu.html">i2.genu</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/io_trans.html">i2.io_trans</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/itypes.html">i2.itypes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/key_path.html">i2.key_path</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/misc.html">i2.misc</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/routing_forest.html">i2.routing_forest</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/scrap.html">i2.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/signatures.html">i2.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/simple_pymint.html">i2.simple_pymint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/switch_case_tree.html">i2.switch_case_tree</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests.html">i2.tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/footprints.html">i2.tests.footprints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/objects_for_testing.html">i2.tests.objects_for_testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/tests/signatures.html">i2.tests.signatures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/util.html">i2.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/i2/vend/funcutils.html">i2.vend.funcutils</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;OtoSense 2020.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>